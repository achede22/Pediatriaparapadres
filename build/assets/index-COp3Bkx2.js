function t0(n, r) { for (var s = 0; s < r.length; s++) { const a = r[s]; if (typeof a != "string" && !Array.isArray(a)) { for (const u in a) if (u !== "default" && !(u in n)) { const f = Object.getOwnPropertyDescriptor(a, u); f && Object.defineProperty(n, u, f.get ? f : { enumerable: !0, get: () => a[u] }) } } } return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })) } (function () { const r = document.createElement("link").relList; if (r && r.supports && r.supports("modulepreload")) return; for (const u of document.querySelectorAll('link[rel="modulepreload"]')) a(u); new MutationObserver(u => { for (const f of u) if (f.type === "childList") for (const d of f.addedNodes) d.tagName === "LINK" && d.rel === "modulepreload" && a(d) }).observe(document, { childList: !0, subtree: !0 }); function s(u) { const f = {}; return u.integrity && (f.integrity = u.integrity), u.referrerPolicy && (f.referrerPolicy = u.referrerPolicy), u.crossOrigin === "use-credentials" ? f.credentials = "include" : u.crossOrigin === "anonymous" ? f.credentials = "omit" : f.credentials = "same-origin", f } function a(u) { if (u.ep) return; u.ep = !0; const f = s(u); fetch(u.href, f) } })(); function n0(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } var sl = { exports: {} }, fi = {}, ol = { exports: {} }, oe = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Mf; function r0() { if (Mf) return oe; Mf = 1; var n = Symbol.for("react.element"), r = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), f = Symbol.for("react.provider"), d = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), v = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), x = Symbol.iterator; function S(P) { return P === null || typeof P != "object" ? null : (P = x && P[x] || P["@@iterator"], typeof P == "function" ? P : null) } var N = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, b = Object.assign, A = {}; function R(P, L, se) { this.props = P, this.context = L, this.refs = A, this.updater = se || N } R.prototype.isReactComponent = {}, R.prototype.setState = function (P, L) { if (typeof P != "object" && typeof P != "function" && P != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, P, L, "setState") }, R.prototype.forceUpdate = function (P) { this.updater.enqueueForceUpdate(this, P, "forceUpdate") }; function I() { } I.prototype = R.prototype; function B(P, L, se) { this.props = P, this.context = L, this.refs = A, this.updater = se || N } var z = B.prototype = new I; z.constructor = B, b(z, R.prototype), z.isPureReactComponent = !0; var Y = Array.isArray, $ = Object.prototype.hasOwnProperty, Z = { current: null }, te = { key: !0, ref: !0, __self: !0, __source: !0 }; function Q(P, L, se) { var ae, ue = {}, ce = null, ge = null; if (L != null) for (ae in L.ref !== void 0 && (ge = L.ref), L.key !== void 0 && (ce = "" + L.key), L) $.call(L, ae) && !te.hasOwnProperty(ae) && (ue[ae] = L[ae]); var fe = arguments.length - 2; if (fe === 1) ue.children = se; else if (1 < fe) { for (var Se = Array(fe), dt = 0; dt < fe; dt++)Se[dt] = arguments[dt + 2]; ue.children = Se } if (P && P.defaultProps) for (ae in fe = P.defaultProps, fe) ue[ae] === void 0 && (ue[ae] = fe[ae]); return { $$typeof: n, type: P, key: ce, ref: ge, props: ue, _owner: Z.current } } function pe(P, L) { return { $$typeof: n, type: P.type, key: L, ref: P.ref, props: P.props, _owner: P._owner } } function ve(P) { return typeof P == "object" && P !== null && P.$$typeof === n } function He(P) { var L = { "=": "=0", ":": "=2" }; return "$" + P.replace(/[=:]/g, function (se) { return L[se] }) } var ut = /\/+/g; function Xe(P, L) { return typeof P == "object" && P !== null && P.key != null ? He("" + P.key) : L.toString(36) } function tt(P, L, se, ae, ue) { var ce = typeof P; (ce === "undefined" || ce === "boolean") && (P = null); var ge = !1; if (P === null) ge = !0; else switch (ce) { case "string": case "number": ge = !0; break; case "object": switch (P.$$typeof) { case n: case r: ge = !0 } }if (ge) return ge = P, ue = ue(ge), P = ae === "" ? "." + Xe(ge, 0) : ae, Y(ue) ? (se = "", P != null && (se = P.replace(ut, "$&/") + "/"), tt(ue, L, se, "", function (dt) { return dt })) : ue != null && (ve(ue) && (ue = pe(ue, se + (!ue.key || ge && ge.key === ue.key ? "" : ("" + ue.key).replace(ut, "$&/") + "/") + P)), L.push(ue)), 1; if (ge = 0, ae = ae === "" ? "." : ae + ":", Y(P)) for (var fe = 0; fe < P.length; fe++) { ce = P[fe]; var Se = ae + Xe(ce, fe); ge += tt(ce, L, se, Se, ue) } else if (Se = S(P), typeof Se == "function") for (P = Se.call(P), fe = 0; !(ce = P.next()).done;)ce = ce.value, Se = ae + Xe(ce, fe++), ge += tt(ce, L, se, Se, ue); else if (ce === "object") throw L = String(P), Error("Objects are not valid as a React child (found: " + (L === "[object Object]" ? "object with keys {" + Object.keys(P).join(", ") + "}" : L) + "). If you meant to render a collection of children, use an array instead."); return ge } function ct(P, L, se) { if (P == null) return P; var ae = [], ue = 0; return tt(P, ae, "", "", function (ce) { return L.call(se, ce, ue++) }), ae } function Qe(P) { if (P._status === -1) { var L = P._result; L = L(), L.then(function (se) { (P._status === 0 || P._status === -1) && (P._status = 1, P._result = se) }, function (se) { (P._status === 0 || P._status === -1) && (P._status = 2, P._result = se) }), P._status === -1 && (P._status = 0, P._result = L) } if (P._status === 1) return P._result.default; throw P._result } var ie = { current: null }, F = { transition: null }, X = { ReactCurrentDispatcher: ie, ReactCurrentBatchConfig: F, ReactCurrentOwner: Z }; function U() { throw Error("act(...) is not supported in production builds of React.") } return oe.Children = { map: ct, forEach: function (P, L, se) { ct(P, function () { L.apply(this, arguments) }, se) }, count: function (P) { var L = 0; return ct(P, function () { L++ }), L }, toArray: function (P) { return ct(P, function (L) { return L }) || [] }, only: function (P) { if (!ve(P)) throw Error("React.Children.only expected to receive a single React element child."); return P } }, oe.Component = R, oe.Fragment = s, oe.Profiler = u, oe.PureComponent = B, oe.StrictMode = a, oe.Suspense = p, oe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = X, oe.act = U, oe.cloneElement = function (P, L, se) { if (P == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + P + "."); var ae = b({}, P.props), ue = P.key, ce = P.ref, ge = P._owner; if (L != null) { if (L.ref !== void 0 && (ce = L.ref, ge = Z.current), L.key !== void 0 && (ue = "" + L.key), P.type && P.type.defaultProps) var fe = P.type.defaultProps; for (Se in L) $.call(L, Se) && !te.hasOwnProperty(Se) && (ae[Se] = L[Se] === void 0 && fe !== void 0 ? fe[Se] : L[Se]) } var Se = arguments.length - 2; if (Se === 1) ae.children = se; else if (1 < Se) { fe = Array(Se); for (var dt = 0; dt < Se; dt++)fe[dt] = arguments[dt + 2]; ae.children = fe } return { $$typeof: n, type: P.type, key: ue, ref: ce, props: ae, _owner: ge } }, oe.createContext = function (P) { return P = { $$typeof: d, _currentValue: P, _currentValue2: P, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, P.Provider = { $$typeof: f, _context: P }, P.Consumer = P }, oe.createElement = Q, oe.createFactory = function (P) { var L = Q.bind(null, P); return L.type = P, L }, oe.createRef = function () { return { current: null } }, oe.forwardRef = function (P) { return { $$typeof: h, render: P } }, oe.isValidElement = ve, oe.lazy = function (P) { return { $$typeof: y, _payload: { _status: -1, _result: P }, _init: Qe } }, oe.memo = function (P, L) { return { $$typeof: v, type: P, compare: L === void 0 ? null : L } }, oe.startTransition = function (P) { var L = F.transition; F.transition = {}; try { P() } finally { F.transition = L } }, oe.unstable_act = U, oe.useCallback = function (P, L) { return ie.current.useCallback(P, L) }, oe.useContext = function (P) { return ie.current.useContext(P) }, oe.useDebugValue = function () { }, oe.useDeferredValue = function (P) { return ie.current.useDeferredValue(P) }, oe.useEffect = function (P, L) { return ie.current.useEffect(P, L) }, oe.useId = function () { return ie.current.useId() }, oe.useImperativeHandle = function (P, L, se) { return ie.current.useImperativeHandle(P, L, se) }, oe.useInsertionEffect = function (P, L) { return ie.current.useInsertionEffect(P, L) }, oe.useLayoutEffect = function (P, L) { return ie.current.useLayoutEffect(P, L) }, oe.useMemo = function (P, L) { return ie.current.useMemo(P, L) }, oe.useReducer = function (P, L, se) { return ie.current.useReducer(P, L, se) }, oe.useRef = function (P) { return ie.current.useRef(P) }, oe.useState = function (P) { return ie.current.useState(P) }, oe.useSyncExternalStore = function (P, L, se) { return ie.current.useSyncExternalStore(P, L, se) }, oe.useTransition = function () { return ie.current.useTransition() }, oe.version = "18.3.1", oe } var Rf; function Ql() { return Rf || (Rf = 1, ol.exports = r0()), ol.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Af; function i0() { if (Af) return fi; Af = 1; var n = Ql(), r = Symbol.for("react.element"), s = Symbol.for("react.fragment"), a = Object.prototype.hasOwnProperty, u = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, f = { key: !0, ref: !0, __self: !0, __source: !0 }; function d(h, p, v) { var y, x = {}, S = null, N = null; v !== void 0 && (S = "" + v), p.key !== void 0 && (S = "" + p.key), p.ref !== void 0 && (N = p.ref); for (y in p) a.call(p, y) && !f.hasOwnProperty(y) && (x[y] = p[y]); if (h && h.defaultProps) for (y in p = h.defaultProps, p) x[y] === void 0 && (x[y] = p[y]); return { $$typeof: r, type: h, key: S, ref: N, props: x, _owner: u.current } } return fi.Fragment = s, fi.jsx = d, fi.jsxs = d, fi } var bf; function s0() { return bf || (bf = 1, sl.exports = i0()), sl.exports } var g = s0(), Ws = {}, al = { exports: {} }, at = {}, ll = { exports: {} }, ul = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Df; function o0() { return Df || (Df = 1, (function (n) { function r(F, X) { var U = F.length; F.push(X); e: for (; 0 < U;) { var P = U - 1 >>> 1, L = F[P]; if (0 < u(L, X)) F[P] = X, F[U] = L, U = P; else break e } } function s(F) { return F.length === 0 ? null : F[0] } function a(F) { if (F.length === 0) return null; var X = F[0], U = F.pop(); if (U !== X) { F[0] = U; e: for (var P = 0, L = F.length, se = L >>> 1; P < se;) { var ae = 2 * (P + 1) - 1, ue = F[ae], ce = ae + 1, ge = F[ce]; if (0 > u(ue, U)) ce < L && 0 > u(ge, ue) ? (F[P] = ge, F[ce] = U, P = ce) : (F[P] = ue, F[ae] = U, P = ae); else if (ce < L && 0 > u(ge, U)) F[P] = ge, F[ce] = U, P = ce; else break e } } return X } function u(F, X) { var U = F.sortIndex - X.sortIndex; return U !== 0 ? U : F.id - X.id } if (typeof performance == "object" && typeof performance.now == "function") { var f = performance; n.unstable_now = function () { return f.now() } } else { var d = Date, h = d.now(); n.unstable_now = function () { return d.now() - h } } var p = [], v = [], y = 1, x = null, S = 3, N = !1, b = !1, A = !1, R = typeof setTimeout == "function" ? setTimeout : null, I = typeof clearTimeout == "function" ? clearTimeout : null, B = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function z(F) { for (var X = s(v); X !== null;) { if (X.callback === null) a(v); else if (X.startTime <= F) a(v), X.sortIndex = X.expirationTime, r(p, X); else break; X = s(v) } } function Y(F) { if (A = !1, z(F), !b) if (s(p) !== null) b = !0, Qe($); else { var X = s(v); X !== null && ie(Y, X.startTime - F) } } function $(F, X) { b = !1, A && (A = !1, I(Q), Q = -1), N = !0; var U = S; try { for (z(X), x = s(p); x !== null && (!(x.expirationTime > X) || F && !He());) { var P = x.callback; if (typeof P == "function") { x.callback = null, S = x.priorityLevel; var L = P(x.expirationTime <= X); X = n.unstable_now(), typeof L == "function" ? x.callback = L : x === s(p) && a(p), z(X) } else a(p); x = s(p) } if (x !== null) var se = !0; else { var ae = s(v); ae !== null && ie(Y, ae.startTime - X), se = !1 } return se } finally { x = null, S = U, N = !1 } } var Z = !1, te = null, Q = -1, pe = 5, ve = -1; function He() { return !(n.unstable_now() - ve < pe) } function ut() { if (te !== null) { var F = n.unstable_now(); ve = F; var X = !0; try { X = te(!0, F) } finally { X ? Xe() : (Z = !1, te = null) } } else Z = !1 } var Xe; if (typeof B == "function") Xe = function () { B(ut) }; else if (typeof MessageChannel < "u") { var tt = new MessageChannel, ct = tt.port2; tt.port1.onmessage = ut, Xe = function () { ct.postMessage(null) } } else Xe = function () { R(ut, 0) }; function Qe(F) { te = F, Z || (Z = !0, Xe()) } function ie(F, X) { Q = R(function () { F(n.unstable_now()) }, X) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (F) { F.callback = null }, n.unstable_continueExecution = function () { b || N || (b = !0, Qe($)) }, n.unstable_forceFrameRate = function (F) { 0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : pe = 0 < F ? Math.floor(1e3 / F) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return S }, n.unstable_getFirstCallbackNode = function () { return s(p) }, n.unstable_next = function (F) { switch (S) { case 1: case 2: case 3: var X = 3; break; default: X = S }var U = S; S = X; try { return F() } finally { S = U } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (F, X) { switch (F) { case 1: case 2: case 3: case 4: case 5: break; default: F = 3 }var U = S; S = F; try { return X() } finally { S = U } }, n.unstable_scheduleCallback = function (F, X, U) { var P = n.unstable_now(); switch (typeof U == "object" && U !== null ? (U = U.delay, U = typeof U == "number" && 0 < U ? P + U : P) : U = P, F) { case 1: var L = -1; break; case 2: L = 250; break; case 5: L = 1073741823; break; case 4: L = 1e4; break; default: L = 5e3 }return L = U + L, F = { id: y++, callback: X, priorityLevel: F, startTime: U, expirationTime: L, sortIndex: -1 }, U > P ? (F.sortIndex = U, r(v, F), s(p) === null && F === s(v) && (A ? (I(Q), Q = -1) : A = !0, ie(Y, U - P))) : (F.sortIndex = L, r(p, F), b || N || (b = !0, Qe($))), F }, n.unstable_shouldYield = He, n.unstable_wrapCallback = function (F) { var X = S; return function () { var U = S; S = X; try { return F.apply(this, arguments) } finally { S = U } } } })(ul)), ul } var Lf; function a0() { return Lf || (Lf = 1, ll.exports = o0()), ll.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _f; function l0() {
  if (_f) return at; _f = 1; var n = Ql(), r = a0(); function s(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, i = 1; i < arguments.length; i++)t += "&args[]=" + encodeURIComponent(arguments[i]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var a = new Set, u = {}; function f(e, t) { d(e, t), d(e + "Capture", t) } function d(e, t) { for (u[e] = t, e = 0; e < t.length; e++)a.add(t[e]) } var h = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), p = Object.prototype.hasOwnProperty, v = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, y = {}, x = {}; function S(e) { return p.call(x, e) ? !0 : p.call(y, e) ? !1 : v.test(e) ? x[e] = !0 : (y[e] = !0, !1) } function N(e, t, i, o) { if (i !== null && i.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return o ? !1 : i !== null ? !i.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function b(e, t, i, o) { if (t === null || typeof t > "u" || N(e, t, i, o)) return !0; if (o) return !1; if (i !== null) switch (i.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function A(e, t, i, o, l, c, m) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = o, this.attributeNamespace = l, this.mustUseProperty = i, this.propertyName = e, this.type = t, this.sanitizeURL = c, this.removeEmptyString = m } var R = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { R[e] = new A(e, 0, !1, e, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; R[t] = new A(t, 1, !1, e[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { R[e] = new A(e, 2, !1, e.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { R[e] = new A(e, 2, !1, e, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { R[e] = new A(e, 3, !1, e.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (e) { R[e] = new A(e, 3, !0, e, null, !1, !1) }), ["capture", "download"].forEach(function (e) { R[e] = new A(e, 4, !1, e, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (e) { R[e] = new A(e, 6, !1, e, null, !1, !1) }), ["rowSpan", "start"].forEach(function (e) { R[e] = new A(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var I = /[\-:]([a-z])/g; function B(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(I, B); R[t] = new A(t, 1, !1, e, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(I, B); R[t] = new A(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(I, B); R[t] = new A(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (e) { R[e] = new A(e, 1, !1, e.toLowerCase(), null, !1, !1) }), R.xlinkHref = new A("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (e) { R[e] = new A(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function z(e, t, i, o) { var l = R.hasOwnProperty(t) ? R[t] : null; (l !== null ? l.type !== 0 : o || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (b(t, i, l, o) && (i = null), o || l === null ? S(t) && (i === null ? e.removeAttribute(t) : e.setAttribute(t, "" + i)) : l.mustUseProperty ? e[l.propertyName] = i === null ? l.type === 3 ? !1 : "" : i : (t = l.attributeName, o = l.attributeNamespace, i === null ? e.removeAttribute(t) : (l = l.type, i = l === 3 || l === 4 && i === !0 ? "" : "" + i, o ? e.setAttributeNS(o, t, i) : e.setAttribute(t, i)))) } var Y = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, $ = Symbol.for("react.element"), Z = Symbol.for("react.portal"), te = Symbol.for("react.fragment"), Q = Symbol.for("react.strict_mode"), pe = Symbol.for("react.profiler"), ve = Symbol.for("react.provider"), He = Symbol.for("react.context"), ut = Symbol.for("react.forward_ref"), Xe = Symbol.for("react.suspense"), tt = Symbol.for("react.suspense_list"), ct = Symbol.for("react.memo"), Qe = Symbol.for("react.lazy"), ie = Symbol.for("react.offscreen"), F = Symbol.iterator; function X(e) { return e === null || typeof e != "object" ? null : (e = F && e[F] || e["@@iterator"], typeof e == "function" ? e : null) } var U = Object.assign, P; function L(e) {
    if (P === void 0) try { throw Error() } catch (i) { var t = i.stack.trim().match(/\n( *(at )?)/); P = t && t[1] || "" } return `
`+ P + e
  } var se = !1; function ae(e, t) {
    if (!e || se) return ""; se = !0; var i = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (T) { var o = T } Reflect.construct(e, [], t) } else { try { t.call() } catch (T) { o = T } e.call(t.prototype) } else { try { throw Error() } catch (T) { o = T } e() } } catch (T) {
      if (T && o && typeof T.stack == "string") {
        for (var l = T.stack.split(`
`), c = o.stack.split(`
`), m = l.length - 1, w = c.length - 1; 1 <= m && 0 <= w && l[m] !== c[w];)w--; for (; 1 <= m && 0 <= w; m--, w--)if (l[m] !== c[w]) {
          if (m !== 1 || w !== 1) do if (m--, w--, 0 > w || l[m] !== c[w]) {
            var C = `
`+ l[m].replace(" at new ", " at "); return e.displayName && C.includes("<anonymous>") && (C = C.replace("<anonymous>", e.displayName)), C
          } while (1 <= m && 0 <= w); break
        }
      }
    } finally { se = !1, Error.prepareStackTrace = i } return (e = e ? e.displayName || e.name : "") ? L(e) : ""
  } function ue(e) { switch (e.tag) { case 5: return L(e.type); case 16: return L("Lazy"); case 13: return L("Suspense"); case 19: return L("SuspenseList"); case 0: case 2: case 15: return e = ae(e.type, !1), e; case 11: return e = ae(e.type.render, !1), e; case 1: return e = ae(e.type, !0), e; default: return "" } } function ce(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case te: return "Fragment"; case Z: return "Portal"; case pe: return "Profiler"; case Q: return "StrictMode"; case Xe: return "Suspense"; case tt: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case He: return (e.displayName || "Context") + ".Consumer"; case ve: return (e._context.displayName || "Context") + ".Provider"; case ut: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case ct: return t = e.displayName || null, t !== null ? t : ce(e.type) || "Memo"; case Qe: t = e._payload, e = e._init; try { return ce(e(t)) } catch { } }return null } function ge(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return ce(t); case 8: return t === Q ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function fe(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function Se(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function dt(e) { var t = Se(e) ? "checked" : "value", i = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), o = "" + e[t]; if (!e.hasOwnProperty(t) && typeof i < "u" && typeof i.get == "function" && typeof i.set == "function") { var l = i.get, c = i.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return l.call(this) }, set: function (m) { o = "" + m, c.call(this, m) } }), Object.defineProperty(e, t, { enumerable: i.enumerable }), { getValue: function () { return o }, setValue: function (m) { o = "" + m }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Li(e) { e._valueTracker || (e._valueTracker = dt(e)) } function Lu(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var i = t.getValue(), o = ""; return e && (o = Se(e) ? e.checked ? "true" : "false" : e.value), e = o, e !== i ? (t.setValue(e), !0) : !1 } function _i(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function fo(e, t) { var i = t.checked; return U({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: i ?? e._wrapperState.initialChecked }) } function _u(e, t) { var i = t.defaultValue == null ? "" : t.defaultValue, o = t.checked != null ? t.checked : t.defaultChecked; i = fe(t.value != null ? t.value : i), e._wrapperState = { initialChecked: o, initialValue: i, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function Vu(e, t) { t = t.checked, t != null && z(e, "checked", t, !1) } function ho(e, t) { Vu(e, t); var i = fe(t.value), o = t.type; if (i != null) o === "number" ? (i === 0 && e.value === "" || e.value != i) && (e.value = "" + i) : e.value !== "" + i && (e.value = "" + i); else if (o === "submit" || o === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? po(e, t.type, i) : t.hasOwnProperty("defaultValue") && po(e, t.type, fe(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function Iu(e, t, i) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var o = t.type; if (!(o !== "submit" && o !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, i || t === e.value || (e.value = t), e.defaultValue = t } i = e.name, i !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, i !== "" && (e.name = i) } function po(e, t, i) { (t !== "number" || _i(e.ownerDocument) !== e) && (i == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + i && (e.defaultValue = "" + i)) } var Tr = Array.isArray; function Un(e, t, i, o) { if (e = e.options, t) { t = {}; for (var l = 0; l < i.length; l++)t["$" + i[l]] = !0; for (i = 0; i < e.length; i++)l = t.hasOwnProperty("$" + e[i].value), e[i].selected !== l && (e[i].selected = l), l && o && (e[i].defaultSelected = !0) } else { for (i = "" + fe(i), t = null, l = 0; l < e.length; l++) { if (e[l].value === i) { e[l].selected = !0, o && (e[l].defaultSelected = !0); return } t !== null || e[l].disabled || (t = e[l]) } t !== null && (t.selected = !0) } } function mo(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(s(91)); return U({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function Ou(e, t) { var i = t.value; if (i == null) { if (i = t.children, t = t.defaultValue, i != null) { if (t != null) throw Error(s(92)); if (Tr(i)) { if (1 < i.length) throw Error(s(93)); i = i[0] } t = i } t == null && (t = ""), i = t } e._wrapperState = { initialValue: fe(i) } } function zu(e, t) { var i = fe(t.value), o = fe(t.defaultValue); i != null && (i = "" + i, i !== e.value && (e.value = i), t.defaultValue == null && e.defaultValue !== i && (e.defaultValue = i)), o != null && (e.defaultValue = "" + o) } function Fu(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function Bu(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function go(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Bu(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var Vi, Uu = (function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, i, o, l) { MSApp.execUnsafeLocalFunction(function () { return e(t, i, o, l) }) } : e })(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (Vi = Vi || document.createElement("div"), Vi.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Vi.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function Nr(e, t) { if (t) { var i = e.firstChild; if (i && i === e.lastChild && i.nodeType === 3) { i.nodeValue = t; return } } e.textContent = t } var Mr = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, sg = ["Webkit", "ms", "Moz", "O"]; Object.keys(Mr).forEach(function (e) { sg.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Mr[t] = Mr[e] }) }); function Hu(e, t, i) { return t == null || typeof t == "boolean" || t === "" ? "" : i || typeof t != "number" || t === 0 || Mr.hasOwnProperty(e) && Mr[e] ? ("" + t).trim() : t + "px" } function Wu(e, t) { e = e.style; for (var i in t) if (t.hasOwnProperty(i)) { var o = i.indexOf("--") === 0, l = Hu(i, t[i], o); i === "float" && (i = "cssFloat"), o ? e.setProperty(i, l) : e[i] = l } } var og = U({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function yo(e, t) { if (t) { if (og[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(s(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(s(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(s(61)) } if (t.style != null && typeof t.style != "object") throw Error(s(62)) } } function vo(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var xo = null; function wo(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var So = null, Hn = null, Wn = null; function $u(e) { if (e = Qr(e)) { if (typeof So != "function") throw Error(s(280)); var t = e.stateNode; t && (t = ss(t), So(e.stateNode, e.type, t)) } } function Ku(e) { Hn ? Wn ? Wn.push(e) : Wn = [e] : Hn = e } function Gu() { if (Hn) { var e = Hn, t = Wn; if (Wn = Hn = null, $u(e), t) for (e = 0; e < t.length; e++)$u(t[e]) } } function qu(e, t) { return e(t) } function Yu() { } var Co = !1; function Xu(e, t, i) { if (Co) return e(t, i); Co = !0; try { return qu(e, t, i) } finally { Co = !1, (Hn !== null || Wn !== null) && (Yu(), Gu()) } } function Rr(e, t) { var i = e.stateNode; if (i === null) return null; var o = ss(i); if (o === null) return null; i = o[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (o = !o.disabled) || (e = e.type, o = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !o; break e; default: e = !1 }if (e) return null; if (i && typeof i != "function") throw Error(s(231, t, typeof i)); return i } var ko = !1; if (h) try { var Ar = {}; Object.defineProperty(Ar, "passive", { get: function () { ko = !0 } }), window.addEventListener("test", Ar, Ar), window.removeEventListener("test", Ar, Ar) } catch { ko = !1 } function ag(e, t, i, o, l, c, m, w, C) { var T = Array.prototype.slice.call(arguments, 3); try { t.apply(i, T) } catch (_) { this.onError(_) } } var br = !1, Ii = null, Oi = !1, Po = null, lg = { onError: function (e) { br = !0, Ii = e } }; function ug(e, t, i, o, l, c, m, w, C) { br = !1, Ii = null, ag.apply(lg, arguments) } function cg(e, t, i, o, l, c, m, w, C) { if (ug.apply(this, arguments), br) { if (br) { var T = Ii; br = !1, Ii = null } else throw Error(s(198)); Oi || (Oi = !0, Po = T) } } function Cn(e) { var t = e, i = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, (t.flags & 4098) !== 0 && (i = t.return), e = t.return; while (e) } return t.tag === 3 ? i : null } function Qu(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Zu(e) { if (Cn(e) !== e) throw Error(s(188)) } function dg(e) { var t = e.alternate; if (!t) { if (t = Cn(e), t === null) throw Error(s(188)); return t !== e ? null : e } for (var i = e, o = t; ;) { var l = i.return; if (l === null) break; var c = l.alternate; if (c === null) { if (o = l.return, o !== null) { i = o; continue } break } if (l.child === c.child) { for (c = l.child; c;) { if (c === i) return Zu(l), e; if (c === o) return Zu(l), t; c = c.sibling } throw Error(s(188)) } if (i.return !== o.return) i = l, o = c; else { for (var m = !1, w = l.child; w;) { if (w === i) { m = !0, i = l, o = c; break } if (w === o) { m = !0, o = l, i = c; break } w = w.sibling } if (!m) { for (w = c.child; w;) { if (w === i) { m = !0, i = c, o = l; break } if (w === o) { m = !0, o = c, i = l; break } w = w.sibling } if (!m) throw Error(s(189)) } } if (i.alternate !== o) throw Error(s(190)) } if (i.tag !== 3) throw Error(s(188)); return i.stateNode.current === i ? e : t } function Ju(e) { return e = dg(e), e !== null ? ec(e) : null } function ec(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = ec(e); if (t !== null) return t; e = e.sibling } return null } var tc = r.unstable_scheduleCallback, nc = r.unstable_cancelCallback, fg = r.unstable_shouldYield, hg = r.unstable_requestPaint, Me = r.unstable_now, pg = r.unstable_getCurrentPriorityLevel, Eo = r.unstable_ImmediatePriority, rc = r.unstable_UserBlockingPriority, zi = r.unstable_NormalPriority, mg = r.unstable_LowPriority, ic = r.unstable_IdlePriority, Fi = null, Lt = null; function gg(e) { if (Lt && typeof Lt.onCommitFiberRoot == "function") try { Lt.onCommitFiberRoot(Fi, e, void 0, (e.current.flags & 128) === 128) } catch { } } var jt = Math.clz32 ? Math.clz32 : xg, yg = Math.log, vg = Math.LN2; function xg(e) { return e >>>= 0, e === 0 ? 32 : 31 - (yg(e) / vg | 0) | 0 } var Bi = 64, Ui = 4194304; function Dr(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Hi(e, t) { var i = e.pendingLanes; if (i === 0) return 0; var o = 0, l = e.suspendedLanes, c = e.pingedLanes, m = i & 268435455; if (m !== 0) { var w = m & ~l; w !== 0 ? o = Dr(w) : (c &= m, c !== 0 && (o = Dr(c))) } else m = i & ~l, m !== 0 ? o = Dr(m) : c !== 0 && (o = Dr(c)); if (o === 0) return 0; if (t !== 0 && t !== o && (t & l) === 0 && (l = o & -o, c = t & -t, l >= c || l === 16 && (c & 4194240) !== 0)) return t; if ((o & 4) !== 0 && (o |= i & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= o; 0 < t;)i = 31 - jt(t), l = 1 << i, o |= e[i], t &= ~l; return o } function wg(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Sg(e, t) { for (var i = e.suspendedLanes, o = e.pingedLanes, l = e.expirationTimes, c = e.pendingLanes; 0 < c;) { var m = 31 - jt(c), w = 1 << m, C = l[m]; C === -1 ? ((w & i) === 0 || (w & o) !== 0) && (l[m] = wg(w, t)) : C <= t && (e.expiredLanes |= w), c &= ~w } } function jo(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function sc() { var e = Bi; return Bi <<= 1, (Bi & 4194240) === 0 && (Bi = 64), e } function To(e) { for (var t = [], i = 0; 31 > i; i++)t.push(e); return t } function Lr(e, t, i) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - jt(t), e[t] = i } function Cg(e, t) { var i = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var o = e.eventTimes; for (e = e.expirationTimes; 0 < i;) { var l = 31 - jt(i), c = 1 << l; t[l] = 0, o[l] = -1, e[l] = -1, i &= ~c } } function No(e, t) { var i = e.entangledLanes |= t; for (e = e.entanglements; i;) { var o = 31 - jt(i), l = 1 << o; l & t | e[o] & t && (e[o] |= t), i &= ~l } } var he = 0; function oc(e) { return e &= -e, 1 < e ? 4 < e ? (e & 268435455) !== 0 ? 16 : 536870912 : 4 : 1 } var ac, Mo, lc, uc, cc, Ro = !1, Wi = [], Qt = null, Zt = null, Jt = null, _r = new Map, Vr = new Map, en = [], kg = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function dc(e, t) { switch (e) { case "focusin": case "focusout": Qt = null; break; case "dragenter": case "dragleave": Zt = null; break; case "mouseover": case "mouseout": Jt = null; break; case "pointerover": case "pointerout": _r.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": Vr.delete(t.pointerId) } } function Ir(e, t, i, o, l, c) { return e === null || e.nativeEvent !== c ? (e = { blockedOn: t, domEventName: i, eventSystemFlags: o, nativeEvent: c, targetContainers: [l] }, t !== null && (t = Qr(t), t !== null && Mo(t)), e) : (e.eventSystemFlags |= o, t = e.targetContainers, l !== null && t.indexOf(l) === -1 && t.push(l), e) } function Pg(e, t, i, o, l) { switch (t) { case "focusin": return Qt = Ir(Qt, e, t, i, o, l), !0; case "dragenter": return Zt = Ir(Zt, e, t, i, o, l), !0; case "mouseover": return Jt = Ir(Jt, e, t, i, o, l), !0; case "pointerover": var c = l.pointerId; return _r.set(c, Ir(_r.get(c) || null, e, t, i, o, l)), !0; case "gotpointercapture": return c = l.pointerId, Vr.set(c, Ir(Vr.get(c) || null, e, t, i, o, l)), !0 }return !1 } function fc(e) { var t = kn(e.target); if (t !== null) { var i = Cn(t); if (i !== null) { if (t = i.tag, t === 13) { if (t = Qu(i), t !== null) { e.blockedOn = t, cc(e.priority, function () { lc(i) }); return } } else if (t === 3 && i.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = i.tag === 3 ? i.stateNode.containerInfo : null; return } } } e.blockedOn = null } function $i(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var i = bo(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (i === null) { i = e.nativeEvent; var o = new i.constructor(i.type, i); xo = o, i.target.dispatchEvent(o), xo = null } else return t = Qr(i), t !== null && Mo(t), e.blockedOn = i, !1; t.shift() } return !0 } function hc(e, t, i) { $i(e) && i.delete(t) } function Eg() { Ro = !1, Qt !== null && $i(Qt) && (Qt = null), Zt !== null && $i(Zt) && (Zt = null), Jt !== null && $i(Jt) && (Jt = null), _r.forEach(hc), Vr.forEach(hc) } function Or(e, t) { e.blockedOn === t && (e.blockedOn = null, Ro || (Ro = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, Eg))) } function zr(e) { function t(l) { return Or(l, e) } if (0 < Wi.length) { Or(Wi[0], e); for (var i = 1; i < Wi.length; i++) { var o = Wi[i]; o.blockedOn === e && (o.blockedOn = null) } } for (Qt !== null && Or(Qt, e), Zt !== null && Or(Zt, e), Jt !== null && Or(Jt, e), _r.forEach(t), Vr.forEach(t), i = 0; i < en.length; i++)o = en[i], o.blockedOn === e && (o.blockedOn = null); for (; 0 < en.length && (i = en[0], i.blockedOn === null);)fc(i), i.blockedOn === null && en.shift() } var $n = Y.ReactCurrentBatchConfig, Ki = !0; function jg(e, t, i, o) { var l = he, c = $n.transition; $n.transition = null; try { he = 1, Ao(e, t, i, o) } finally { he = l, $n.transition = c } } function Tg(e, t, i, o) { var l = he, c = $n.transition; $n.transition = null; try { he = 4, Ao(e, t, i, o) } finally { he = l, $n.transition = c } } function Ao(e, t, i, o) { if (Ki) { var l = bo(e, t, i, o); if (l === null) Yo(e, t, o, Gi, i), dc(e, o); else if (Pg(l, e, t, i, o)) o.stopPropagation(); else if (dc(e, o), t & 4 && -1 < kg.indexOf(e)) { for (; l !== null;) { var c = Qr(l); if (c !== null && ac(c), c = bo(e, t, i, o), c === null && Yo(e, t, o, Gi, i), c === l) break; l = c } l !== null && o.stopPropagation() } else Yo(e, t, o, null, i) } } var Gi = null; function bo(e, t, i, o) { if (Gi = null, e = wo(o), e = kn(e), e !== null) if (t = Cn(e), t === null) e = null; else if (i = t.tag, i === 13) { if (e = Qu(t), e !== null) return e; e = null } else if (i === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Gi = e, null } function pc(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (pg()) { case Eo: return 1; case rc: return 4; case zi: case mg: return 16; case ic: return 536870912; default: return 16 }default: return 16 } } var tn = null, Do = null, qi = null; function mc() { if (qi) return qi; var e, t = Do, i = t.length, o, l = "value" in tn ? tn.value : tn.textContent, c = l.length; for (e = 0; e < i && t[e] === l[e]; e++); var m = i - e; for (o = 1; o <= m && t[i - o] === l[c - o]; o++); return qi = l.slice(e, 1 < o ? 1 - o : void 0) } function Yi(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function Xi() { return !0 } function gc() { return !1 } function ft(e) { function t(i, o, l, c, m) { this._reactName = i, this._targetInst = l, this.type = o, this.nativeEvent = c, this.target = m, this.currentTarget = null; for (var w in e) e.hasOwnProperty(w) && (i = e[w], this[w] = i ? i(c) : c[w]); return this.isDefaultPrevented = (c.defaultPrevented != null ? c.defaultPrevented : c.returnValue === !1) ? Xi : gc, this.isPropagationStopped = gc, this } return U(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var i = this.nativeEvent; i && (i.preventDefault ? i.preventDefault() : typeof i.returnValue != "unknown" && (i.returnValue = !1), this.isDefaultPrevented = Xi) }, stopPropagation: function () { var i = this.nativeEvent; i && (i.stopPropagation ? i.stopPropagation() : typeof i.cancelBubble != "unknown" && (i.cancelBubble = !0), this.isPropagationStopped = Xi) }, persist: function () { }, isPersistent: Xi }), t } var Kn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Lo = ft(Kn), Fr = U({}, Kn, { view: 0, detail: 0 }), Ng = ft(Fr), _o, Vo, Br, Qi = U({}, Fr, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Oo, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Br && (Br && e.type === "mousemove" ? (_o = e.screenX - Br.screenX, Vo = e.screenY - Br.screenY) : Vo = _o = 0, Br = e), _o) }, movementY: function (e) { return "movementY" in e ? e.movementY : Vo } }), yc = ft(Qi), Mg = U({}, Qi, { dataTransfer: 0 }), Rg = ft(Mg), Ag = U({}, Fr, { relatedTarget: 0 }), Io = ft(Ag), bg = U({}, Kn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Dg = ft(bg), Lg = U({}, Kn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), _g = ft(Lg), Vg = U({}, Kn, { data: 0 }), vc = ft(Vg), Ig = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Og = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, zg = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Fg(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = zg[e]) ? !!t[e] : !1 } function Oo() { return Fg } var Bg = U({}, Fr, { key: function (e) { if (e.key) { var t = Ig[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = Yi(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Og[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Oo, charCode: function (e) { return e.type === "keypress" ? Yi(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? Yi(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Ug = ft(Bg), Hg = U({}, Qi, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), xc = ft(Hg), Wg = U({}, Fr, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Oo }), $g = ft(Wg), Kg = U({}, Kn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Gg = ft(Kg), qg = U({}, Qi, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Yg = ft(qg), Xg = [9, 13, 27, 32], zo = h && "CompositionEvent" in window, Ur = null; h && "documentMode" in document && (Ur = document.documentMode); var Qg = h && "TextEvent" in window && !Ur, wc = h && (!zo || Ur && 8 < Ur && 11 >= Ur), Sc = " ", Cc = !1; function kc(e, t) { switch (e) { case "keyup": return Xg.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Pc(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Gn = !1; function Zg(e, t) { switch (e) { case "compositionend": return Pc(t); case "keypress": return t.which !== 32 ? null : (Cc = !0, Sc); case "textInput": return e = t.data, e === Sc && Cc ? null : e; default: return null } } function Jg(e, t) { if (Gn) return e === "compositionend" || !zo && kc(e, t) ? (e = mc(), qi = Do = tn = null, Gn = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return wc && t.locale !== "ko" ? null : t.data; default: return null } } var ey = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Ec(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!ey[e.type] : t === "textarea" } function jc(e, t, i, o) { Ku(o), t = ns(t, "onChange"), 0 < t.length && (i = new Lo("onChange", "change", null, i, o), e.push({ event: i, listeners: t })) } var Hr = null, Wr = null; function ty(e) { Wc(e, 0) } function Zi(e) { var t = Zn(e); if (Lu(t)) return e } function ny(e, t) { if (e === "change") return t } var Tc = !1; if (h) { var Fo; if (h) { var Bo = "oninput" in document; if (!Bo) { var Nc = document.createElement("div"); Nc.setAttribute("oninput", "return;"), Bo = typeof Nc.oninput == "function" } Fo = Bo } else Fo = !1; Tc = Fo && (!document.documentMode || 9 < document.documentMode) } function Mc() { Hr && (Hr.detachEvent("onpropertychange", Rc), Wr = Hr = null) } function Rc(e) { if (e.propertyName === "value" && Zi(Wr)) { var t = []; jc(t, Wr, e, wo(e)), Xu(ty, t) } } function ry(e, t, i) { e === "focusin" ? (Mc(), Hr = t, Wr = i, Hr.attachEvent("onpropertychange", Rc)) : e === "focusout" && Mc() } function iy(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return Zi(Wr) } function sy(e, t) { if (e === "click") return Zi(t) } function oy(e, t) { if (e === "input" || e === "change") return Zi(t) } function ay(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var Tt = typeof Object.is == "function" ? Object.is : ay; function $r(e, t) { if (Tt(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var i = Object.keys(e), o = Object.keys(t); if (i.length !== o.length) return !1; for (o = 0; o < i.length; o++) { var l = i[o]; if (!p.call(t, l) || !Tt(e[l], t[l])) return !1 } return !0 } function Ac(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function bc(e, t) { var i = Ac(e); e = 0; for (var o; i;) { if (i.nodeType === 3) { if (o = e + i.textContent.length, e <= t && o >= t) return { node: i, offset: t - e }; e = o } e: { for (; i;) { if (i.nextSibling) { i = i.nextSibling; break e } i = i.parentNode } i = void 0 } i = Ac(i) } } function Dc(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? Dc(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function Lc() { for (var e = window, t = _i(); t instanceof e.HTMLIFrameElement;) { try { var i = typeof t.contentWindow.location.href == "string" } catch { i = !1 } if (i) e = t.contentWindow; else break; t = _i(e.document) } return t } function Uo(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function ly(e) { var t = Lc(), i = e.focusedElem, o = e.selectionRange; if (t !== i && i && i.ownerDocument && Dc(i.ownerDocument.documentElement, i)) { if (o !== null && Uo(i)) { if (t = o.start, e = o.end, e === void 0 && (e = t), "selectionStart" in i) i.selectionStart = t, i.selectionEnd = Math.min(e, i.value.length); else if (e = (t = i.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var l = i.textContent.length, c = Math.min(o.start, l); o = o.end === void 0 ? c : Math.min(o.end, l), !e.extend && c > o && (l = o, o = c, c = l), l = bc(i, c); var m = bc(i, o); l && m && (e.rangeCount !== 1 || e.anchorNode !== l.node || e.anchorOffset !== l.offset || e.focusNode !== m.node || e.focusOffset !== m.offset) && (t = t.createRange(), t.setStart(l.node, l.offset), e.removeAllRanges(), c > o ? (e.addRange(t), e.extend(m.node, m.offset)) : (t.setEnd(m.node, m.offset), e.addRange(t))) } } for (t = [], e = i; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof i.focus == "function" && i.focus(), i = 0; i < t.length; i++)e = t[i], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var uy = h && "documentMode" in document && 11 >= document.documentMode, qn = null, Ho = null, Kr = null, Wo = !1; function _c(e, t, i) { var o = i.window === i ? i.document : i.nodeType === 9 ? i : i.ownerDocument; Wo || qn == null || qn !== _i(o) || (o = qn, "selectionStart" in o && Uo(o) ? o = { start: o.selectionStart, end: o.selectionEnd } : (o = (o.ownerDocument && o.ownerDocument.defaultView || window).getSelection(), o = { anchorNode: o.anchorNode, anchorOffset: o.anchorOffset, focusNode: o.focusNode, focusOffset: o.focusOffset }), Kr && $r(Kr, o) || (Kr = o, o = ns(Ho, "onSelect"), 0 < o.length && (t = new Lo("onSelect", "select", null, t, i), e.push({ event: t, listeners: o }), t.target = qn))) } function Ji(e, t) { var i = {}; return i[e.toLowerCase()] = t.toLowerCase(), i["Webkit" + e] = "webkit" + t, i["Moz" + e] = "moz" + t, i } var Yn = { animationend: Ji("Animation", "AnimationEnd"), animationiteration: Ji("Animation", "AnimationIteration"), animationstart: Ji("Animation", "AnimationStart"), transitionend: Ji("Transition", "TransitionEnd") }, $o = {}, Vc = {}; h && (Vc = document.createElement("div").style, "AnimationEvent" in window || (delete Yn.animationend.animation, delete Yn.animationiteration.animation, delete Yn.animationstart.animation), "TransitionEvent" in window || delete Yn.transitionend.transition); function es(e) { if ($o[e]) return $o[e]; if (!Yn[e]) return e; var t = Yn[e], i; for (i in t) if (t.hasOwnProperty(i) && i in Vc) return $o[e] = t[i]; return e } var Ic = es("animationend"), Oc = es("animationiteration"), zc = es("animationstart"), Fc = es("transitionend"), Bc = new Map, Uc = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function nn(e, t) { Bc.set(e, t), f(t, [e]) } for (var Ko = 0; Ko < Uc.length; Ko++) { var Go = Uc[Ko], cy = Go.toLowerCase(), dy = Go[0].toUpperCase() + Go.slice(1); nn(cy, "on" + dy) } nn(Ic, "onAnimationEnd"), nn(Oc, "onAnimationIteration"), nn(zc, "onAnimationStart"), nn("dblclick", "onDoubleClick"), nn("focusin", "onFocus"), nn("focusout", "onBlur"), nn(Fc, "onTransitionEnd"), d("onMouseEnter", ["mouseout", "mouseover"]), d("onMouseLeave", ["mouseout", "mouseover"]), d("onPointerEnter", ["pointerout", "pointerover"]), d("onPointerLeave", ["pointerout", "pointerover"]), f("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), f("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), f("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), f("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), f("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Gr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), fy = new Set("cancel close invalid load scroll toggle".split(" ").concat(Gr)); function Hc(e, t, i) { var o = e.type || "unknown-event"; e.currentTarget = i, cg(o, t, void 0, e), e.currentTarget = null } function Wc(e, t) { t = (t & 4) !== 0; for (var i = 0; i < e.length; i++) { var o = e[i], l = o.event; o = o.listeners; e: { var c = void 0; if (t) for (var m = o.length - 1; 0 <= m; m--) { var w = o[m], C = w.instance, T = w.currentTarget; if (w = w.listener, C !== c && l.isPropagationStopped()) break e; Hc(l, w, T), c = C } else for (m = 0; m < o.length; m++) { if (w = o[m], C = w.instance, T = w.currentTarget, w = w.listener, C !== c && l.isPropagationStopped()) break e; Hc(l, w, T), c = C } } } if (Oi) throw e = Po, Oi = !1, Po = null, e } function xe(e, t) { var i = t[ta]; i === void 0 && (i = t[ta] = new Set); var o = e + "__bubble"; i.has(o) || ($c(t, e, 2, !1), i.add(o)) } function qo(e, t, i) { var o = 0; t && (o |= 4), $c(i, e, o, t) } var ts = "_reactListening" + Math.random().toString(36).slice(2); function qr(e) { if (!e[ts]) { e[ts] = !0, a.forEach(function (i) { i !== "selectionchange" && (fy.has(i) || qo(i, !1, e), qo(i, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[ts] || (t[ts] = !0, qo("selectionchange", !1, t)) } } function $c(e, t, i, o) { switch (pc(t)) { case 1: var l = jg; break; case 4: l = Tg; break; default: l = Ao }i = l.bind(null, t, i, e), l = void 0, !ko || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (l = !0), o ? l !== void 0 ? e.addEventListener(t, i, { capture: !0, passive: l }) : e.addEventListener(t, i, !0) : l !== void 0 ? e.addEventListener(t, i, { passive: l }) : e.addEventListener(t, i, !1) } function Yo(e, t, i, o, l) { var c = o; if ((t & 1) === 0 && (t & 2) === 0 && o !== null) e: for (; ;) { if (o === null) return; var m = o.tag; if (m === 3 || m === 4) { var w = o.stateNode.containerInfo; if (w === l || w.nodeType === 8 && w.parentNode === l) break; if (m === 4) for (m = o.return; m !== null;) { var C = m.tag; if ((C === 3 || C === 4) && (C = m.stateNode.containerInfo, C === l || C.nodeType === 8 && C.parentNode === l)) return; m = m.return } for (; w !== null;) { if (m = kn(w), m === null) return; if (C = m.tag, C === 5 || C === 6) { o = c = m; continue e } w = w.parentNode } } o = o.return } Xu(function () { var T = c, _ = wo(i), V = []; e: { var D = Bc.get(e); if (D !== void 0) { var H = Lo, K = e; switch (e) { case "keypress": if (Yi(i) === 0) break e; case "keydown": case "keyup": H = Ug; break; case "focusin": K = "focus", H = Io; break; case "focusout": K = "blur", H = Io; break; case "beforeblur": case "afterblur": H = Io; break; case "click": if (i.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": H = yc; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": H = Rg; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": H = $g; break; case Ic: case Oc: case zc: H = Dg; break; case Fc: H = Gg; break; case "scroll": H = Ng; break; case "wheel": H = Yg; break; case "copy": case "cut": case "paste": H = _g; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": H = xc }var G = (t & 4) !== 0, Re = !G && e === "scroll", E = G ? D !== null ? D + "Capture" : null : D; G = []; for (var k = T, j; k !== null;) { j = k; var O = j.stateNode; if (j.tag === 5 && O !== null && (j = O, E !== null && (O = Rr(k, E), O != null && G.push(Yr(k, O, j)))), Re) break; k = k.return } 0 < G.length && (D = new H(D, K, null, i, _), V.push({ event: D, listeners: G })) } } if ((t & 7) === 0) { e: { if (D = e === "mouseover" || e === "pointerover", H = e === "mouseout" || e === "pointerout", D && i !== xo && (K = i.relatedTarget || i.fromElement) && (kn(K) || K[Bt])) break e; if ((H || D) && (D = _.window === _ ? _ : (D = _.ownerDocument) ? D.defaultView || D.parentWindow : window, H ? (K = i.relatedTarget || i.toElement, H = T, K = K ? kn(K) : null, K !== null && (Re = Cn(K), K !== Re || K.tag !== 5 && K.tag !== 6) && (K = null)) : (H = null, K = T), H !== K)) { if (G = yc, O = "onMouseLeave", E = "onMouseEnter", k = "mouse", (e === "pointerout" || e === "pointerover") && (G = xc, O = "onPointerLeave", E = "onPointerEnter", k = "pointer"), Re = H == null ? D : Zn(H), j = K == null ? D : Zn(K), D = new G(O, k + "leave", H, i, _), D.target = Re, D.relatedTarget = j, O = null, kn(_) === T && (G = new G(E, k + "enter", K, i, _), G.target = j, G.relatedTarget = Re, O = G), Re = O, H && K) t: { for (G = H, E = K, k = 0, j = G; j; j = Xn(j))k++; for (j = 0, O = E; O; O = Xn(O))j++; for (; 0 < k - j;)G = Xn(G), k--; for (; 0 < j - k;)E = Xn(E), j--; for (; k--;) { if (G === E || E !== null && G === E.alternate) break t; G = Xn(G), E = Xn(E) } G = null } else G = null; H !== null && Kc(V, D, H, G, !1), K !== null && Re !== null && Kc(V, Re, K, G, !0) } } e: { if (D = T ? Zn(T) : window, H = D.nodeName && D.nodeName.toLowerCase(), H === "select" || H === "input" && D.type === "file") var q = ny; else if (Ec(D)) if (Tc) q = oy; else { q = iy; var J = ry } else (H = D.nodeName) && H.toLowerCase() === "input" && (D.type === "checkbox" || D.type === "radio") && (q = sy); if (q && (q = q(e, T))) { jc(V, q, i, _); break e } J && J(e, D, T), e === "focusout" && (J = D._wrapperState) && J.controlled && D.type === "number" && po(D, "number", D.value) } switch (J = T ? Zn(T) : window, e) { case "focusin": (Ec(J) || J.contentEditable === "true") && (qn = J, Ho = T, Kr = null); break; case "focusout": Kr = Ho = qn = null; break; case "mousedown": Wo = !0; break; case "contextmenu": case "mouseup": case "dragend": Wo = !1, _c(V, i, _); break; case "selectionchange": if (uy) break; case "keydown": case "keyup": _c(V, i, _) }var ee; if (zo) e: { switch (e) { case "compositionstart": var re = "onCompositionStart"; break e; case "compositionend": re = "onCompositionEnd"; break e; case "compositionupdate": re = "onCompositionUpdate"; break e }re = void 0 } else Gn ? kc(e, i) && (re = "onCompositionEnd") : e === "keydown" && i.keyCode === 229 && (re = "onCompositionStart"); re && (wc && i.locale !== "ko" && (Gn || re !== "onCompositionStart" ? re === "onCompositionEnd" && Gn && (ee = mc()) : (tn = _, Do = "value" in tn ? tn.value : tn.textContent, Gn = !0)), J = ns(T, re), 0 < J.length && (re = new vc(re, e, null, i, _), V.push({ event: re, listeners: J }), ee ? re.data = ee : (ee = Pc(i), ee !== null && (re.data = ee)))), (ee = Qg ? Zg(e, i) : Jg(e, i)) && (T = ns(T, "onBeforeInput"), 0 < T.length && (_ = new vc("onBeforeInput", "beforeinput", null, i, _), V.push({ event: _, listeners: T }), _.data = ee)) } Wc(V, t) }) } function Yr(e, t, i) { return { instance: e, listener: t, currentTarget: i } } function ns(e, t) { for (var i = t + "Capture", o = []; e !== null;) { var l = e, c = l.stateNode; l.tag === 5 && c !== null && (l = c, c = Rr(e, i), c != null && o.unshift(Yr(e, c, l)), c = Rr(e, t), c != null && o.push(Yr(e, c, l))), e = e.return } return o } function Xn(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Kc(e, t, i, o, l) { for (var c = t._reactName, m = []; i !== null && i !== o;) { var w = i, C = w.alternate, T = w.stateNode; if (C !== null && C === o) break; w.tag === 5 && T !== null && (w = T, l ? (C = Rr(i, c), C != null && m.unshift(Yr(i, C, w))) : l || (C = Rr(i, c), C != null && m.push(Yr(i, C, w)))), i = i.return } m.length !== 0 && e.push({ event: t, listeners: m }) } var hy = /\r\n?/g, py = /\u0000|\uFFFD/g; function Gc(e) {
    return (typeof e == "string" ? e : "" + e).replace(hy, `
`).replace(py, "")
  } function rs(e, t, i) { if (t = Gc(t), Gc(e) !== t && i) throw Error(s(425)) } function is() { } var Xo = null, Qo = null; function Zo(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var Jo = typeof setTimeout == "function" ? setTimeout : void 0, my = typeof clearTimeout == "function" ? clearTimeout : void 0, qc = typeof Promise == "function" ? Promise : void 0, gy = typeof queueMicrotask == "function" ? queueMicrotask : typeof qc < "u" ? function (e) { return qc.resolve(null).then(e).catch(yy) } : Jo; function yy(e) { setTimeout(function () { throw e }) } function ea(e, t) { var i = t, o = 0; do { var l = i.nextSibling; if (e.removeChild(i), l && l.nodeType === 8) if (i = l.data, i === "/$") { if (o === 0) { e.removeChild(l), zr(t); return } o-- } else i !== "$" && i !== "$?" && i !== "$!" || o++; i = l } while (i); zr(t) } function rn(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function Yc(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "$" || i === "$!" || i === "$?") { if (t === 0) return e; t-- } else i === "/$" && t++ } e = e.previousSibling } return null } var Qn = Math.random().toString(36).slice(2), _t = "__reactFiber$" + Qn, Xr = "__reactProps$" + Qn, Bt = "__reactContainer$" + Qn, ta = "__reactEvents$" + Qn, vy = "__reactListeners$" + Qn, xy = "__reactHandles$" + Qn; function kn(e) { var t = e[_t]; if (t) return t; for (var i = e.parentNode; i;) { if (t = i[Bt] || i[_t]) { if (i = t.alternate, t.child !== null || i !== null && i.child !== null) for (e = Yc(e); e !== null;) { if (i = e[_t]) return i; e = Yc(e) } return t } e = i, i = e.parentNode } return null } function Qr(e) { return e = e[_t] || e[Bt], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function Zn(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(s(33)) } function ss(e) { return e[Xr] || null } var na = [], Jn = -1; function sn(e) { return { current: e } } function we(e) { 0 > Jn || (e.current = na[Jn], na[Jn] = null, Jn--) } function ye(e, t) { Jn++, na[Jn] = e.current, e.current = t } var on = {}, We = sn(on), nt = sn(!1), Pn = on; function er(e, t) { var i = e.type.contextTypes; if (!i) return on; var o = e.stateNode; if (o && o.__reactInternalMemoizedUnmaskedChildContext === t) return o.__reactInternalMemoizedMaskedChildContext; var l = {}, c; for (c in i) l[c] = t[c]; return o && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = l), l } function rt(e) { return e = e.childContextTypes, e != null } function os() { we(nt), we(We) } function Xc(e, t, i) { if (We.current !== on) throw Error(s(168)); ye(We, t), ye(nt, i) } function Qc(e, t, i) { var o = e.stateNode; if (t = t.childContextTypes, typeof o.getChildContext != "function") return i; o = o.getChildContext(); for (var l in o) if (!(l in t)) throw Error(s(108, ge(e) || "Unknown", l)); return U({}, i, o) } function as(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || on, Pn = We.current, ye(We, e), ye(nt, nt.current), !0 } function Zc(e, t, i) { var o = e.stateNode; if (!o) throw Error(s(169)); i ? (e = Qc(e, t, Pn), o.__reactInternalMemoizedMergedChildContext = e, we(nt), we(We), ye(We, e)) : we(nt), ye(nt, i) } var Ut = null, ls = !1, ra = !1; function Jc(e) { Ut === null ? Ut = [e] : Ut.push(e) } function wy(e) { ls = !0, Jc(e) } function an() { if (!ra && Ut !== null) { ra = !0; var e = 0, t = he; try { var i = Ut; for (he = 1; e < i.length; e++) { var o = i[e]; do o = o(!0); while (o !== null) } Ut = null, ls = !1 } catch (l) { throw Ut !== null && (Ut = Ut.slice(e + 1)), tc(Eo, an), l } finally { he = t, ra = !1 } } return null } var tr = [], nr = 0, us = null, cs = 0, gt = [], yt = 0, En = null, Ht = 1, Wt = ""; function jn(e, t) { tr[nr++] = cs, tr[nr++] = us, us = e, cs = t } function ed(e, t, i) { gt[yt++] = Ht, gt[yt++] = Wt, gt[yt++] = En, En = e; var o = Ht; e = Wt; var l = 32 - jt(o) - 1; o &= ~(1 << l), i += 1; var c = 32 - jt(t) + l; if (30 < c) { var m = l - l % 5; c = (o & (1 << m) - 1).toString(32), o >>= m, l -= m, Ht = 1 << 32 - jt(t) + l | i << l | o, Wt = c + e } else Ht = 1 << c | i << l | o, Wt = e } function ia(e) { e.return !== null && (jn(e, 1), ed(e, 1, 0)) } function sa(e) { for (; e === us;)us = tr[--nr], tr[nr] = null, cs = tr[--nr], tr[nr] = null; for (; e === En;)En = gt[--yt], gt[yt] = null, Wt = gt[--yt], gt[yt] = null, Ht = gt[--yt], gt[yt] = null } var ht = null, pt = null, Ce = !1, Nt = null; function td(e, t) { var i = St(5, null, null, 0); i.elementType = "DELETED", i.stateNode = t, i.return = e, t = e.deletions, t === null ? (e.deletions = [i], e.flags |= 16) : t.push(i) } function nd(e, t) { switch (e.tag) { case 5: var i = e.type; return t = t.nodeType !== 1 || i.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, ht = e, pt = rn(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, ht = e, pt = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (i = En !== null ? { id: Ht, overflow: Wt } : null, e.memoizedState = { dehydrated: t, treeContext: i, retryLane: 1073741824 }, i = St(18, null, null, 0), i.stateNode = t, i.return = e, e.child = i, ht = e, pt = null, !0) : !1; default: return !1 } } function oa(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function aa(e) { if (Ce) { var t = pt; if (t) { var i = t; if (!nd(e, t)) { if (oa(e)) throw Error(s(418)); t = rn(i.nextSibling); var o = ht; t && nd(e, t) ? td(o, i) : (e.flags = e.flags & -4097 | 2, Ce = !1, ht = e) } } else { if (oa(e)) throw Error(s(418)); e.flags = e.flags & -4097 | 2, Ce = !1, ht = e } } } function rd(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; ht = e } function ds(e) { if (e !== ht) return !1; if (!Ce) return rd(e), Ce = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !Zo(e.type, e.memoizedProps)), t && (t = pt)) { if (oa(e)) throw id(), Error(s(418)); for (; t;)td(e, t), t = rn(t.nextSibling) } if (rd(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(s(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "/$") { if (t === 0) { pt = rn(e.nextSibling); break e } t-- } else i !== "$" && i !== "$!" && i !== "$?" || t++ } e = e.nextSibling } pt = null } } else pt = ht ? rn(e.stateNode.nextSibling) : null; return !0 } function id() { for (var e = pt; e;)e = rn(e.nextSibling) } function rr() { pt = ht = null, Ce = !1 } function la(e) { Nt === null ? Nt = [e] : Nt.push(e) } var Sy = Y.ReactCurrentBatchConfig; function Zr(e, t, i) { if (e = i.ref, e !== null && typeof e != "function" && typeof e != "object") { if (i._owner) { if (i = i._owner, i) { if (i.tag !== 1) throw Error(s(309)); var o = i.stateNode } if (!o) throw Error(s(147, e)); var l = o, c = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === c ? t.ref : (t = function (m) { var w = l.refs; m === null ? delete w[c] : w[c] = m }, t._stringRef = c, t) } if (typeof e != "string") throw Error(s(284)); if (!i._owner) throw Error(s(290, e)) } return e } function fs(e, t) { throw e = Object.prototype.toString.call(t), Error(s(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function sd(e) { var t = e._init; return t(e._payload) } function od(e) { function t(E, k) { if (e) { var j = E.deletions; j === null ? (E.deletions = [k], E.flags |= 16) : j.push(k) } } function i(E, k) { if (!e) return null; for (; k !== null;)t(E, k), k = k.sibling; return null } function o(E, k) { for (E = new Map; k !== null;)k.key !== null ? E.set(k.key, k) : E.set(k.index, k), k = k.sibling; return E } function l(E, k) { return E = mn(E, k), E.index = 0, E.sibling = null, E } function c(E, k, j) { return E.index = j, e ? (j = E.alternate, j !== null ? (j = j.index, j < k ? (E.flags |= 2, k) : j) : (E.flags |= 2, k)) : (E.flags |= 1048576, k) } function m(E) { return e && E.alternate === null && (E.flags |= 2), E } function w(E, k, j, O) { return k === null || k.tag !== 6 ? (k = Ja(j, E.mode, O), k.return = E, k) : (k = l(k, j), k.return = E, k) } function C(E, k, j, O) { var q = j.type; return q === te ? _(E, k, j.props.children, O, j.key) : k !== null && (k.elementType === q || typeof q == "object" && q !== null && q.$$typeof === Qe && sd(q) === k.type) ? (O = l(k, j.props), O.ref = Zr(E, k, j), O.return = E, O) : (O = Vs(j.type, j.key, j.props, null, E.mode, O), O.ref = Zr(E, k, j), O.return = E, O) } function T(E, k, j, O) { return k === null || k.tag !== 4 || k.stateNode.containerInfo !== j.containerInfo || k.stateNode.implementation !== j.implementation ? (k = el(j, E.mode, O), k.return = E, k) : (k = l(k, j.children || []), k.return = E, k) } function _(E, k, j, O, q) { return k === null || k.tag !== 7 ? (k = Ln(j, E.mode, O, q), k.return = E, k) : (k = l(k, j), k.return = E, k) } function V(E, k, j) { if (typeof k == "string" && k !== "" || typeof k == "number") return k = Ja("" + k, E.mode, j), k.return = E, k; if (typeof k == "object" && k !== null) { switch (k.$$typeof) { case $: return j = Vs(k.type, k.key, k.props, null, E.mode, j), j.ref = Zr(E, null, k), j.return = E, j; case Z: return k = el(k, E.mode, j), k.return = E, k; case Qe: var O = k._init; return V(E, O(k._payload), j) }if (Tr(k) || X(k)) return k = Ln(k, E.mode, j, null), k.return = E, k; fs(E, k) } return null } function D(E, k, j, O) { var q = k !== null ? k.key : null; if (typeof j == "string" && j !== "" || typeof j == "number") return q !== null ? null : w(E, k, "" + j, O); if (typeof j == "object" && j !== null) { switch (j.$$typeof) { case $: return j.key === q ? C(E, k, j, O) : null; case Z: return j.key === q ? T(E, k, j, O) : null; case Qe: return q = j._init, D(E, k, q(j._payload), O) }if (Tr(j) || X(j)) return q !== null ? null : _(E, k, j, O, null); fs(E, j) } return null } function H(E, k, j, O, q) { if (typeof O == "string" && O !== "" || typeof O == "number") return E = E.get(j) || null, w(k, E, "" + O, q); if (typeof O == "object" && O !== null) { switch (O.$$typeof) { case $: return E = E.get(O.key === null ? j : O.key) || null, C(k, E, O, q); case Z: return E = E.get(O.key === null ? j : O.key) || null, T(k, E, O, q); case Qe: var J = O._init; return H(E, k, j, J(O._payload), q) }if (Tr(O) || X(O)) return E = E.get(j) || null, _(k, E, O, q, null); fs(k, O) } return null } function K(E, k, j, O) { for (var q = null, J = null, ee = k, re = k = 0, ze = null; ee !== null && re < j.length; re++) { ee.index > re ? (ze = ee, ee = null) : ze = ee.sibling; var de = D(E, ee, j[re], O); if (de === null) { ee === null && (ee = ze); break } e && ee && de.alternate === null && t(E, ee), k = c(de, k, re), J === null ? q = de : J.sibling = de, J = de, ee = ze } if (re === j.length) return i(E, ee), Ce && jn(E, re), q; if (ee === null) { for (; re < j.length; re++)ee = V(E, j[re], O), ee !== null && (k = c(ee, k, re), J === null ? q = ee : J.sibling = ee, J = ee); return Ce && jn(E, re), q } for (ee = o(E, ee); re < j.length; re++)ze = H(ee, E, re, j[re], O), ze !== null && (e && ze.alternate !== null && ee.delete(ze.key === null ? re : ze.key), k = c(ze, k, re), J === null ? q = ze : J.sibling = ze, J = ze); return e && ee.forEach(function (gn) { return t(E, gn) }), Ce && jn(E, re), q } function G(E, k, j, O) { var q = X(j); if (typeof q != "function") throw Error(s(150)); if (j = q.call(j), j == null) throw Error(s(151)); for (var J = q = null, ee = k, re = k = 0, ze = null, de = j.next(); ee !== null && !de.done; re++, de = j.next()) { ee.index > re ? (ze = ee, ee = null) : ze = ee.sibling; var gn = D(E, ee, de.value, O); if (gn === null) { ee === null && (ee = ze); break } e && ee && gn.alternate === null && t(E, ee), k = c(gn, k, re), J === null ? q = gn : J.sibling = gn, J = gn, ee = ze } if (de.done) return i(E, ee), Ce && jn(E, re), q; if (ee === null) { for (; !de.done; re++, de = j.next())de = V(E, de.value, O), de !== null && (k = c(de, k, re), J === null ? q = de : J.sibling = de, J = de); return Ce && jn(E, re), q } for (ee = o(E, ee); !de.done; re++, de = j.next())de = H(ee, E, re, de.value, O), de !== null && (e && de.alternate !== null && ee.delete(de.key === null ? re : de.key), k = c(de, k, re), J === null ? q = de : J.sibling = de, J = de); return e && ee.forEach(function (e0) { return t(E, e0) }), Ce && jn(E, re), q } function Re(E, k, j, O) { if (typeof j == "object" && j !== null && j.type === te && j.key === null && (j = j.props.children), typeof j == "object" && j !== null) { switch (j.$$typeof) { case $: e: { for (var q = j.key, J = k; J !== null;) { if (J.key === q) { if (q = j.type, q === te) { if (J.tag === 7) { i(E, J.sibling), k = l(J, j.props.children), k.return = E, E = k; break e } } else if (J.elementType === q || typeof q == "object" && q !== null && q.$$typeof === Qe && sd(q) === J.type) { i(E, J.sibling), k = l(J, j.props), k.ref = Zr(E, J, j), k.return = E, E = k; break e } i(E, J); break } else t(E, J); J = J.sibling } j.type === te ? (k = Ln(j.props.children, E.mode, O, j.key), k.return = E, E = k) : (O = Vs(j.type, j.key, j.props, null, E.mode, O), O.ref = Zr(E, k, j), O.return = E, E = O) } return m(E); case Z: e: { for (J = j.key; k !== null;) { if (k.key === J) if (k.tag === 4 && k.stateNode.containerInfo === j.containerInfo && k.stateNode.implementation === j.implementation) { i(E, k.sibling), k = l(k, j.children || []), k.return = E, E = k; break e } else { i(E, k); break } else t(E, k); k = k.sibling } k = el(j, E.mode, O), k.return = E, E = k } return m(E); case Qe: return J = j._init, Re(E, k, J(j._payload), O) }if (Tr(j)) return K(E, k, j, O); if (X(j)) return G(E, k, j, O); fs(E, j) } return typeof j == "string" && j !== "" || typeof j == "number" ? (j = "" + j, k !== null && k.tag === 6 ? (i(E, k.sibling), k = l(k, j), k.return = E, E = k) : (i(E, k), k = Ja(j, E.mode, O), k.return = E, E = k), m(E)) : i(E, k) } return Re } var ir = od(!0), ad = od(!1), hs = sn(null), ps = null, sr = null, ua = null; function ca() { ua = sr = ps = null } function da(e) { var t = hs.current; we(hs), e._currentValue = t } function fa(e, t, i) { for (; e !== null;) { var o = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, o !== null && (o.childLanes |= t)) : o !== null && (o.childLanes & t) !== t && (o.childLanes |= t), e === i) break; e = e.return } } function or(e, t) { ps = e, ua = sr = null, e = e.dependencies, e !== null && e.firstContext !== null && ((e.lanes & t) !== 0 && (it = !0), e.firstContext = null) } function vt(e) { var t = e._currentValue; if (ua !== e) if (e = { context: e, memoizedValue: t, next: null }, sr === null) { if (ps === null) throw Error(s(308)); sr = e, ps.dependencies = { lanes: 0, firstContext: e } } else sr = sr.next = e; return t } var Tn = null; function ha(e) { Tn === null ? Tn = [e] : Tn.push(e) } function ld(e, t, i, o) { var l = t.interleaved; return l === null ? (i.next = i, ha(t)) : (i.next = l.next, l.next = i), t.interleaved = i, $t(e, o) } function $t(e, t) { e.lanes |= t; var i = e.alternate; for (i !== null && (i.lanes |= t), i = e, e = e.return; e !== null;)e.childLanes |= t, i = e.alternate, i !== null && (i.childLanes |= t), i = e, e = e.return; return i.tag === 3 ? i.stateNode : null } var ln = !1; function pa(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function ud(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Kt(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function un(e, t, i) { var o = e.updateQueue; if (o === null) return null; if (o = o.shared, (le & 2) !== 0) { var l = o.pending; return l === null ? t.next = t : (t.next = l.next, l.next = t), o.pending = t, $t(e, i) } return l = o.interleaved, l === null ? (t.next = t, ha(o)) : (t.next = l.next, l.next = t), o.interleaved = t, $t(e, i) } function ms(e, t, i) { if (t = t.updateQueue, t !== null && (t = t.shared, (i & 4194240) !== 0)) { var o = t.lanes; o &= e.pendingLanes, i |= o, t.lanes = i, No(e, i) } } function cd(e, t) { var i = e.updateQueue, o = e.alternate; if (o !== null && (o = o.updateQueue, i === o)) { var l = null, c = null; if (i = i.firstBaseUpdate, i !== null) { do { var m = { eventTime: i.eventTime, lane: i.lane, tag: i.tag, payload: i.payload, callback: i.callback, next: null }; c === null ? l = c = m : c = c.next = m, i = i.next } while (i !== null); c === null ? l = c = t : c = c.next = t } else l = c = t; i = { baseState: o.baseState, firstBaseUpdate: l, lastBaseUpdate: c, shared: o.shared, effects: o.effects }, e.updateQueue = i; return } e = i.lastBaseUpdate, e === null ? i.firstBaseUpdate = t : e.next = t, i.lastBaseUpdate = t } function gs(e, t, i, o) { var l = e.updateQueue; ln = !1; var c = l.firstBaseUpdate, m = l.lastBaseUpdate, w = l.shared.pending; if (w !== null) { l.shared.pending = null; var C = w, T = C.next; C.next = null, m === null ? c = T : m.next = T, m = C; var _ = e.alternate; _ !== null && (_ = _.updateQueue, w = _.lastBaseUpdate, w !== m && (w === null ? _.firstBaseUpdate = T : w.next = T, _.lastBaseUpdate = C)) } if (c !== null) { var V = l.baseState; m = 0, _ = T = C = null, w = c; do { var D = w.lane, H = w.eventTime; if ((o & D) === D) { _ !== null && (_ = _.next = { eventTime: H, lane: 0, tag: w.tag, payload: w.payload, callback: w.callback, next: null }); e: { var K = e, G = w; switch (D = t, H = i, G.tag) { case 1: if (K = G.payload, typeof K == "function") { V = K.call(H, V, D); break e } V = K; break e; case 3: K.flags = K.flags & -65537 | 128; case 0: if (K = G.payload, D = typeof K == "function" ? K.call(H, V, D) : K, D == null) break e; V = U({}, V, D); break e; case 2: ln = !0 } } w.callback !== null && w.lane !== 0 && (e.flags |= 64, D = l.effects, D === null ? l.effects = [w] : D.push(w)) } else H = { eventTime: H, lane: D, tag: w.tag, payload: w.payload, callback: w.callback, next: null }, _ === null ? (T = _ = H, C = V) : _ = _.next = H, m |= D; if (w = w.next, w === null) { if (w = l.shared.pending, w === null) break; D = w, w = D.next, D.next = null, l.lastBaseUpdate = D, l.shared.pending = null } } while (!0); if (_ === null && (C = V), l.baseState = C, l.firstBaseUpdate = T, l.lastBaseUpdate = _, t = l.shared.interleaved, t !== null) { l = t; do m |= l.lane, l = l.next; while (l !== t) } else c === null && (l.shared.lanes = 0); Rn |= m, e.lanes = m, e.memoizedState = V } } function dd(e, t, i) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var o = e[t], l = o.callback; if (l !== null) { if (o.callback = null, o = i, typeof l != "function") throw Error(s(191, l)); l.call(o) } } } var Jr = {}, Vt = sn(Jr), ei = sn(Jr), ti = sn(Jr); function Nn(e) { if (e === Jr) throw Error(s(174)); return e } function ma(e, t) { switch (ye(ti, t), ye(ei, e), ye(Vt, Jr), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : go(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = go(t, e) }we(Vt), ye(Vt, t) } function ar() { we(Vt), we(ei), we(ti) } function fd(e) { Nn(ti.current); var t = Nn(Vt.current), i = go(t, e.type); t !== i && (ye(ei, e), ye(Vt, i)) } function ga(e) { ei.current === e && (we(Vt), we(ei)) } var Pe = sn(0); function ys(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var i = t.memoizedState; if (i !== null && (i = i.dehydrated, i === null || i.data === "$?" || i.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if ((t.flags & 128) !== 0) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var ya = []; function va() { for (var e = 0; e < ya.length; e++)ya[e]._workInProgressVersionPrimary = null; ya.length = 0 } var vs = Y.ReactCurrentDispatcher, xa = Y.ReactCurrentBatchConfig, Mn = 0, Ee = null, Le = null, Ie = null, xs = !1, ni = !1, ri = 0, Cy = 0; function $e() { throw Error(s(321)) } function wa(e, t) { if (t === null) return !1; for (var i = 0; i < t.length && i < e.length; i++)if (!Tt(e[i], t[i])) return !1; return !0 } function Sa(e, t, i, o, l, c) { if (Mn = c, Ee = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, vs.current = e === null || e.memoizedState === null ? jy : Ty, e = i(o, l), ni) { c = 0; do { if (ni = !1, ri = 0, 25 <= c) throw Error(s(301)); c += 1, Ie = Le = null, t.updateQueue = null, vs.current = Ny, e = i(o, l) } while (ni) } if (vs.current = Cs, t = Le !== null && Le.next !== null, Mn = 0, Ie = Le = Ee = null, xs = !1, t) throw Error(s(300)); return e } function Ca() { var e = ri !== 0; return ri = 0, e } function It() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ie === null ? Ee.memoizedState = Ie = e : Ie = Ie.next = e, Ie } function xt() { if (Le === null) { var e = Ee.alternate; e = e !== null ? e.memoizedState : null } else e = Le.next; var t = Ie === null ? Ee.memoizedState : Ie.next; if (t !== null) Ie = t, Le = e; else { if (e === null) throw Error(s(310)); Le = e, e = { memoizedState: Le.memoizedState, baseState: Le.baseState, baseQueue: Le.baseQueue, queue: Le.queue, next: null }, Ie === null ? Ee.memoizedState = Ie = e : Ie = Ie.next = e } return Ie } function ii(e, t) { return typeof t == "function" ? t(e) : t } function ka(e) { var t = xt(), i = t.queue; if (i === null) throw Error(s(311)); i.lastRenderedReducer = e; var o = Le, l = o.baseQueue, c = i.pending; if (c !== null) { if (l !== null) { var m = l.next; l.next = c.next, c.next = m } o.baseQueue = l = c, i.pending = null } if (l !== null) { c = l.next, o = o.baseState; var w = m = null, C = null, T = c; do { var _ = T.lane; if ((Mn & _) === _) C !== null && (C = C.next = { lane: 0, action: T.action, hasEagerState: T.hasEagerState, eagerState: T.eagerState, next: null }), o = T.hasEagerState ? T.eagerState : e(o, T.action); else { var V = { lane: _, action: T.action, hasEagerState: T.hasEagerState, eagerState: T.eagerState, next: null }; C === null ? (w = C = V, m = o) : C = C.next = V, Ee.lanes |= _, Rn |= _ } T = T.next } while (T !== null && T !== c); C === null ? m = o : C.next = w, Tt(o, t.memoizedState) || (it = !0), t.memoizedState = o, t.baseState = m, t.baseQueue = C, i.lastRenderedState = o } if (e = i.interleaved, e !== null) { l = e; do c = l.lane, Ee.lanes |= c, Rn |= c, l = l.next; while (l !== e) } else l === null && (i.lanes = 0); return [t.memoizedState, i.dispatch] } function Pa(e) { var t = xt(), i = t.queue; if (i === null) throw Error(s(311)); i.lastRenderedReducer = e; var o = i.dispatch, l = i.pending, c = t.memoizedState; if (l !== null) { i.pending = null; var m = l = l.next; do c = e(c, m.action), m = m.next; while (m !== l); Tt(c, t.memoizedState) || (it = !0), t.memoizedState = c, t.baseQueue === null && (t.baseState = c), i.lastRenderedState = c } return [c, o] } function hd() { } function pd(e, t) { var i = Ee, o = xt(), l = t(), c = !Tt(o.memoizedState, l); if (c && (o.memoizedState = l, it = !0), o = o.queue, Ea(yd.bind(null, i, o, e), [e]), o.getSnapshot !== t || c || Ie !== null && Ie.memoizedState.tag & 1) { if (i.flags |= 2048, si(9, gd.bind(null, i, o, l, t), void 0, null), Oe === null) throw Error(s(349)); (Mn & 30) !== 0 || md(i, t, l) } return l } function md(e, t, i) { e.flags |= 16384, e = { getSnapshot: t, value: i }, t = Ee.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Ee.updateQueue = t, t.stores = [e]) : (i = t.stores, i === null ? t.stores = [e] : i.push(e)) } function gd(e, t, i, o) { t.value = i, t.getSnapshot = o, vd(t) && xd(e) } function yd(e, t, i) { return i(function () { vd(t) && xd(e) }) } function vd(e) { var t = e.getSnapshot; e = e.value; try { var i = t(); return !Tt(e, i) } catch { return !0 } } function xd(e) { var t = $t(e, 1); t !== null && bt(t, e, 1, -1) } function wd(e) { var t = It(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ii, lastRenderedState: e }, t.queue = e, e = e.dispatch = Ey.bind(null, Ee, e), [t.memoizedState, e] } function si(e, t, i, o) { return e = { tag: e, create: t, destroy: i, deps: o, next: null }, t = Ee.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Ee.updateQueue = t, t.lastEffect = e.next = e) : (i = t.lastEffect, i === null ? t.lastEffect = e.next = e : (o = i.next, i.next = e, e.next = o, t.lastEffect = e)), e } function Sd() { return xt().memoizedState } function ws(e, t, i, o) { var l = It(); Ee.flags |= e, l.memoizedState = si(1 | t, i, void 0, o === void 0 ? null : o) } function Ss(e, t, i, o) { var l = xt(); o = o === void 0 ? null : o; var c = void 0; if (Le !== null) { var m = Le.memoizedState; if (c = m.destroy, o !== null && wa(o, m.deps)) { l.memoizedState = si(t, i, c, o); return } } Ee.flags |= e, l.memoizedState = si(1 | t, i, c, o) } function Cd(e, t) { return ws(8390656, 8, e, t) } function Ea(e, t) { return Ss(2048, 8, e, t) } function kd(e, t) { return Ss(4, 2, e, t) } function Pd(e, t) { return Ss(4, 4, e, t) } function Ed(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function jd(e, t, i) { return i = i != null ? i.concat([e]) : null, Ss(4, 4, Ed.bind(null, t, e), i) } function ja() { } function Td(e, t) { var i = xt(); t = t === void 0 ? null : t; var o = i.memoizedState; return o !== null && t !== null && wa(t, o[1]) ? o[0] : (i.memoizedState = [e, t], e) } function Nd(e, t) { var i = xt(); t = t === void 0 ? null : t; var o = i.memoizedState; return o !== null && t !== null && wa(t, o[1]) ? o[0] : (e = e(), i.memoizedState = [e, t], e) } function Md(e, t, i) { return (Mn & 21) === 0 ? (e.baseState && (e.baseState = !1, it = !0), e.memoizedState = i) : (Tt(i, t) || (i = sc(), Ee.lanes |= i, Rn |= i, e.baseState = !0), t) } function ky(e, t) { var i = he; he = i !== 0 && 4 > i ? i : 4, e(!0); var o = xa.transition; xa.transition = {}; try { e(!1), t() } finally { he = i, xa.transition = o } } function Rd() { return xt().memoizedState } function Py(e, t, i) { var o = hn(e); if (i = { lane: o, action: i, hasEagerState: !1, eagerState: null, next: null }, Ad(e)) bd(t, i); else if (i = ld(e, t, i, o), i !== null) { var l = Je(); bt(i, e, o, l), Dd(i, t, o) } } function Ey(e, t, i) { var o = hn(e), l = { lane: o, action: i, hasEagerState: !1, eagerState: null, next: null }; if (Ad(e)) bd(t, l); else { var c = e.alternate; if (e.lanes === 0 && (c === null || c.lanes === 0) && (c = t.lastRenderedReducer, c !== null)) try { var m = t.lastRenderedState, w = c(m, i); if (l.hasEagerState = !0, l.eagerState = w, Tt(w, m)) { var C = t.interleaved; C === null ? (l.next = l, ha(t)) : (l.next = C.next, C.next = l), t.interleaved = l; return } } catch { } finally { } i = ld(e, t, l, o), i !== null && (l = Je(), bt(i, e, o, l), Dd(i, t, o)) } } function Ad(e) { var t = e.alternate; return e === Ee || t !== null && t === Ee } function bd(e, t) { ni = xs = !0; var i = e.pending; i === null ? t.next = t : (t.next = i.next, i.next = t), e.pending = t } function Dd(e, t, i) { if ((i & 4194240) !== 0) { var o = t.lanes; o &= e.pendingLanes, i |= o, t.lanes = i, No(e, i) } } var Cs = { readContext: vt, useCallback: $e, useContext: $e, useEffect: $e, useImperativeHandle: $e, useInsertionEffect: $e, useLayoutEffect: $e, useMemo: $e, useReducer: $e, useRef: $e, useState: $e, useDebugValue: $e, useDeferredValue: $e, useTransition: $e, useMutableSource: $e, useSyncExternalStore: $e, useId: $e, unstable_isNewReconciler: !1 }, jy = { readContext: vt, useCallback: function (e, t) { return It().memoizedState = [e, t === void 0 ? null : t], e }, useContext: vt, useEffect: Cd, useImperativeHandle: function (e, t, i) { return i = i != null ? i.concat([e]) : null, ws(4194308, 4, Ed.bind(null, t, e), i) }, useLayoutEffect: function (e, t) { return ws(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return ws(4, 2, e, t) }, useMemo: function (e, t) { var i = It(); return t = t === void 0 ? null : t, e = e(), i.memoizedState = [e, t], e }, useReducer: function (e, t, i) { var o = It(); return t = i !== void 0 ? i(t) : t, o.memoizedState = o.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, o.queue = e, e = e.dispatch = Py.bind(null, Ee, e), [o.memoizedState, e] }, useRef: function (e) { var t = It(); return e = { current: e }, t.memoizedState = e }, useState: wd, useDebugValue: ja, useDeferredValue: function (e) { return It().memoizedState = e }, useTransition: function () { var e = wd(!1), t = e[0]; return e = ky.bind(null, e[1]), It().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, i) { var o = Ee, l = It(); if (Ce) { if (i === void 0) throw Error(s(407)); i = i() } else { if (i = t(), Oe === null) throw Error(s(349)); (Mn & 30) !== 0 || md(o, t, i) } l.memoizedState = i; var c = { value: i, getSnapshot: t }; return l.queue = c, Cd(yd.bind(null, o, c, e), [e]), o.flags |= 2048, si(9, gd.bind(null, o, c, i, t), void 0, null), i }, useId: function () { var e = It(), t = Oe.identifierPrefix; if (Ce) { var i = Wt, o = Ht; i = (o & ~(1 << 32 - jt(o) - 1)).toString(32) + i, t = ":" + t + "R" + i, i = ri++, 0 < i && (t += "H" + i.toString(32)), t += ":" } else i = Cy++, t = ":" + t + "r" + i.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, Ty = { readContext: vt, useCallback: Td, useContext: vt, useEffect: Ea, useImperativeHandle: jd, useInsertionEffect: kd, useLayoutEffect: Pd, useMemo: Nd, useReducer: ka, useRef: Sd, useState: function () { return ka(ii) }, useDebugValue: ja, useDeferredValue: function (e) { var t = xt(); return Md(t, Le.memoizedState, e) }, useTransition: function () { var e = ka(ii)[0], t = xt().memoizedState; return [e, t] }, useMutableSource: hd, useSyncExternalStore: pd, useId: Rd, unstable_isNewReconciler: !1 }, Ny = { readContext: vt, useCallback: Td, useContext: vt, useEffect: Ea, useImperativeHandle: jd, useInsertionEffect: kd, useLayoutEffect: Pd, useMemo: Nd, useReducer: Pa, useRef: Sd, useState: function () { return Pa(ii) }, useDebugValue: ja, useDeferredValue: function (e) { var t = xt(); return Le === null ? t.memoizedState = e : Md(t, Le.memoizedState, e) }, useTransition: function () { var e = Pa(ii)[0], t = xt().memoizedState; return [e, t] }, useMutableSource: hd, useSyncExternalStore: pd, useId: Rd, unstable_isNewReconciler: !1 }; function Mt(e, t) { if (e && e.defaultProps) { t = U({}, t), e = e.defaultProps; for (var i in e) t[i] === void 0 && (t[i] = e[i]); return t } return t } function Ta(e, t, i, o) { t = e.memoizedState, i = i(o, t), i = i == null ? t : U({}, t, i), e.memoizedState = i, e.lanes === 0 && (e.updateQueue.baseState = i) } var ks = { isMounted: function (e) { return (e = e._reactInternals) ? Cn(e) === e : !1 }, enqueueSetState: function (e, t, i) { e = e._reactInternals; var o = Je(), l = hn(e), c = Kt(o, l); c.payload = t, i != null && (c.callback = i), t = un(e, c, l), t !== null && (bt(t, e, l, o), ms(t, e, l)) }, enqueueReplaceState: function (e, t, i) { e = e._reactInternals; var o = Je(), l = hn(e), c = Kt(o, l); c.tag = 1, c.payload = t, i != null && (c.callback = i), t = un(e, c, l), t !== null && (bt(t, e, l, o), ms(t, e, l)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var i = Je(), o = hn(e), l = Kt(i, o); l.tag = 2, t != null && (l.callback = t), t = un(e, l, o), t !== null && (bt(t, e, o, i), ms(t, e, o)) } }; function Ld(e, t, i, o, l, c, m) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(o, c, m) : t.prototype && t.prototype.isPureReactComponent ? !$r(i, o) || !$r(l, c) : !0 } function _d(e, t, i) { var o = !1, l = on, c = t.contextType; return typeof c == "object" && c !== null ? c = vt(c) : (l = rt(t) ? Pn : We.current, o = t.contextTypes, c = (o = o != null) ? er(e, l) : on), t = new t(i, c), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = ks, e.stateNode = t, t._reactInternals = e, o && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = l, e.__reactInternalMemoizedMaskedChildContext = c), t } function Vd(e, t, i, o) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(i, o), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(i, o), t.state !== e && ks.enqueueReplaceState(t, t.state, null) } function Na(e, t, i, o) { var l = e.stateNode; l.props = i, l.state = e.memoizedState, l.refs = {}, pa(e); var c = t.contextType; typeof c == "object" && c !== null ? l.context = vt(c) : (c = rt(t) ? Pn : We.current, l.context = er(e, c)), l.state = e.memoizedState, c = t.getDerivedStateFromProps, typeof c == "function" && (Ta(e, t, c, i), l.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof l.getSnapshotBeforeUpdate == "function" || typeof l.UNSAFE_componentWillMount != "function" && typeof l.componentWillMount != "function" || (t = l.state, typeof l.componentWillMount == "function" && l.componentWillMount(), typeof l.UNSAFE_componentWillMount == "function" && l.UNSAFE_componentWillMount(), t !== l.state && ks.enqueueReplaceState(l, l.state, null), gs(e, i, l, o), l.state = e.memoizedState), typeof l.componentDidMount == "function" && (e.flags |= 4194308) } function lr(e, t) {
    try { var i = "", o = t; do i += ue(o), o = o.return; while (o); var l = i } catch (c) {
      l = `
Error generating stack: `+ c.message + `
`+ c.stack
    } return { value: e, source: t, stack: l, digest: null }
  } function Ma(e, t, i) { return { value: e, source: null, stack: i ?? null, digest: t ?? null } } function Ra(e, t) { try { console.error(t.value) } catch (i) { setTimeout(function () { throw i }) } } var My = typeof WeakMap == "function" ? WeakMap : Map; function Id(e, t, i) { i = Kt(-1, i), i.tag = 3, i.payload = { element: null }; var o = t.value; return i.callback = function () { Rs || (Rs = !0, $a = o), Ra(e, t) }, i } function Od(e, t, i) { i = Kt(-1, i), i.tag = 3; var o = e.type.getDerivedStateFromError; if (typeof o == "function") { var l = t.value; i.payload = function () { return o(l) }, i.callback = function () { Ra(e, t) } } var c = e.stateNode; return c !== null && typeof c.componentDidCatch == "function" && (i.callback = function () { Ra(e, t), typeof o != "function" && (dn === null ? dn = new Set([this]) : dn.add(this)); var m = t.stack; this.componentDidCatch(t.value, { componentStack: m !== null ? m : "" }) }), i } function zd(e, t, i) { var o = e.pingCache; if (o === null) { o = e.pingCache = new My; var l = new Set; o.set(t, l) } else l = o.get(t), l === void 0 && (l = new Set, o.set(t, l)); l.has(i) || (l.add(i), e = Hy.bind(null, e, t, i), t.then(e, e)) } function Fd(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function Bd(e, t, i, o, l) { return (e.mode & 1) === 0 ? (e === t ? e.flags |= 65536 : (e.flags |= 128, i.flags |= 131072, i.flags &= -52805, i.tag === 1 && (i.alternate === null ? i.tag = 17 : (t = Kt(-1, 1), t.tag = 2, un(i, t, 1))), i.lanes |= 1), e) : (e.flags |= 65536, e.lanes = l, e) } var Ry = Y.ReactCurrentOwner, it = !1; function Ze(e, t, i, o) { t.child = e === null ? ad(t, null, i, o) : ir(t, e.child, i, o) } function Ud(e, t, i, o, l) { i = i.render; var c = t.ref; return or(t, l), o = Sa(e, t, i, o, c, l), i = Ca(), e !== null && !it ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~l, Gt(e, t, l)) : (Ce && i && ia(t), t.flags |= 1, Ze(e, t, o, l), t.child) } function Hd(e, t, i, o, l) { if (e === null) { var c = i.type; return typeof c == "function" && !Za(c) && c.defaultProps === void 0 && i.compare === null && i.defaultProps === void 0 ? (t.tag = 15, t.type = c, Wd(e, t, c, o, l)) : (e = Vs(i.type, null, o, t, t.mode, l), e.ref = t.ref, e.return = t, t.child = e) } if (c = e.child, (e.lanes & l) === 0) { var m = c.memoizedProps; if (i = i.compare, i = i !== null ? i : $r, i(m, o) && e.ref === t.ref) return Gt(e, t, l) } return t.flags |= 1, e = mn(c, o), e.ref = t.ref, e.return = t, t.child = e } function Wd(e, t, i, o, l) { if (e !== null) { var c = e.memoizedProps; if ($r(c, o) && e.ref === t.ref) if (it = !1, t.pendingProps = o = c, (e.lanes & l) !== 0) (e.flags & 131072) !== 0 && (it = !0); else return t.lanes = e.lanes, Gt(e, t, l) } return Aa(e, t, i, o, l) } function $d(e, t, i) { var o = t.pendingProps, l = o.children, c = e !== null ? e.memoizedState : null; if (o.mode === "hidden") if ((t.mode & 1) === 0) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ye(cr, mt), mt |= i; else { if ((i & 1073741824) === 0) return e = c !== null ? c.baseLanes | i : i, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, ye(cr, mt), mt |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, o = c !== null ? c.baseLanes : i, ye(cr, mt), mt |= o } else c !== null ? (o = c.baseLanes | i, t.memoizedState = null) : o = i, ye(cr, mt), mt |= o; return Ze(e, t, l, i), t.child } function Kd(e, t) { var i = t.ref; (e === null && i !== null || e !== null && e.ref !== i) && (t.flags |= 512, t.flags |= 2097152) } function Aa(e, t, i, o, l) { var c = rt(i) ? Pn : We.current; return c = er(t, c), or(t, l), i = Sa(e, t, i, o, c, l), o = Ca(), e !== null && !it ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~l, Gt(e, t, l)) : (Ce && o && ia(t), t.flags |= 1, Ze(e, t, i, l), t.child) } function Gd(e, t, i, o, l) { if (rt(i)) { var c = !0; as(t) } else c = !1; if (or(t, l), t.stateNode === null) Es(e, t), _d(t, i, o), Na(t, i, o, l), o = !0; else if (e === null) { var m = t.stateNode, w = t.memoizedProps; m.props = w; var C = m.context, T = i.contextType; typeof T == "object" && T !== null ? T = vt(T) : (T = rt(i) ? Pn : We.current, T = er(t, T)); var _ = i.getDerivedStateFromProps, V = typeof _ == "function" || typeof m.getSnapshotBeforeUpdate == "function"; V || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (w !== o || C !== T) && Vd(t, m, o, T), ln = !1; var D = t.memoizedState; m.state = D, gs(t, o, m, l), C = t.memoizedState, w !== o || D !== C || nt.current || ln ? (typeof _ == "function" && (Ta(t, i, _, o), C = t.memoizedState), (w = ln || Ld(t, i, w, o, D, C, T)) ? (V || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount()), typeof m.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof m.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = o, t.memoizedState = C), m.props = o, m.state = C, m.context = T, o = w) : (typeof m.componentDidMount == "function" && (t.flags |= 4194308), o = !1) } else { m = t.stateNode, ud(e, t), w = t.memoizedProps, T = t.type === t.elementType ? w : Mt(t.type, w), m.props = T, V = t.pendingProps, D = m.context, C = i.contextType, typeof C == "object" && C !== null ? C = vt(C) : (C = rt(i) ? Pn : We.current, C = er(t, C)); var H = i.getDerivedStateFromProps; (_ = typeof H == "function" || typeof m.getSnapshotBeforeUpdate == "function") || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (w !== V || D !== C) && Vd(t, m, o, C), ln = !1, D = t.memoizedState, m.state = D, gs(t, o, m, l); var K = t.memoizedState; w !== V || D !== K || nt.current || ln ? (typeof H == "function" && (Ta(t, i, H, o), K = t.memoizedState), (T = ln || Ld(t, i, T, o, D, K, C) || !1) ? (_ || typeof m.UNSAFE_componentWillUpdate != "function" && typeof m.componentWillUpdate != "function" || (typeof m.componentWillUpdate == "function" && m.componentWillUpdate(o, K, C), typeof m.UNSAFE_componentWillUpdate == "function" && m.UNSAFE_componentWillUpdate(o, K, C)), typeof m.componentDidUpdate == "function" && (t.flags |= 4), typeof m.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof m.componentDidUpdate != "function" || w === e.memoizedProps && D === e.memoizedState || (t.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || w === e.memoizedProps && D === e.memoizedState || (t.flags |= 1024), t.memoizedProps = o, t.memoizedState = K), m.props = o, m.state = K, m.context = C, o = T) : (typeof m.componentDidUpdate != "function" || w === e.memoizedProps && D === e.memoizedState || (t.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || w === e.memoizedProps && D === e.memoizedState || (t.flags |= 1024), o = !1) } return ba(e, t, i, o, c, l) } function ba(e, t, i, o, l, c) { Kd(e, t); var m = (t.flags & 128) !== 0; if (!o && !m) return l && Zc(t, i, !1), Gt(e, t, c); o = t.stateNode, Ry.current = t; var w = m && typeof i.getDerivedStateFromError != "function" ? null : o.render(); return t.flags |= 1, e !== null && m ? (t.child = ir(t, e.child, null, c), t.child = ir(t, null, w, c)) : Ze(e, t, w, c), t.memoizedState = o.state, l && Zc(t, i, !0), t.child } function qd(e) { var t = e.stateNode; t.pendingContext ? Xc(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Xc(e, t.context, !1), ma(e, t.containerInfo) } function Yd(e, t, i, o, l) { return rr(), la(l), t.flags |= 256, Ze(e, t, i, o), t.child } var Da = { dehydrated: null, treeContext: null, retryLane: 0 }; function La(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Xd(e, t, i) { var o = t.pendingProps, l = Pe.current, c = !1, m = (t.flags & 128) !== 0, w; if ((w = m) || (w = e !== null && e.memoizedState === null ? !1 : (l & 2) !== 0), w ? (c = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (l |= 1), ye(Pe, l & 1), e === null) return aa(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? ((t.mode & 1) === 0 ? t.lanes = 1 : e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824, null) : (m = o.children, e = o.fallback, c ? (o = t.mode, c = t.child, m = { mode: "hidden", children: m }, (o & 1) === 0 && c !== null ? (c.childLanes = 0, c.pendingProps = m) : c = Is(m, o, 0, null), e = Ln(e, o, i, null), c.return = t, e.return = t, c.sibling = e, t.child = c, t.child.memoizedState = La(i), t.memoizedState = Da, e) : _a(t, m)); if (l = e.memoizedState, l !== null && (w = l.dehydrated, w !== null)) return Ay(e, t, m, o, w, l, i); if (c) { c = o.fallback, m = t.mode, l = e.child, w = l.sibling; var C = { mode: "hidden", children: o.children }; return (m & 1) === 0 && t.child !== l ? (o = t.child, o.childLanes = 0, o.pendingProps = C, t.deletions = null) : (o = mn(l, C), o.subtreeFlags = l.subtreeFlags & 14680064), w !== null ? c = mn(w, c) : (c = Ln(c, m, i, null), c.flags |= 2), c.return = t, o.return = t, o.sibling = c, t.child = o, o = c, c = t.child, m = e.child.memoizedState, m = m === null ? La(i) : { baseLanes: m.baseLanes | i, cachePool: null, transitions: m.transitions }, c.memoizedState = m, c.childLanes = e.childLanes & ~i, t.memoizedState = Da, o } return c = e.child, e = c.sibling, o = mn(c, { mode: "visible", children: o.children }), (t.mode & 1) === 0 && (o.lanes = i), o.return = t, o.sibling = null, e !== null && (i = t.deletions, i === null ? (t.deletions = [e], t.flags |= 16) : i.push(e)), t.child = o, t.memoizedState = null, o } function _a(e, t) { return t = Is({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function Ps(e, t, i, o) { return o !== null && la(o), ir(t, e.child, null, i), e = _a(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function Ay(e, t, i, o, l, c, m) { if (i) return t.flags & 256 ? (t.flags &= -257, o = Ma(Error(s(422))), Ps(e, t, m, o)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (c = o.fallback, l = t.mode, o = Is({ mode: "visible", children: o.children }, l, 0, null), c = Ln(c, l, m, null), c.flags |= 2, o.return = t, c.return = t, o.sibling = c, t.child = o, (t.mode & 1) !== 0 && ir(t, e.child, null, m), t.child.memoizedState = La(m), t.memoizedState = Da, c); if ((t.mode & 1) === 0) return Ps(e, t, m, null); if (l.data === "$!") { if (o = l.nextSibling && l.nextSibling.dataset, o) var w = o.dgst; return o = w, c = Error(s(419)), o = Ma(c, o, void 0), Ps(e, t, m, o) } if (w = (m & e.childLanes) !== 0, it || w) { if (o = Oe, o !== null) { switch (m & -m) { case 4: l = 2; break; case 16: l = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: l = 32; break; case 536870912: l = 268435456; break; default: l = 0 }l = (l & (o.suspendedLanes | m)) !== 0 ? 0 : l, l !== 0 && l !== c.retryLane && (c.retryLane = l, $t(e, l), bt(o, e, l, -1)) } return Qa(), o = Ma(Error(s(421))), Ps(e, t, m, o) } return l.data === "$?" ? (t.flags |= 128, t.child = e.child, t = Wy.bind(null, e), l._reactRetry = t, null) : (e = c.treeContext, pt = rn(l.nextSibling), ht = t, Ce = !0, Nt = null, e !== null && (gt[yt++] = Ht, gt[yt++] = Wt, gt[yt++] = En, Ht = e.id, Wt = e.overflow, En = t), t = _a(t, o.children), t.flags |= 4096, t) } function Qd(e, t, i) { e.lanes |= t; var o = e.alternate; o !== null && (o.lanes |= t), fa(e.return, t, i) } function Va(e, t, i, o, l) { var c = e.memoizedState; c === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: o, tail: i, tailMode: l } : (c.isBackwards = t, c.rendering = null, c.renderingStartTime = 0, c.last = o, c.tail = i, c.tailMode = l) } function Zd(e, t, i) { var o = t.pendingProps, l = o.revealOrder, c = o.tail; if (Ze(e, t, o.children, i), o = Pe.current, (o & 2) !== 0) o = o & 1 | 2, t.flags |= 128; else { if (e !== null && (e.flags & 128) !== 0) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && Qd(e, i, t); else if (e.tag === 19) Qd(e, i, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } o &= 1 } if (ye(Pe, o), (t.mode & 1) === 0) t.memoizedState = null; else switch (l) { case "forwards": for (i = t.child, l = null; i !== null;)e = i.alternate, e !== null && ys(e) === null && (l = i), i = i.sibling; i = l, i === null ? (l = t.child, t.child = null) : (l = i.sibling, i.sibling = null), Va(t, !1, l, i, c); break; case "backwards": for (i = null, l = t.child, t.child = null; l !== null;) { if (e = l.alternate, e !== null && ys(e) === null) { t.child = l; break } e = l.sibling, l.sibling = i, i = l, l = e } Va(t, !0, i, null, c); break; case "together": Va(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Es(e, t) { (t.mode & 1) === 0 && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Gt(e, t, i) { if (e !== null && (t.dependencies = e.dependencies), Rn |= t.lanes, (i & t.childLanes) === 0) return null; if (e !== null && t.child !== e.child) throw Error(s(153)); if (t.child !== null) { for (e = t.child, i = mn(e, e.pendingProps), t.child = i, i.return = t; e.sibling !== null;)e = e.sibling, i = i.sibling = mn(e, e.pendingProps), i.return = t; i.sibling = null } return t.child } function by(e, t, i) { switch (t.tag) { case 3: qd(t), rr(); break; case 5: fd(t); break; case 1: rt(t.type) && as(t); break; case 4: ma(t, t.stateNode.containerInfo); break; case 10: var o = t.type._context, l = t.memoizedProps.value; ye(hs, o._currentValue), o._currentValue = l; break; case 13: if (o = t.memoizedState, o !== null) return o.dehydrated !== null ? (ye(Pe, Pe.current & 1), t.flags |= 128, null) : (i & t.child.childLanes) !== 0 ? Xd(e, t, i) : (ye(Pe, Pe.current & 1), e = Gt(e, t, i), e !== null ? e.sibling : null); ye(Pe, Pe.current & 1); break; case 19: if (o = (i & t.childLanes) !== 0, (e.flags & 128) !== 0) { if (o) return Zd(e, t, i); t.flags |= 128 } if (l = t.memoizedState, l !== null && (l.rendering = null, l.tail = null, l.lastEffect = null), ye(Pe, Pe.current), o) break; return null; case 22: case 23: return t.lanes = 0, $d(e, t, i) }return Gt(e, t, i) } var Jd, Ia, ef, tf; Jd = function (e, t) { for (var i = t.child; i !== null;) { if (i.tag === 5 || i.tag === 6) e.appendChild(i.stateNode); else if (i.tag !== 4 && i.child !== null) { i.child.return = i, i = i.child; continue } if (i === t) break; for (; i.sibling === null;) { if (i.return === null || i.return === t) return; i = i.return } i.sibling.return = i.return, i = i.sibling } }, Ia = function () { }, ef = function (e, t, i, o) { var l = e.memoizedProps; if (l !== o) { e = t.stateNode, Nn(Vt.current); var c = null; switch (i) { case "input": l = fo(e, l), o = fo(e, o), c = []; break; case "select": l = U({}, l, { value: void 0 }), o = U({}, o, { value: void 0 }), c = []; break; case "textarea": l = mo(e, l), o = mo(e, o), c = []; break; default: typeof l.onClick != "function" && typeof o.onClick == "function" && (e.onclick = is) }yo(i, o); var m; i = null; for (T in l) if (!o.hasOwnProperty(T) && l.hasOwnProperty(T) && l[T] != null) if (T === "style") { var w = l[T]; for (m in w) w.hasOwnProperty(m) && (i || (i = {}), i[m] = "") } else T !== "dangerouslySetInnerHTML" && T !== "children" && T !== "suppressContentEditableWarning" && T !== "suppressHydrationWarning" && T !== "autoFocus" && (u.hasOwnProperty(T) ? c || (c = []) : (c = c || []).push(T, null)); for (T in o) { var C = o[T]; if (w = l?.[T], o.hasOwnProperty(T) && C !== w && (C != null || w != null)) if (T === "style") if (w) { for (m in w) !w.hasOwnProperty(m) || C && C.hasOwnProperty(m) || (i || (i = {}), i[m] = ""); for (m in C) C.hasOwnProperty(m) && w[m] !== C[m] && (i || (i = {}), i[m] = C[m]) } else i || (c || (c = []), c.push(T, i)), i = C; else T === "dangerouslySetInnerHTML" ? (C = C ? C.__html : void 0, w = w ? w.__html : void 0, C != null && w !== C && (c = c || []).push(T, C)) : T === "children" ? typeof C != "string" && typeof C != "number" || (c = c || []).push(T, "" + C) : T !== "suppressContentEditableWarning" && T !== "suppressHydrationWarning" && (u.hasOwnProperty(T) ? (C != null && T === "onScroll" && xe("scroll", e), c || w === C || (c = [])) : (c = c || []).push(T, C)) } i && (c = c || []).push("style", i); var T = c; (t.updateQueue = T) && (t.flags |= 4) } }, tf = function (e, t, i, o) { i !== o && (t.flags |= 4) }; function oi(e, t) { if (!Ce) switch (e.tailMode) { case "hidden": t = e.tail; for (var i = null; t !== null;)t.alternate !== null && (i = t), t = t.sibling; i === null ? e.tail = null : i.sibling = null; break; case "collapsed": i = e.tail; for (var o = null; i !== null;)i.alternate !== null && (o = i), i = i.sibling; o === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : o.sibling = null } } function Ke(e) { var t = e.alternate !== null && e.alternate.child === e.child, i = 0, o = 0; if (t) for (var l = e.child; l !== null;)i |= l.lanes | l.childLanes, o |= l.subtreeFlags & 14680064, o |= l.flags & 14680064, l.return = e, l = l.sibling; else for (l = e.child; l !== null;)i |= l.lanes | l.childLanes, o |= l.subtreeFlags, o |= l.flags, l.return = e, l = l.sibling; return e.subtreeFlags |= o, e.childLanes = i, t } function Dy(e, t, i) { var o = t.pendingProps; switch (sa(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ke(t), null; case 1: return rt(t.type) && os(), Ke(t), null; case 3: return o = t.stateNode, ar(), we(nt), we(We), va(), o.pendingContext && (o.context = o.pendingContext, o.pendingContext = null), (e === null || e.child === null) && (ds(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && (t.flags & 256) === 0 || (t.flags |= 1024, Nt !== null && (qa(Nt), Nt = null))), Ia(e, t), Ke(t), null; case 5: ga(t); var l = Nn(ti.current); if (i = t.type, e !== null && t.stateNode != null) ef(e, t, i, o, l), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!o) { if (t.stateNode === null) throw Error(s(166)); return Ke(t), null } if (e = Nn(Vt.current), ds(t)) { o = t.stateNode, i = t.type; var c = t.memoizedProps; switch (o[_t] = t, o[Xr] = c, e = (t.mode & 1) !== 0, i) { case "dialog": xe("cancel", o), xe("close", o); break; case "iframe": case "object": case "embed": xe("load", o); break; case "video": case "audio": for (l = 0; l < Gr.length; l++)xe(Gr[l], o); break; case "source": xe("error", o); break; case "img": case "image": case "link": xe("error", o), xe("load", o); break; case "details": xe("toggle", o); break; case "input": _u(o, c), xe("invalid", o); break; case "select": o._wrapperState = { wasMultiple: !!c.multiple }, xe("invalid", o); break; case "textarea": Ou(o, c), xe("invalid", o) }yo(i, c), l = null; for (var m in c) if (c.hasOwnProperty(m)) { var w = c[m]; m === "children" ? typeof w == "string" ? o.textContent !== w && (c.suppressHydrationWarning !== !0 && rs(o.textContent, w, e), l = ["children", w]) : typeof w == "number" && o.textContent !== "" + w && (c.suppressHydrationWarning !== !0 && rs(o.textContent, w, e), l = ["children", "" + w]) : u.hasOwnProperty(m) && w != null && m === "onScroll" && xe("scroll", o) } switch (i) { case "input": Li(o), Iu(o, c, !0); break; case "textarea": Li(o), Fu(o); break; case "select": case "option": break; default: typeof c.onClick == "function" && (o.onclick = is) }o = l, t.updateQueue = o, o !== null && (t.flags |= 4) } else { m = l.nodeType === 9 ? l : l.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Bu(i)), e === "http://www.w3.org/1999/xhtml" ? i === "script" ? (e = m.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof o.is == "string" ? e = m.createElement(i, { is: o.is }) : (e = m.createElement(i), i === "select" && (m = e, o.multiple ? m.multiple = !0 : o.size && (m.size = o.size))) : e = m.createElementNS(e, i), e[_t] = t, e[Xr] = o, Jd(e, t, !1, !1), t.stateNode = e; e: { switch (m = vo(i, o), i) { case "dialog": xe("cancel", e), xe("close", e), l = o; break; case "iframe": case "object": case "embed": xe("load", e), l = o; break; case "video": case "audio": for (l = 0; l < Gr.length; l++)xe(Gr[l], e); l = o; break; case "source": xe("error", e), l = o; break; case "img": case "image": case "link": xe("error", e), xe("load", e), l = o; break; case "details": xe("toggle", e), l = o; break; case "input": _u(e, o), l = fo(e, o), xe("invalid", e); break; case "option": l = o; break; case "select": e._wrapperState = { wasMultiple: !!o.multiple }, l = U({}, o, { value: void 0 }), xe("invalid", e); break; case "textarea": Ou(e, o), l = mo(e, o), xe("invalid", e); break; default: l = o }yo(i, l), w = l; for (c in w) if (w.hasOwnProperty(c)) { var C = w[c]; c === "style" ? Wu(e, C) : c === "dangerouslySetInnerHTML" ? (C = C ? C.__html : void 0, C != null && Uu(e, C)) : c === "children" ? typeof C == "string" ? (i !== "textarea" || C !== "") && Nr(e, C) : typeof C == "number" && Nr(e, "" + C) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (u.hasOwnProperty(c) ? C != null && c === "onScroll" && xe("scroll", e) : C != null && z(e, c, C, m)) } switch (i) { case "input": Li(e), Iu(e, o, !1); break; case "textarea": Li(e), Fu(e); break; case "option": o.value != null && e.setAttribute("value", "" + fe(o.value)); break; case "select": e.multiple = !!o.multiple, c = o.value, c != null ? Un(e, !!o.multiple, c, !1) : o.defaultValue != null && Un(e, !!o.multiple, o.defaultValue, !0); break; default: typeof l.onClick == "function" && (e.onclick = is) }switch (i) { case "button": case "input": case "select": case "textarea": o = !!o.autoFocus; break e; case "img": o = !0; break e; default: o = !1 } } o && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return Ke(t), null; case 6: if (e && t.stateNode != null) tf(e, t, e.memoizedProps, o); else { if (typeof o != "string" && t.stateNode === null) throw Error(s(166)); if (i = Nn(ti.current), Nn(Vt.current), ds(t)) { if (o = t.stateNode, i = t.memoizedProps, o[_t] = t, (c = o.nodeValue !== i) && (e = ht, e !== null)) switch (e.tag) { case 3: rs(o.nodeValue, i, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && rs(o.nodeValue, i, (e.mode & 1) !== 0) }c && (t.flags |= 4) } else o = (i.nodeType === 9 ? i : i.ownerDocument).createTextNode(o), o[_t] = t, t.stateNode = o } return Ke(t), null; case 13: if (we(Pe), o = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (Ce && pt !== null && (t.mode & 1) !== 0 && (t.flags & 128) === 0) id(), rr(), t.flags |= 98560, c = !1; else if (c = ds(t), o !== null && o.dehydrated !== null) { if (e === null) { if (!c) throw Error(s(318)); if (c = t.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(s(317)); c[_t] = t } else rr(), (t.flags & 128) === 0 && (t.memoizedState = null), t.flags |= 4; Ke(t), c = !1 } else Nt !== null && (qa(Nt), Nt = null), c = !0; if (!c) return t.flags & 65536 ? t : null } return (t.flags & 128) !== 0 ? (t.lanes = i, t) : (o = o !== null, o !== (e !== null && e.memoizedState !== null) && o && (t.child.flags |= 8192, (t.mode & 1) !== 0 && (e === null || (Pe.current & 1) !== 0 ? _e === 0 && (_e = 3) : Qa())), t.updateQueue !== null && (t.flags |= 4), Ke(t), null); case 4: return ar(), Ia(e, t), e === null && qr(t.stateNode.containerInfo), Ke(t), null; case 10: return da(t.type._context), Ke(t), null; case 17: return rt(t.type) && os(), Ke(t), null; case 19: if (we(Pe), c = t.memoizedState, c === null) return Ke(t), null; if (o = (t.flags & 128) !== 0, m = c.rendering, m === null) if (o) oi(c, !1); else { if (_e !== 0 || e !== null && (e.flags & 128) !== 0) for (e = t.child; e !== null;) { if (m = ys(e), m !== null) { for (t.flags |= 128, oi(c, !1), o = m.updateQueue, o !== null && (t.updateQueue = o, t.flags |= 4), t.subtreeFlags = 0, o = i, i = t.child; i !== null;)c = i, e = o, c.flags &= 14680066, m = c.alternate, m === null ? (c.childLanes = 0, c.lanes = e, c.child = null, c.subtreeFlags = 0, c.memoizedProps = null, c.memoizedState = null, c.updateQueue = null, c.dependencies = null, c.stateNode = null) : (c.childLanes = m.childLanes, c.lanes = m.lanes, c.child = m.child, c.subtreeFlags = 0, c.deletions = null, c.memoizedProps = m.memoizedProps, c.memoizedState = m.memoizedState, c.updateQueue = m.updateQueue, c.type = m.type, e = m.dependencies, c.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), i = i.sibling; return ye(Pe, Pe.current & 1 | 2), t.child } e = e.sibling } c.tail !== null && Me() > dr && (t.flags |= 128, o = !0, oi(c, !1), t.lanes = 4194304) } else { if (!o) if (e = ys(m), e !== null) { if (t.flags |= 128, o = !0, i = e.updateQueue, i !== null && (t.updateQueue = i, t.flags |= 4), oi(c, !0), c.tail === null && c.tailMode === "hidden" && !m.alternate && !Ce) return Ke(t), null } else 2 * Me() - c.renderingStartTime > dr && i !== 1073741824 && (t.flags |= 128, o = !0, oi(c, !1), t.lanes = 4194304); c.isBackwards ? (m.sibling = t.child, t.child = m) : (i = c.last, i !== null ? i.sibling = m : t.child = m, c.last = m) } return c.tail !== null ? (t = c.tail, c.rendering = t, c.tail = t.sibling, c.renderingStartTime = Me(), t.sibling = null, i = Pe.current, ye(Pe, o ? i & 1 | 2 : i & 1), t) : (Ke(t), null); case 22: case 23: return Xa(), o = t.memoizedState !== null, e !== null && e.memoizedState !== null !== o && (t.flags |= 8192), o && (t.mode & 1) !== 0 ? (mt & 1073741824) !== 0 && (Ke(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Ke(t), null; case 24: return null; case 25: return null }throw Error(s(156, t.tag)) } function Ly(e, t) { switch (sa(t), t.tag) { case 1: return rt(t.type) && os(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return ar(), we(nt), we(We), va(), e = t.flags, (e & 65536) !== 0 && (e & 128) === 0 ? (t.flags = e & -65537 | 128, t) : null; case 5: return ga(t), null; case 13: if (we(Pe), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(s(340)); rr() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return we(Pe), null; case 4: return ar(), null; case 10: return da(t.type._context), null; case 22: case 23: return Xa(), null; case 24: return null; default: return null } } var js = !1, Ge = !1, _y = typeof WeakSet == "function" ? WeakSet : Set, W = null; function ur(e, t) { var i = e.ref; if (i !== null) if (typeof i == "function") try { i(null) } catch (o) { Te(e, t, o) } else i.current = null } function Oa(e, t, i) { try { i() } catch (o) { Te(e, t, o) } } var nf = !1; function Vy(e, t) { if (Xo = Ki, e = Lc(), Uo(e)) { if ("selectionStart" in e) var i = { start: e.selectionStart, end: e.selectionEnd }; else e: { i = (i = e.ownerDocument) && i.defaultView || window; var o = i.getSelection && i.getSelection(); if (o && o.rangeCount !== 0) { i = o.anchorNode; var l = o.anchorOffset, c = o.focusNode; o = o.focusOffset; try { i.nodeType, c.nodeType } catch { i = null; break e } var m = 0, w = -1, C = -1, T = 0, _ = 0, V = e, D = null; t: for (; ;) { for (var H; V !== i || l !== 0 && V.nodeType !== 3 || (w = m + l), V !== c || o !== 0 && V.nodeType !== 3 || (C = m + o), V.nodeType === 3 && (m += V.nodeValue.length), (H = V.firstChild) !== null;)D = V, V = H; for (; ;) { if (V === e) break t; if (D === i && ++T === l && (w = m), D === c && ++_ === o && (C = m), (H = V.nextSibling) !== null) break; V = D, D = V.parentNode } V = H } i = w === -1 || C === -1 ? null : { start: w, end: C } } else i = null } i = i || { start: 0, end: 0 } } else i = null; for (Qo = { focusedElem: e, selectionRange: i }, Ki = !1, W = t; W !== null;)if (t = W, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, W = e; else for (; W !== null;) { t = W; try { var K = t.alternate; if ((t.flags & 1024) !== 0) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (K !== null) { var G = K.memoizedProps, Re = K.memoizedState, E = t.stateNode, k = E.getSnapshotBeforeUpdate(t.elementType === t.type ? G : Mt(t.type, G), Re); E.__reactInternalSnapshotBeforeUpdate = k } break; case 3: var j = t.stateNode.containerInfo; j.nodeType === 1 ? j.textContent = "" : j.nodeType === 9 && j.documentElement && j.removeChild(j.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(s(163)) } } catch (O) { Te(t, t.return, O) } if (e = t.sibling, e !== null) { e.return = t.return, W = e; break } W = t.return } return K = nf, nf = !1, K } function ai(e, t, i) { var o = t.updateQueue; if (o = o !== null ? o.lastEffect : null, o !== null) { var l = o = o.next; do { if ((l.tag & e) === e) { var c = l.destroy; l.destroy = void 0, c !== void 0 && Oa(t, i, c) } l = l.next } while (l !== o) } } function Ts(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var i = t = t.next; do { if ((i.tag & e) === e) { var o = i.create; i.destroy = o() } i = i.next } while (i !== t) } } function za(e) { var t = e.ref; if (t !== null) { var i = e.stateNode; switch (e.tag) { case 5: e = i; break; default: e = i }typeof t == "function" ? t(e) : t.current = e } } function rf(e) { var t = e.alternate; t !== null && (e.alternate = null, rf(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[_t], delete t[Xr], delete t[ta], delete t[vy], delete t[xy])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function sf(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function of(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || sf(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function Fa(e, t, i) { var o = e.tag; if (o === 5 || o === 6) e = e.stateNode, t ? i.nodeType === 8 ? i.parentNode.insertBefore(e, t) : i.insertBefore(e, t) : (i.nodeType === 8 ? (t = i.parentNode, t.insertBefore(e, i)) : (t = i, t.appendChild(e)), i = i._reactRootContainer, i != null || t.onclick !== null || (t.onclick = is)); else if (o !== 4 && (e = e.child, e !== null)) for (Fa(e, t, i), e = e.sibling; e !== null;)Fa(e, t, i), e = e.sibling } function Ba(e, t, i) { var o = e.tag; if (o === 5 || o === 6) e = e.stateNode, t ? i.insertBefore(e, t) : i.appendChild(e); else if (o !== 4 && (e = e.child, e !== null)) for (Ba(e, t, i), e = e.sibling; e !== null;)Ba(e, t, i), e = e.sibling } var Fe = null, Rt = !1; function cn(e, t, i) { for (i = i.child; i !== null;)af(e, t, i), i = i.sibling } function af(e, t, i) { if (Lt && typeof Lt.onCommitFiberUnmount == "function") try { Lt.onCommitFiberUnmount(Fi, i) } catch { } switch (i.tag) { case 5: Ge || ur(i, t); case 6: var o = Fe, l = Rt; Fe = null, cn(e, t, i), Fe = o, Rt = l, Fe !== null && (Rt ? (e = Fe, i = i.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(i) : e.removeChild(i)) : Fe.removeChild(i.stateNode)); break; case 18: Fe !== null && (Rt ? (e = Fe, i = i.stateNode, e.nodeType === 8 ? ea(e.parentNode, i) : e.nodeType === 1 && ea(e, i), zr(e)) : ea(Fe, i.stateNode)); break; case 4: o = Fe, l = Rt, Fe = i.stateNode.containerInfo, Rt = !0, cn(e, t, i), Fe = o, Rt = l; break; case 0: case 11: case 14: case 15: if (!Ge && (o = i.updateQueue, o !== null && (o = o.lastEffect, o !== null))) { l = o = o.next; do { var c = l, m = c.destroy; c = c.tag, m !== void 0 && ((c & 2) !== 0 || (c & 4) !== 0) && Oa(i, t, m), l = l.next } while (l !== o) } cn(e, t, i); break; case 1: if (!Ge && (ur(i, t), o = i.stateNode, typeof o.componentWillUnmount == "function")) try { o.props = i.memoizedProps, o.state = i.memoizedState, o.componentWillUnmount() } catch (w) { Te(i, t, w) } cn(e, t, i); break; case 21: cn(e, t, i); break; case 22: i.mode & 1 ? (Ge = (o = Ge) || i.memoizedState !== null, cn(e, t, i), Ge = o) : cn(e, t, i); break; default: cn(e, t, i) } } function lf(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var i = e.stateNode; i === null && (i = e.stateNode = new _y), t.forEach(function (o) { var l = $y.bind(null, e, o); i.has(o) || (i.add(o), o.then(l, l)) }) } } function At(e, t) { var i = t.deletions; if (i !== null) for (var o = 0; o < i.length; o++) { var l = i[o]; try { var c = e, m = t, w = m; e: for (; w !== null;) { switch (w.tag) { case 5: Fe = w.stateNode, Rt = !1; break e; case 3: Fe = w.stateNode.containerInfo, Rt = !0; break e; case 4: Fe = w.stateNode.containerInfo, Rt = !0; break e }w = w.return } if (Fe === null) throw Error(s(160)); af(c, m, l), Fe = null, Rt = !1; var C = l.alternate; C !== null && (C.return = null), l.return = null } catch (T) { Te(l, t, T) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)uf(t, e), t = t.sibling } function uf(e, t) { var i = e.alternate, o = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (At(t, e), Ot(e), o & 4) { try { ai(3, e, e.return), Ts(3, e) } catch (G) { Te(e, e.return, G) } try { ai(5, e, e.return) } catch (G) { Te(e, e.return, G) } } break; case 1: At(t, e), Ot(e), o & 512 && i !== null && ur(i, i.return); break; case 5: if (At(t, e), Ot(e), o & 512 && i !== null && ur(i, i.return), e.flags & 32) { var l = e.stateNode; try { Nr(l, "") } catch (G) { Te(e, e.return, G) } } if (o & 4 && (l = e.stateNode, l != null)) { var c = e.memoizedProps, m = i !== null ? i.memoizedProps : c, w = e.type, C = e.updateQueue; if (e.updateQueue = null, C !== null) try { w === "input" && c.type === "radio" && c.name != null && Vu(l, c), vo(w, m); var T = vo(w, c); for (m = 0; m < C.length; m += 2) { var _ = C[m], V = C[m + 1]; _ === "style" ? Wu(l, V) : _ === "dangerouslySetInnerHTML" ? Uu(l, V) : _ === "children" ? Nr(l, V) : z(l, _, V, T) } switch (w) { case "input": ho(l, c); break; case "textarea": zu(l, c); break; case "select": var D = l._wrapperState.wasMultiple; l._wrapperState.wasMultiple = !!c.multiple; var H = c.value; H != null ? Un(l, !!c.multiple, H, !1) : D !== !!c.multiple && (c.defaultValue != null ? Un(l, !!c.multiple, c.defaultValue, !0) : Un(l, !!c.multiple, c.multiple ? [] : "", !1)) }l[Xr] = c } catch (G) { Te(e, e.return, G) } } break; case 6: if (At(t, e), Ot(e), o & 4) { if (e.stateNode === null) throw Error(s(162)); l = e.stateNode, c = e.memoizedProps; try { l.nodeValue = c } catch (G) { Te(e, e.return, G) } } break; case 3: if (At(t, e), Ot(e), o & 4 && i !== null && i.memoizedState.isDehydrated) try { zr(t.containerInfo) } catch (G) { Te(e, e.return, G) } break; case 4: At(t, e), Ot(e); break; case 13: At(t, e), Ot(e), l = e.child, l.flags & 8192 && (c = l.memoizedState !== null, l.stateNode.isHidden = c, !c || l.alternate !== null && l.alternate.memoizedState !== null || (Wa = Me())), o & 4 && lf(e); break; case 22: if (_ = i !== null && i.memoizedState !== null, e.mode & 1 ? (Ge = (T = Ge) || _, At(t, e), Ge = T) : At(t, e), Ot(e), o & 8192) { if (T = e.memoizedState !== null, (e.stateNode.isHidden = T) && !_ && (e.mode & 1) !== 0) for (W = e, _ = e.child; _ !== null;) { for (V = W = _; W !== null;) { switch (D = W, H = D.child, D.tag) { case 0: case 11: case 14: case 15: ai(4, D, D.return); break; case 1: ur(D, D.return); var K = D.stateNode; if (typeof K.componentWillUnmount == "function") { o = D, i = D.return; try { t = o, K.props = t.memoizedProps, K.state = t.memoizedState, K.componentWillUnmount() } catch (G) { Te(o, i, G) } } break; case 5: ur(D, D.return); break; case 22: if (D.memoizedState !== null) { ff(V); continue } }H !== null ? (H.return = D, W = H) : ff(V) } _ = _.sibling } e: for (_ = null, V = e; ;) { if (V.tag === 5) { if (_ === null) { _ = V; try { l = V.stateNode, T ? (c = l.style, typeof c.setProperty == "function" ? c.setProperty("display", "none", "important") : c.display = "none") : (w = V.stateNode, C = V.memoizedProps.style, m = C != null && C.hasOwnProperty("display") ? C.display : null, w.style.display = Hu("display", m)) } catch (G) { Te(e, e.return, G) } } } else if (V.tag === 6) { if (_ === null) try { V.stateNode.nodeValue = T ? "" : V.memoizedProps } catch (G) { Te(e, e.return, G) } } else if ((V.tag !== 22 && V.tag !== 23 || V.memoizedState === null || V === e) && V.child !== null) { V.child.return = V, V = V.child; continue } if (V === e) break e; for (; V.sibling === null;) { if (V.return === null || V.return === e) break e; _ === V && (_ = null), V = V.return } _ === V && (_ = null), V.sibling.return = V.return, V = V.sibling } } break; case 19: At(t, e), Ot(e), o & 4 && lf(e); break; case 21: break; default: At(t, e), Ot(e) } } function Ot(e) { var t = e.flags; if (t & 2) { try { e: { for (var i = e.return; i !== null;) { if (sf(i)) { var o = i; break e } i = i.return } throw Error(s(160)) } switch (o.tag) { case 5: var l = o.stateNode; o.flags & 32 && (Nr(l, ""), o.flags &= -33); var c = of(e); Ba(e, c, l); break; case 3: case 4: var m = o.stateNode.containerInfo, w = of(e); Fa(e, w, m); break; default: throw Error(s(161)) } } catch (C) { Te(e, e.return, C) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function Iy(e, t, i) { W = e, cf(e) } function cf(e, t, i) { for (var o = (e.mode & 1) !== 0; W !== null;) { var l = W, c = l.child; if (l.tag === 22 && o) { var m = l.memoizedState !== null || js; if (!m) { var w = l.alternate, C = w !== null && w.memoizedState !== null || Ge; w = js; var T = Ge; if (js = m, (Ge = C) && !T) for (W = l; W !== null;)m = W, C = m.child, m.tag === 22 && m.memoizedState !== null ? hf(l) : C !== null ? (C.return = m, W = C) : hf(l); for (; c !== null;)W = c, cf(c), c = c.sibling; W = l, js = w, Ge = T } df(e) } else (l.subtreeFlags & 8772) !== 0 && c !== null ? (c.return = l, W = c) : df(e) } } function df(e) { for (; W !== null;) { var t = W; if ((t.flags & 8772) !== 0) { var i = t.alternate; try { if ((t.flags & 8772) !== 0) switch (t.tag) { case 0: case 11: case 15: Ge || Ts(5, t); break; case 1: var o = t.stateNode; if (t.flags & 4 && !Ge) if (i === null) o.componentDidMount(); else { var l = t.elementType === t.type ? i.memoizedProps : Mt(t.type, i.memoizedProps); o.componentDidUpdate(l, i.memoizedState, o.__reactInternalSnapshotBeforeUpdate) } var c = t.updateQueue; c !== null && dd(t, c, o); break; case 3: var m = t.updateQueue; if (m !== null) { if (i = null, t.child !== null) switch (t.child.tag) { case 5: i = t.child.stateNode; break; case 1: i = t.child.stateNode }dd(t, m, i) } break; case 5: var w = t.stateNode; if (i === null && t.flags & 4) { i = w; var C = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": C.autoFocus && i.focus(); break; case "img": C.src && (i.src = C.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var T = t.alternate; if (T !== null) { var _ = T.memoizedState; if (_ !== null) { var V = _.dehydrated; V !== null && zr(V) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(s(163)) }Ge || t.flags & 512 && za(t) } catch (D) { Te(t, t.return, D) } } if (t === e) { W = null; break } if (i = t.sibling, i !== null) { i.return = t.return, W = i; break } W = t.return } } function ff(e) { for (; W !== null;) { var t = W; if (t === e) { W = null; break } var i = t.sibling; if (i !== null) { i.return = t.return, W = i; break } W = t.return } } function hf(e) { for (; W !== null;) { var t = W; try { switch (t.tag) { case 0: case 11: case 15: var i = t.return; try { Ts(4, t) } catch (C) { Te(t, i, C) } break; case 1: var o = t.stateNode; if (typeof o.componentDidMount == "function") { var l = t.return; try { o.componentDidMount() } catch (C) { Te(t, l, C) } } var c = t.return; try { za(t) } catch (C) { Te(t, c, C) } break; case 5: var m = t.return; try { za(t) } catch (C) { Te(t, m, C) } } } catch (C) { Te(t, t.return, C) } if (t === e) { W = null; break } var w = t.sibling; if (w !== null) { w.return = t.return, W = w; break } W = t.return } } var Oy = Math.ceil, Ns = Y.ReactCurrentDispatcher, Ua = Y.ReactCurrentOwner, wt = Y.ReactCurrentBatchConfig, le = 0, Oe = null, be = null, Be = 0, mt = 0, cr = sn(0), _e = 0, li = null, Rn = 0, Ms = 0, Ha = 0, ui = null, st = null, Wa = 0, dr = 1 / 0, qt = null, Rs = !1, $a = null, dn = null, As = !1, fn = null, bs = 0, ci = 0, Ka = null, Ds = -1, Ls = 0; function Je() { return (le & 6) !== 0 ? Me() : Ds !== -1 ? Ds : Ds = Me() } function hn(e) { return (e.mode & 1) === 0 ? 1 : (le & 2) !== 0 && Be !== 0 ? Be & -Be : Sy.transition !== null ? (Ls === 0 && (Ls = sc()), Ls) : (e = he, e !== 0 || (e = window.event, e = e === void 0 ? 16 : pc(e.type)), e) } function bt(e, t, i, o) { if (50 < ci) throw ci = 0, Ka = null, Error(s(185)); Lr(e, i, o), ((le & 2) === 0 || e !== Oe) && (e === Oe && ((le & 2) === 0 && (Ms |= i), _e === 4 && pn(e, Be)), ot(e, o), i === 1 && le === 0 && (t.mode & 1) === 0 && (dr = Me() + 500, ls && an())) } function ot(e, t) { var i = e.callbackNode; Sg(e, t); var o = Hi(e, e === Oe ? Be : 0); if (o === 0) i !== null && nc(i), e.callbackNode = null, e.callbackPriority = 0; else if (t = o & -o, e.callbackPriority !== t) { if (i != null && nc(i), t === 1) e.tag === 0 ? wy(mf.bind(null, e)) : Jc(mf.bind(null, e)), gy(function () { (le & 6) === 0 && an() }), i = null; else { switch (oc(o)) { case 1: i = Eo; break; case 4: i = rc; break; case 16: i = zi; break; case 536870912: i = ic; break; default: i = zi }i = kf(i, pf.bind(null, e)) } e.callbackPriority = t, e.callbackNode = i } } function pf(e, t) { if (Ds = -1, Ls = 0, (le & 6) !== 0) throw Error(s(327)); var i = e.callbackNode; if (fr() && e.callbackNode !== i) return null; var o = Hi(e, e === Oe ? Be : 0); if (o === 0) return null; if ((o & 30) !== 0 || (o & e.expiredLanes) !== 0 || t) t = _s(e, o); else { t = o; var l = le; le |= 2; var c = yf(); (Oe !== e || Be !== t) && (qt = null, dr = Me() + 500, bn(e, t)); do try { By(); break } catch (w) { gf(e, w) } while (!0); ca(), Ns.current = c, le = l, be !== null ? t = 0 : (Oe = null, Be = 0, t = _e) } if (t !== 0) { if (t === 2 && (l = jo(e), l !== 0 && (o = l, t = Ga(e, l))), t === 1) throw i = li, bn(e, 0), pn(e, o), ot(e, Me()), i; if (t === 6) pn(e, o); else { if (l = e.current.alternate, (o & 30) === 0 && !zy(l) && (t = _s(e, o), t === 2 && (c = jo(e), c !== 0 && (o = c, t = Ga(e, c))), t === 1)) throw i = li, bn(e, 0), pn(e, o), ot(e, Me()), i; switch (e.finishedWork = l, e.finishedLanes = o, t) { case 0: case 1: throw Error(s(345)); case 2: Dn(e, st, qt); break; case 3: if (pn(e, o), (o & 130023424) === o && (t = Wa + 500 - Me(), 10 < t)) { if (Hi(e, 0) !== 0) break; if (l = e.suspendedLanes, (l & o) !== o) { Je(), e.pingedLanes |= e.suspendedLanes & l; break } e.timeoutHandle = Jo(Dn.bind(null, e, st, qt), t); break } Dn(e, st, qt); break; case 4: if (pn(e, o), (o & 4194240) === o) break; for (t = e.eventTimes, l = -1; 0 < o;) { var m = 31 - jt(o); c = 1 << m, m = t[m], m > l && (l = m), o &= ~c } if (o = l, o = Me() - o, o = (120 > o ? 120 : 480 > o ? 480 : 1080 > o ? 1080 : 1920 > o ? 1920 : 3e3 > o ? 3e3 : 4320 > o ? 4320 : 1960 * Oy(o / 1960)) - o, 10 < o) { e.timeoutHandle = Jo(Dn.bind(null, e, st, qt), o); break } Dn(e, st, qt); break; case 5: Dn(e, st, qt); break; default: throw Error(s(329)) } } } return ot(e, Me()), e.callbackNode === i ? pf.bind(null, e) : null } function Ga(e, t) { var i = ui; return e.current.memoizedState.isDehydrated && (bn(e, t).flags |= 256), e = _s(e, t), e !== 2 && (t = st, st = i, t !== null && qa(t)), e } function qa(e) { st === null ? st = e : st.push.apply(st, e) } function zy(e) { for (var t = e; ;) { if (t.flags & 16384) { var i = t.updateQueue; if (i !== null && (i = i.stores, i !== null)) for (var o = 0; o < i.length; o++) { var l = i[o], c = l.getSnapshot; l = l.value; try { if (!Tt(c(), l)) return !1 } catch { return !1 } } } if (i = t.child, t.subtreeFlags & 16384 && i !== null) i.return = t, t = i; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function pn(e, t) { for (t &= ~Ha, t &= ~Ms, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var i = 31 - jt(t), o = 1 << i; e[i] = -1, t &= ~o } } function mf(e) { if ((le & 6) !== 0) throw Error(s(327)); fr(); var t = Hi(e, 0); if ((t & 1) === 0) return ot(e, Me()), null; var i = _s(e, t); if (e.tag !== 0 && i === 2) { var o = jo(e); o !== 0 && (t = o, i = Ga(e, o)) } if (i === 1) throw i = li, bn(e, 0), pn(e, t), ot(e, Me()), i; if (i === 6) throw Error(s(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Dn(e, st, qt), ot(e, Me()), null } function Ya(e, t) { var i = le; le |= 1; try { return e(t) } finally { le = i, le === 0 && (dr = Me() + 500, ls && an()) } } function An(e) { fn !== null && fn.tag === 0 && (le & 6) === 0 && fr(); var t = le; le |= 1; var i = wt.transition, o = he; try { if (wt.transition = null, he = 1, e) return e() } finally { he = o, wt.transition = i, le = t, (le & 6) === 0 && an() } } function Xa() { mt = cr.current, we(cr) } function bn(e, t) { e.finishedWork = null, e.finishedLanes = 0; var i = e.timeoutHandle; if (i !== -1 && (e.timeoutHandle = -1, my(i)), be !== null) for (i = be.return; i !== null;) { var o = i; switch (sa(o), o.tag) { case 1: o = o.type.childContextTypes, o != null && os(); break; case 3: ar(), we(nt), we(We), va(); break; case 5: ga(o); break; case 4: ar(); break; case 13: we(Pe); break; case 19: we(Pe); break; case 10: da(o.type._context); break; case 22: case 23: Xa() }i = i.return } if (Oe = e, be = e = mn(e.current, null), Be = mt = t, _e = 0, li = null, Ha = Ms = Rn = 0, st = ui = null, Tn !== null) { for (t = 0; t < Tn.length; t++)if (i = Tn[t], o = i.interleaved, o !== null) { i.interleaved = null; var l = o.next, c = i.pending; if (c !== null) { var m = c.next; c.next = l, o.next = m } i.pending = o } Tn = null } return e } function gf(e, t) { do { var i = be; try { if (ca(), vs.current = Cs, xs) { for (var o = Ee.memoizedState; o !== null;) { var l = o.queue; l !== null && (l.pending = null), o = o.next } xs = !1 } if (Mn = 0, Ie = Le = Ee = null, ni = !1, ri = 0, Ua.current = null, i === null || i.return === null) { _e = 1, li = t, be = null; break } e: { var c = e, m = i.return, w = i, C = t; if (t = Be, w.flags |= 32768, C !== null && typeof C == "object" && typeof C.then == "function") { var T = C, _ = w, V = _.tag; if ((_.mode & 1) === 0 && (V === 0 || V === 11 || V === 15)) { var D = _.alternate; D ? (_.updateQueue = D.updateQueue, _.memoizedState = D.memoizedState, _.lanes = D.lanes) : (_.updateQueue = null, _.memoizedState = null) } var H = Fd(m); if (H !== null) { H.flags &= -257, Bd(H, m, w, c, t), H.mode & 1 && zd(c, T, t), t = H, C = T; var K = t.updateQueue; if (K === null) { var G = new Set; G.add(C), t.updateQueue = G } else K.add(C); break e } else { if ((t & 1) === 0) { zd(c, T, t), Qa(); break e } C = Error(s(426)) } } else if (Ce && w.mode & 1) { var Re = Fd(m); if (Re !== null) { (Re.flags & 65536) === 0 && (Re.flags |= 256), Bd(Re, m, w, c, t), la(lr(C, w)); break e } } c = C = lr(C, w), _e !== 4 && (_e = 2), ui === null ? ui = [c] : ui.push(c), c = m; do { switch (c.tag) { case 3: c.flags |= 65536, t &= -t, c.lanes |= t; var E = Id(c, C, t); cd(c, E); break e; case 1: w = C; var k = c.type, j = c.stateNode; if ((c.flags & 128) === 0 && (typeof k.getDerivedStateFromError == "function" || j !== null && typeof j.componentDidCatch == "function" && (dn === null || !dn.has(j)))) { c.flags |= 65536, t &= -t, c.lanes |= t; var O = Od(c, w, t); cd(c, O); break e } }c = c.return } while (c !== null) } xf(i) } catch (q) { t = q, be === i && i !== null && (be = i = i.return); continue } break } while (!0) } function yf() { var e = Ns.current; return Ns.current = Cs, e === null ? Cs : e } function Qa() { (_e === 0 || _e === 3 || _e === 2) && (_e = 4), Oe === null || (Rn & 268435455) === 0 && (Ms & 268435455) === 0 || pn(Oe, Be) } function _s(e, t) { var i = le; le |= 2; var o = yf(); (Oe !== e || Be !== t) && (qt = null, bn(e, t)); do try { Fy(); break } catch (l) { gf(e, l) } while (!0); if (ca(), le = i, Ns.current = o, be !== null) throw Error(s(261)); return Oe = null, Be = 0, _e } function Fy() { for (; be !== null;)vf(be) } function By() { for (; be !== null && !fg();)vf(be) } function vf(e) { var t = Cf(e.alternate, e, mt); e.memoizedProps = e.pendingProps, t === null ? xf(e) : be = t, Ua.current = null } function xf(e) { var t = e; do { var i = t.alternate; if (e = t.return, (t.flags & 32768) === 0) { if (i = Dy(i, t, mt), i !== null) { be = i; return } } else { if (i = Ly(i, t), i !== null) { i.flags &= 32767, be = i; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { _e = 6, be = null; return } } if (t = t.sibling, t !== null) { be = t; return } be = t = e } while (t !== null); _e === 0 && (_e = 5) } function Dn(e, t, i) { var o = he, l = wt.transition; try { wt.transition = null, he = 1, Uy(e, t, i, o) } finally { wt.transition = l, he = o } return null } function Uy(e, t, i, o) { do fr(); while (fn !== null); if ((le & 6) !== 0) throw Error(s(327)); i = e.finishedWork; var l = e.finishedLanes; if (i === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, i === e.current) throw Error(s(177)); e.callbackNode = null, e.callbackPriority = 0; var c = i.lanes | i.childLanes; if (Cg(e, c), e === Oe && (be = Oe = null, Be = 0), (i.subtreeFlags & 2064) === 0 && (i.flags & 2064) === 0 || As || (As = !0, kf(zi, function () { return fr(), null })), c = (i.flags & 15990) !== 0, (i.subtreeFlags & 15990) !== 0 || c) { c = wt.transition, wt.transition = null; var m = he; he = 1; var w = le; le |= 4, Ua.current = null, Vy(e, i), uf(i, e), ly(Qo), Ki = !!Xo, Qo = Xo = null, e.current = i, Iy(i), hg(), le = w, he = m, wt.transition = c } else e.current = i; if (As && (As = !1, fn = e, bs = l), c = e.pendingLanes, c === 0 && (dn = null), gg(i.stateNode), ot(e, Me()), t !== null) for (o = e.onRecoverableError, i = 0; i < t.length; i++)l = t[i], o(l.value, { componentStack: l.stack, digest: l.digest }); if (Rs) throw Rs = !1, e = $a, $a = null, e; return (bs & 1) !== 0 && e.tag !== 0 && fr(), c = e.pendingLanes, (c & 1) !== 0 ? e === Ka ? ci++ : (ci = 0, Ka = e) : ci = 0, an(), null } function fr() { if (fn !== null) { var e = oc(bs), t = wt.transition, i = he; try { if (wt.transition = null, he = 16 > e ? 16 : e, fn === null) var o = !1; else { if (e = fn, fn = null, bs = 0, (le & 6) !== 0) throw Error(s(331)); var l = le; for (le |= 4, W = e.current; W !== null;) { var c = W, m = c.child; if ((W.flags & 16) !== 0) { var w = c.deletions; if (w !== null) { for (var C = 0; C < w.length; C++) { var T = w[C]; for (W = T; W !== null;) { var _ = W; switch (_.tag) { case 0: case 11: case 15: ai(8, _, c) }var V = _.child; if (V !== null) V.return = _, W = V; else for (; W !== null;) { _ = W; var D = _.sibling, H = _.return; if (rf(_), _ === T) { W = null; break } if (D !== null) { D.return = H, W = D; break } W = H } } } var K = c.alternate; if (K !== null) { var G = K.child; if (G !== null) { K.child = null; do { var Re = G.sibling; G.sibling = null, G = Re } while (G !== null) } } W = c } } if ((c.subtreeFlags & 2064) !== 0 && m !== null) m.return = c, W = m; else e: for (; W !== null;) { if (c = W, (c.flags & 2048) !== 0) switch (c.tag) { case 0: case 11: case 15: ai(9, c, c.return) }var E = c.sibling; if (E !== null) { E.return = c.return, W = E; break e } W = c.return } } var k = e.current; for (W = k; W !== null;) { m = W; var j = m.child; if ((m.subtreeFlags & 2064) !== 0 && j !== null) j.return = m, W = j; else e: for (m = k; W !== null;) { if (w = W, (w.flags & 2048) !== 0) try { switch (w.tag) { case 0: case 11: case 15: Ts(9, w) } } catch (q) { Te(w, w.return, q) } if (w === m) { W = null; break e } var O = w.sibling; if (O !== null) { O.return = w.return, W = O; break e } W = w.return } } if (le = l, an(), Lt && typeof Lt.onPostCommitFiberRoot == "function") try { Lt.onPostCommitFiberRoot(Fi, e) } catch { } o = !0 } return o } finally { he = i, wt.transition = t } } return !1 } function wf(e, t, i) { t = lr(i, t), t = Id(e, t, 1), e = un(e, t, 1), t = Je(), e !== null && (Lr(e, 1, t), ot(e, t)) } function Te(e, t, i) { if (e.tag === 3) wf(e, e, i); else for (; t !== null;) { if (t.tag === 3) { wf(t, e, i); break } else if (t.tag === 1) { var o = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof o.componentDidCatch == "function" && (dn === null || !dn.has(o))) { e = lr(i, e), e = Od(t, e, 1), t = un(t, e, 1), e = Je(), t !== null && (Lr(t, 1, e), ot(t, e)); break } } t = t.return } } function Hy(e, t, i) { var o = e.pingCache; o !== null && o.delete(t), t = Je(), e.pingedLanes |= e.suspendedLanes & i, Oe === e && (Be & i) === i && (_e === 4 || _e === 3 && (Be & 130023424) === Be && 500 > Me() - Wa ? bn(e, 0) : Ha |= i), ot(e, t) } function Sf(e, t) { t === 0 && ((e.mode & 1) === 0 ? t = 1 : (t = Ui, Ui <<= 1, (Ui & 130023424) === 0 && (Ui = 4194304))); var i = Je(); e = $t(e, t), e !== null && (Lr(e, t, i), ot(e, i)) } function Wy(e) { var t = e.memoizedState, i = 0; t !== null && (i = t.retryLane), Sf(e, i) } function $y(e, t) { var i = 0; switch (e.tag) { case 13: var o = e.stateNode, l = e.memoizedState; l !== null && (i = l.retryLane); break; case 19: o = e.stateNode; break; default: throw Error(s(314)) }o !== null && o.delete(t), Sf(e, i) } var Cf; Cf = function (e, t, i) { if (e !== null) if (e.memoizedProps !== t.pendingProps || nt.current) it = !0; else { if ((e.lanes & i) === 0 && (t.flags & 128) === 0) return it = !1, by(e, t, i); it = (e.flags & 131072) !== 0 } else it = !1, Ce && (t.flags & 1048576) !== 0 && ed(t, cs, t.index); switch (t.lanes = 0, t.tag) { case 2: var o = t.type; Es(e, t), e = t.pendingProps; var l = er(t, We.current); or(t, i), l = Sa(null, t, o, e, l, i); var c = Ca(); return t.flags |= 1, typeof l == "object" && l !== null && typeof l.render == "function" && l.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, rt(o) ? (c = !0, as(t)) : c = !1, t.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, pa(t), l.updater = ks, t.stateNode = l, l._reactInternals = t, Na(t, o, e, i), t = ba(null, t, o, !0, c, i)) : (t.tag = 0, Ce && c && ia(t), Ze(null, t, l, i), t = t.child), t; case 16: o = t.elementType; e: { switch (Es(e, t), e = t.pendingProps, l = o._init, o = l(o._payload), t.type = o, l = t.tag = Gy(o), e = Mt(o, e), l) { case 0: t = Aa(null, t, o, e, i); break e; case 1: t = Gd(null, t, o, e, i); break e; case 11: t = Ud(null, t, o, e, i); break e; case 14: t = Hd(null, t, o, Mt(o.type, e), i); break e }throw Error(s(306, o, "")) } return t; case 0: return o = t.type, l = t.pendingProps, l = t.elementType === o ? l : Mt(o, l), Aa(e, t, o, l, i); case 1: return o = t.type, l = t.pendingProps, l = t.elementType === o ? l : Mt(o, l), Gd(e, t, o, l, i); case 3: e: { if (qd(t), e === null) throw Error(s(387)); o = t.pendingProps, c = t.memoizedState, l = c.element, ud(e, t), gs(t, o, null, i); var m = t.memoizedState; if (o = m.element, c.isDehydrated) if (c = { element: o, isDehydrated: !1, cache: m.cache, pendingSuspenseBoundaries: m.pendingSuspenseBoundaries, transitions: m.transitions }, t.updateQueue.baseState = c, t.memoizedState = c, t.flags & 256) { l = lr(Error(s(423)), t), t = Yd(e, t, o, i, l); break e } else if (o !== l) { l = lr(Error(s(424)), t), t = Yd(e, t, o, i, l); break e } else for (pt = rn(t.stateNode.containerInfo.firstChild), ht = t, Ce = !0, Nt = null, i = ad(t, null, o, i), t.child = i; i;)i.flags = i.flags & -3 | 4096, i = i.sibling; else { if (rr(), o === l) { t = Gt(e, t, i); break e } Ze(e, t, o, i) } t = t.child } return t; case 5: return fd(t), e === null && aa(t), o = t.type, l = t.pendingProps, c = e !== null ? e.memoizedProps : null, m = l.children, Zo(o, l) ? m = null : c !== null && Zo(o, c) && (t.flags |= 32), Kd(e, t), Ze(e, t, m, i), t.child; case 6: return e === null && aa(t), null; case 13: return Xd(e, t, i); case 4: return ma(t, t.stateNode.containerInfo), o = t.pendingProps, e === null ? t.child = ir(t, null, o, i) : Ze(e, t, o, i), t.child; case 11: return o = t.type, l = t.pendingProps, l = t.elementType === o ? l : Mt(o, l), Ud(e, t, o, l, i); case 7: return Ze(e, t, t.pendingProps, i), t.child; case 8: return Ze(e, t, t.pendingProps.children, i), t.child; case 12: return Ze(e, t, t.pendingProps.children, i), t.child; case 10: e: { if (o = t.type._context, l = t.pendingProps, c = t.memoizedProps, m = l.value, ye(hs, o._currentValue), o._currentValue = m, c !== null) if (Tt(c.value, m)) { if (c.children === l.children && !nt.current) { t = Gt(e, t, i); break e } } else for (c = t.child, c !== null && (c.return = t); c !== null;) { var w = c.dependencies; if (w !== null) { m = c.child; for (var C = w.firstContext; C !== null;) { if (C.context === o) { if (c.tag === 1) { C = Kt(-1, i & -i), C.tag = 2; var T = c.updateQueue; if (T !== null) { T = T.shared; var _ = T.pending; _ === null ? C.next = C : (C.next = _.next, _.next = C), T.pending = C } } c.lanes |= i, C = c.alternate, C !== null && (C.lanes |= i), fa(c.return, i, t), w.lanes |= i; break } C = C.next } } else if (c.tag === 10) m = c.type === t.type ? null : c.child; else if (c.tag === 18) { if (m = c.return, m === null) throw Error(s(341)); m.lanes |= i, w = m.alternate, w !== null && (w.lanes |= i), fa(m, i, t), m = c.sibling } else m = c.child; if (m !== null) m.return = c; else for (m = c; m !== null;) { if (m === t) { m = null; break } if (c = m.sibling, c !== null) { c.return = m.return, m = c; break } m = m.return } c = m } Ze(e, t, l.children, i), t = t.child } return t; case 9: return l = t.type, o = t.pendingProps.children, or(t, i), l = vt(l), o = o(l), t.flags |= 1, Ze(e, t, o, i), t.child; case 14: return o = t.type, l = Mt(o, t.pendingProps), l = Mt(o.type, l), Hd(e, t, o, l, i); case 15: return Wd(e, t, t.type, t.pendingProps, i); case 17: return o = t.type, l = t.pendingProps, l = t.elementType === o ? l : Mt(o, l), Es(e, t), t.tag = 1, rt(o) ? (e = !0, as(t)) : e = !1, or(t, i), _d(t, o, l), Na(t, o, l, i), ba(null, t, o, !0, e, i); case 19: return Zd(e, t, i); case 22: return $d(e, t, i) }throw Error(s(156, t.tag)) }; function kf(e, t) { return tc(e, t) } function Ky(e, t, i, o) { this.tag = e, this.key = i, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = o, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function St(e, t, i, o) { return new Ky(e, t, i, o) } function Za(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function Gy(e) { if (typeof e == "function") return Za(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === ut) return 11; if (e === ct) return 14 } return 2 } function mn(e, t) { var i = e.alternate; return i === null ? (i = St(e.tag, t, e.key, e.mode), i.elementType = e.elementType, i.type = e.type, i.stateNode = e.stateNode, i.alternate = e, e.alternate = i) : (i.pendingProps = t, i.type = e.type, i.flags = 0, i.subtreeFlags = 0, i.deletions = null), i.flags = e.flags & 14680064, i.childLanes = e.childLanes, i.lanes = e.lanes, i.child = e.child, i.memoizedProps = e.memoizedProps, i.memoizedState = e.memoizedState, i.updateQueue = e.updateQueue, t = e.dependencies, i.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, i.sibling = e.sibling, i.index = e.index, i.ref = e.ref, i } function Vs(e, t, i, o, l, c) { var m = 2; if (o = e, typeof e == "function") Za(e) && (m = 1); else if (typeof e == "string") m = 5; else e: switch (e) { case te: return Ln(i.children, l, c, t); case Q: m = 8, l |= 8; break; case pe: return e = St(12, i, t, l | 2), e.elementType = pe, e.lanes = c, e; case Xe: return e = St(13, i, t, l), e.elementType = Xe, e.lanes = c, e; case tt: return e = St(19, i, t, l), e.elementType = tt, e.lanes = c, e; case ie: return Is(i, l, c, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case ve: m = 10; break e; case He: m = 9; break e; case ut: m = 11; break e; case ct: m = 14; break e; case Qe: m = 16, o = null; break e }throw Error(s(130, e == null ? e : typeof e, "")) }return t = St(m, i, t, l), t.elementType = e, t.type = o, t.lanes = c, t } function Ln(e, t, i, o) { return e = St(7, e, o, t), e.lanes = i, e } function Is(e, t, i, o) { return e = St(22, e, o, t), e.elementType = ie, e.lanes = i, e.stateNode = { isHidden: !1 }, e } function Ja(e, t, i) { return e = St(6, e, null, t), e.lanes = i, e } function el(e, t, i) { return t = St(4, e.children !== null ? e.children : [], e.key, t), t.lanes = i, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function qy(e, t, i, o, l) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = To(0), this.expirationTimes = To(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = To(0), this.identifierPrefix = o, this.onRecoverableError = l, this.mutableSourceEagerHydrationData = null } function tl(e, t, i, o, l, c, m, w, C) { return e = new qy(e, t, i, w, C), t === 1 ? (t = 1, c === !0 && (t |= 8)) : t = 0, c = St(3, null, null, t), e.current = c, c.stateNode = e, c.memoizedState = { element: o, isDehydrated: i, cache: null, transitions: null, pendingSuspenseBoundaries: null }, pa(c), e } function Yy(e, t, i) { var o = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Z, key: o == null ? null : "" + o, children: e, containerInfo: t, implementation: i } } function Pf(e) { if (!e) return on; e = e._reactInternals; e: { if (Cn(e) !== e || e.tag !== 1) throw Error(s(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (rt(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(s(171)) } if (e.tag === 1) { var i = e.type; if (rt(i)) return Qc(e, i, t) } return t } function Ef(e, t, i, o, l, c, m, w, C) { return e = tl(i, o, !0, e, l, c, m, w, C), e.context = Pf(null), i = e.current, o = Je(), l = hn(i), c = Kt(o, l), c.callback = t ?? null, un(i, c, l), e.current.lanes = l, Lr(e, l, o), ot(e, o), e } function Os(e, t, i, o) { var l = t.current, c = Je(), m = hn(l); return i = Pf(i), t.context === null ? t.context = i : t.pendingContext = i, t = Kt(c, m), t.payload = { element: e }, o = o === void 0 ? null : o, o !== null && (t.callback = o), e = un(l, t, m), e !== null && (bt(e, l, m, c), ms(e, l, m)), m } function zs(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function jf(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var i = e.retryLane; e.retryLane = i !== 0 && i < t ? i : t } } function nl(e, t) { jf(e, t), (e = e.alternate) && jf(e, t) } function Xy() { return null } var Tf = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function rl(e) { this._internalRoot = e } Fs.prototype.render = rl.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(s(409)); Os(e, t, null, null) }, Fs.prototype.unmount = rl.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; An(function () { Os(null, e, null, null) }), t[Bt] = null } }; function Fs(e) { this._internalRoot = e } Fs.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = uc(); e = { blockedOn: null, target: e, priority: t }; for (var i = 0; i < en.length && t !== 0 && t < en[i].priority; i++); en.splice(i, 0, e), i === 0 && fc(e) } }; function il(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function Bs(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function Nf() { } function Qy(e, t, i, o, l) { if (l) { if (typeof o == "function") { var c = o; o = function () { var T = zs(m); c.call(T) } } var m = Ef(t, o, e, 0, null, !1, !1, "", Nf); return e._reactRootContainer = m, e[Bt] = m.current, qr(e.nodeType === 8 ? e.parentNode : e), An(), m } for (; l = e.lastChild;)e.removeChild(l); if (typeof o == "function") { var w = o; o = function () { var T = zs(C); w.call(T) } } var C = tl(e, 0, !1, null, null, !1, !1, "", Nf); return e._reactRootContainer = C, e[Bt] = C.current, qr(e.nodeType === 8 ? e.parentNode : e), An(function () { Os(t, C, i, o) }), C } function Us(e, t, i, o, l) { var c = i._reactRootContainer; if (c) { var m = c; if (typeof l == "function") { var w = l; l = function () { var C = zs(m); w.call(C) } } Os(t, m, e, l) } else m = Qy(i, t, e, l, o); return zs(m) } ac = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var i = Dr(t.pendingLanes); i !== 0 && (No(t, i | 1), ot(t, Me()), (le & 6) === 0 && (dr = Me() + 500, an())) } break; case 13: An(function () { var o = $t(e, 1); if (o !== null) { var l = Je(); bt(o, e, 1, l) } }), nl(e, 1) } }, Mo = function (e) { if (e.tag === 13) { var t = $t(e, 134217728); if (t !== null) { var i = Je(); bt(t, e, 134217728, i) } nl(e, 134217728) } }, lc = function (e) { if (e.tag === 13) { var t = hn(e), i = $t(e, t); if (i !== null) { var o = Je(); bt(i, e, t, o) } nl(e, t) } }, uc = function () { return he }, cc = function (e, t) { var i = he; try { return he = e, t() } finally { he = i } }, So = function (e, t, i) { switch (t) { case "input": if (ho(e, i), t = i.name, i.type === "radio" && t != null) { for (i = e; i.parentNode;)i = i.parentNode; for (i = i.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < i.length; t++) { var o = i[t]; if (o !== e && o.form === e.form) { var l = ss(o); if (!l) throw Error(s(90)); Lu(o), ho(o, l) } } } break; case "textarea": zu(e, i); break; case "select": t = i.value, t != null && Un(e, !!i.multiple, t, !1) } }, qu = Ya, Yu = An; var Zy = { usingClientEntryPoint: !1, Events: [Qr, Zn, ss, Ku, Gu, Ya] }, di = { findFiberByHostInstance: kn, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Jy = { bundleType: di.bundleType, version: di.version, rendererPackageName: di.rendererPackageName, rendererConfig: di.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Y.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Ju(e), e === null ? null : e.stateNode }, findFiberByHostInstance: di.findFiberByHostInstance || Xy, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Hs = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Hs.isDisabled && Hs.supportsFiber) try { Fi = Hs.inject(Jy), Lt = Hs } catch { } } return at.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Zy, at.createPortal = function (e, t) { var i = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!il(t)) throw Error(s(200)); return Yy(e, t, null, i) }, at.createRoot = function (e, t) { if (!il(e)) throw Error(s(299)); var i = !1, o = "", l = Tf; return t != null && (t.unstable_strictMode === !0 && (i = !0), t.identifierPrefix !== void 0 && (o = t.identifierPrefix), t.onRecoverableError !== void 0 && (l = t.onRecoverableError)), t = tl(e, 1, !1, null, null, i, !1, o, l), e[Bt] = t.current, qr(e.nodeType === 8 ? e.parentNode : e), new rl(t) }, at.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(s(188)) : (e = Object.keys(e).join(","), Error(s(268, e))); return e = Ju(t), e = e === null ? null : e.stateNode, e }, at.flushSync = function (e) { return An(e) }, at.hydrate = function (e, t, i) { if (!Bs(t)) throw Error(s(200)); return Us(null, e, t, !0, i) }, at.hydrateRoot = function (e, t, i) { if (!il(e)) throw Error(s(405)); var o = i != null && i.hydratedSources || null, l = !1, c = "", m = Tf; if (i != null && (i.unstable_strictMode === !0 && (l = !0), i.identifierPrefix !== void 0 && (c = i.identifierPrefix), i.onRecoverableError !== void 0 && (m = i.onRecoverableError)), t = Ef(t, null, e, 1, i ?? null, l, !1, c, m), e[Bt] = t.current, qr(e), o) for (e = 0; e < o.length; e++)i = o[e], l = i._getVersion, l = l(i._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [i, l] : t.mutableSourceEagerHydrationData.push(i, l); return new Fs(t) }, at.render = function (e, t, i) { if (!Bs(t)) throw Error(s(200)); return Us(null, e, t, !1, i) }, at.unmountComponentAtNode = function (e) { if (!Bs(e)) throw Error(s(40)); return e._reactRootContainer ? (An(function () { Us(null, null, e, !1, function () { e._reactRootContainer = null, e[Bt] = null }) }), !0) : !1 }, at.unstable_batchedUpdates = Ya, at.unstable_renderSubtreeIntoContainer = function (e, t, i, o) { if (!Bs(i)) throw Error(s(200)); if (e == null || e._reactInternals === void 0) throw Error(s(38)); return Us(e, t, i, !1, o) }, at.version = "18.3.1-next-f1338f8080-20240426", at
} var Vf; function up() { if (Vf) return al.exports; Vf = 1; function n() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n) } catch (r) { console.error(r) } } return n(), al.exports = l0(), al.exports } var If; function u0() { if (If) return Ws; If = 1; var n = up(); return Ws.createRoot = n.createRoot, Ws.hydrateRoot = n.hydrateRoot, Ws } var c0 = u0(), M = Ql(); const d0 = n0(M), f0 = t0({ __proto__: null, default: d0 }, [M]), Zl = M.createContext({}); function Jl(n) { const r = M.useRef(null); return r.current === null && (r.current = n()), r.current } const eu = typeof window < "u", cp = eu ? M.useLayoutEffect : M.useEffect, io = M.createContext(null); function tu(n, r) { n.indexOf(r) === -1 && n.push(r) } function nu(n, r) { const s = n.indexOf(r); s > -1 && n.splice(s, 1) } const Yt = (n, r, s) => s > r ? r : s < n ? n : s; let ru = () => { }; const Xt = {}, dp = n => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n); function fp(n) { return typeof n == "object" && n !== null } const hp = n => /^0[^.\s]+$/u.test(n); function iu(n) { let r; return () => (r === void 0 && (r = n()), r) } const Et = n => n, h0 = (n, r) => s => r(n(s)), Ri = (...n) => n.reduce(h0), Si = (n, r, s) => { const a = r - n; return a === 0 ? 1 : (s - n) / a }; class su { constructor() { this.subscriptions = [] } add(r) { return tu(this.subscriptions, r), () => nu(this.subscriptions, r) } notify(r, s, a) { const u = this.subscriptions.length; if (u) if (u === 1) this.subscriptions[0](r, s, a); else for (let f = 0; f < u; f++) { const d = this.subscriptions[f]; d && d(r, s, a) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const zt = n => n * 1e3, Pt = n => n / 1e3; function pp(n, r) { return r ? n * (1e3 / r) : 0 } const mp = (n, r, s) => (((1 - 3 * s + 3 * r) * n + (3 * s - 6 * r)) * n + 3 * r) * n, p0 = 1e-7, m0 = 12; function g0(n, r, s, a, u) { let f, d, h = 0; do d = r + (s - r) / 2, f = mp(d, a, u) - n, f > 0 ? s = d : r = d; while (Math.abs(f) > p0 && ++h < m0); return d } function Ai(n, r, s, a) { if (n === r && s === a) return Et; const u = f => g0(f, 0, 1, n, s); return f => f === 0 || f === 1 ? f : mp(u(f), r, a) } const gp = n => r => r <= .5 ? n(2 * r) / 2 : (2 - n(2 * (1 - r))) / 2, yp = n => r => 1 - n(1 - r), vp = Ai(.33, 1.53, .69, .99), ou = yp(vp), xp = gp(ou), wp = n => (n *= 2) < 1 ? .5 * ou(n) : .5 * (2 - Math.pow(2, -10 * (n - 1))), au = n => 1 - Math.sin(Math.acos(n)), Sp = yp(au), Cp = gp(au), y0 = Ai(.42, 0, 1, 1), v0 = Ai(0, 0, .58, 1), kp = Ai(.42, 0, .58, 1), x0 = n => Array.isArray(n) && typeof n[0] != "number", Pp = n => Array.isArray(n) && typeof n[0] == "number", w0 = { linear: Et, easeIn: y0, easeInOut: kp, easeOut: v0, circIn: au, circInOut: Cp, circOut: Sp, backIn: ou, backInOut: xp, backOut: vp, anticipate: wp }, S0 = n => typeof n == "string", Of = n => { if (Pp(n)) { ru(n.length === 4); const [r, s, a, u] = n; return Ai(r, s, a, u) } else if (S0(n)) return w0[n]; return n }, $s = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"]; function C0(n, r) { let s = new Set, a = new Set, u = !1, f = !1; const d = new WeakSet; let h = { delta: 0, timestamp: 0, isProcessing: !1 }; function p(y) { d.has(y) && (v.schedule(y), n()), y(h) } const v = { schedule: (y, x = !1, S = !1) => { const b = S && u ? s : a; return x && d.add(y), b.has(y) || b.add(y), y }, cancel: y => { a.delete(y), d.delete(y) }, process: y => { if (h = y, u) { f = !0; return } u = !0, [s, a] = [a, s], s.forEach(p), s.clear(), u = !1, f && (f = !1, v.process(y)) } }; return v } const k0 = 40; function Ep(n, r) { let s = !1, a = !0; const u = { delta: 0, timestamp: 0, isProcessing: !1 }, f = () => s = !0, d = $s.reduce((z, Y) => (z[Y] = C0(f), z), {}), { setup: h, read: p, resolveKeyframes: v, preUpdate: y, update: x, preRender: S, render: N, postRender: b } = d, A = () => { const z = Xt.useManualTiming ? u.timestamp : performance.now(); s = !1, Xt.useManualTiming || (u.delta = a ? 1e3 / 60 : Math.max(Math.min(z - u.timestamp, k0), 1)), u.timestamp = z, u.isProcessing = !0, h.process(u), p.process(u), v.process(u), y.process(u), x.process(u), S.process(u), N.process(u), b.process(u), u.isProcessing = !1, s && r && (a = !1, n(A)) }, R = () => { s = !0, a = !0, u.isProcessing || n(A) }; return { schedule: $s.reduce((z, Y) => { const $ = d[Y]; return z[Y] = (Z, te = !1, Q = !1) => (s || R(), $.schedule(Z, te, Q)), z }, {}), cancel: z => { for (let Y = 0; Y < $s.length; Y++)d[$s[Y]].cancel(z) }, state: u, steps: d } } const { schedule: ke, cancel: xn, state: Ue, steps: cl } = Ep(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Et, !0); let Ys; function P0() { Ys = void 0 } const lt = { now: () => (Ys === void 0 && lt.set(Ue.isProcessing || Xt.useManualTiming ? Ue.timestamp : performance.now()), Ys), set: n => { Ys = n, queueMicrotask(P0) } }, jp = n => r => typeof r == "string" && r.startsWith(n), lu = jp("--"), E0 = jp("var(--"), uu = n => E0(n) ? j0.test(n.split("/*")[0].trim()) : !1, j0 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Cr = { test: n => typeof n == "number", parse: parseFloat, transform: n => n }, Ci = { ...Cr, transform: n => Yt(0, 1, n) }, Ks = { ...Cr, default: 1 }, gi = n => Math.round(n * 1e5) / 1e5, cu = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function T0(n) { return n == null } const N0 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, du = (n, r) => s => !!(typeof s == "string" && N0.test(s) && s.startsWith(n) || r && !T0(s) && Object.prototype.hasOwnProperty.call(s, r)), Tp = (n, r, s) => a => { if (typeof a != "string") return a; const [u, f, d, h] = a.match(cu); return { [n]: parseFloat(u), [r]: parseFloat(f), [s]: parseFloat(d), alpha: h !== void 0 ? parseFloat(h) : 1 } }, M0 = n => Yt(0, 255, n), dl = { ...Cr, transform: n => Math.round(M0(n)) }, In = { test: du("rgb", "red"), parse: Tp("red", "green", "blue"), transform: ({ red: n, green: r, blue: s, alpha: a = 1 }) => "rgba(" + dl.transform(n) + ", " + dl.transform(r) + ", " + dl.transform(s) + ", " + gi(Ci.transform(a)) + ")" }; function R0(n) { let r = "", s = "", a = "", u = ""; return n.length > 5 ? (r = n.substring(1, 3), s = n.substring(3, 5), a = n.substring(5, 7), u = n.substring(7, 9)) : (r = n.substring(1, 2), s = n.substring(2, 3), a = n.substring(3, 4), u = n.substring(4, 5), r += r, s += s, a += a, u += u), { red: parseInt(r, 16), green: parseInt(s, 16), blue: parseInt(a, 16), alpha: u ? parseInt(u, 16) / 255 : 1 } } const jl = { test: du("#"), parse: R0, transform: In.transform }, bi = n => ({ test: r => typeof r == "string" && r.endsWith(n) && r.split(" ").length === 1, parse: parseFloat, transform: r => `${r}${n}` }), yn = bi("deg"), Ft = bi("%"), ne = bi("px"), A0 = bi("vh"), b0 = bi("vw"), zf = { ...Ft, parse: n => Ft.parse(n) / 100, transform: n => Ft.transform(n * 100) }, pr = { test: du("hsl", "hue"), parse: Tp("hue", "saturation", "lightness"), transform: ({ hue: n, saturation: r, lightness: s, alpha: a = 1 }) => "hsla(" + Math.round(n) + ", " + Ft.transform(gi(r)) + ", " + Ft.transform(gi(s)) + ", " + gi(Ci.transform(a)) + ")" }, De = { test: n => In.test(n) || jl.test(n) || pr.test(n), parse: n => In.test(n) ? In.parse(n) : pr.test(n) ? pr.parse(n) : jl.parse(n), transform: n => typeof n == "string" ? n : n.hasOwnProperty("red") ? In.transform(n) : pr.transform(n), getAnimatableNone: n => { const r = De.parse(n); return r.alpha = 0, De.transform(r) } }, D0 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function L0(n) { return isNaN(n) && typeof n == "string" && (n.match(cu)?.length || 0) + (n.match(D0)?.length || 0) > 0 } const Np = "number", Mp = "color", _0 = "var", V0 = "var(", Ff = "${}", I0 = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function ki(n) { const r = n.toString(), s = [], a = { color: [], number: [], var: [] }, u = []; let f = 0; const h = r.replace(I0, p => (De.test(p) ? (a.color.push(f), u.push(Mp), s.push(De.parse(p))) : p.startsWith(V0) ? (a.var.push(f), u.push(_0), s.push(p)) : (a.number.push(f), u.push(Np), s.push(parseFloat(p))), ++f, Ff)).split(Ff); return { values: s, split: h, indexes: a, types: u } } function Rp(n) { return ki(n).values } function Ap(n) { const { split: r, types: s } = ki(n), a = r.length; return u => { let f = ""; for (let d = 0; d < a; d++)if (f += r[d], u[d] !== void 0) { const h = s[d]; h === Np ? f += gi(u[d]) : h === Mp ? f += De.transform(u[d]) : f += u[d] } return f } } const O0 = n => typeof n == "number" ? 0 : De.test(n) ? De.getAnimatableNone(n) : n; function z0(n) { const r = Rp(n); return Ap(n)(r.map(O0)) } const wn = { test: L0, parse: Rp, createTransformer: Ap, getAnimatableNone: z0 }; function fl(n, r, s) { return s < 0 && (s += 1), s > 1 && (s -= 1), s < 1 / 6 ? n + (r - n) * 6 * s : s < 1 / 2 ? r : s < 2 / 3 ? n + (r - n) * (2 / 3 - s) * 6 : n } function F0({ hue: n, saturation: r, lightness: s, alpha: a }) { n /= 360, r /= 100, s /= 100; let u = 0, f = 0, d = 0; if (!r) u = f = d = s; else { const h = s < .5 ? s * (1 + r) : s + r - s * r, p = 2 * s - h; u = fl(p, h, n + 1 / 3), f = fl(p, h, n), d = fl(p, h, n - 1 / 3) } return { red: Math.round(u * 255), green: Math.round(f * 255), blue: Math.round(d * 255), alpha: a } } function Js(n, r) { return s => s > 0 ? r : n } const je = (n, r, s) => n + (r - n) * s, hl = (n, r, s) => { const a = n * n, u = s * (r * r - a) + a; return u < 0 ? 0 : Math.sqrt(u) }, B0 = [jl, In, pr], U0 = n => B0.find(r => r.test(n)); function Bf(n) { const r = U0(n); if (!r) return !1; let s = r.parse(n); return r === pr && (s = F0(s)), s } const Uf = (n, r) => { const s = Bf(n), a = Bf(r); if (!s || !a) return Js(n, r); const u = { ...s }; return f => (u.red = hl(s.red, a.red, f), u.green = hl(s.green, a.green, f), u.blue = hl(s.blue, a.blue, f), u.alpha = je(s.alpha, a.alpha, f), In.transform(u)) }, Tl = new Set(["none", "hidden"]); function H0(n, r) { return Tl.has(n) ? s => s <= 0 ? n : r : s => s >= 1 ? r : n } function W0(n, r) { return s => je(n, r, s) } function fu(n) { return typeof n == "number" ? W0 : typeof n == "string" ? uu(n) ? Js : De.test(n) ? Uf : G0 : Array.isArray(n) ? bp : typeof n == "object" ? De.test(n) ? Uf : $0 : Js } function bp(n, r) { const s = [...n], a = s.length, u = n.map((f, d) => fu(f)(f, r[d])); return f => { for (let d = 0; d < a; d++)s[d] = u[d](f); return s } } function $0(n, r) { const s = { ...n, ...r }, a = {}; for (const u in s) n[u] !== void 0 && r[u] !== void 0 && (a[u] = fu(n[u])(n[u], r[u])); return u => { for (const f in a) s[f] = a[f](u); return s } } function K0(n, r) { const s = [], a = { color: 0, var: 0, number: 0 }; for (let u = 0; u < r.values.length; u++) { const f = r.types[u], d = n.indexes[f][a[f]], h = n.values[d] ?? 0; s[u] = h, a[f]++ } return s } const G0 = (n, r) => { const s = wn.createTransformer(r), a = ki(n), u = ki(r); return a.indexes.var.length === u.indexes.var.length && a.indexes.color.length === u.indexes.color.length && a.indexes.number.length >= u.indexes.number.length ? Tl.has(n) && !u.values.length || Tl.has(r) && !a.values.length ? H0(n, r) : Ri(bp(K0(a, u), u.values), s) : Js(n, r) }; function Dp(n, r, s) { return typeof n == "number" && typeof r == "number" && typeof s == "number" ? je(n, r, s) : fu(n)(n, r) } const q0 = n => { const r = ({ timestamp: s }) => n(s); return { start: (s = !0) => ke.update(r, s), stop: () => xn(r), now: () => Ue.isProcessing ? Ue.timestamp : lt.now() } }, Lp = (n, r, s = 10) => { let a = ""; const u = Math.max(Math.round(r / s), 2); for (let f = 0; f < u; f++)a += Math.round(n(f / (u - 1)) * 1e4) / 1e4 + ", "; return `linear(${a.substring(0, a.length - 2)})` }, eo = 2e4; function hu(n) { let r = 0; const s = 50; let a = n.next(r); for (; !a.done && r < eo;)r += s, a = n.next(r); return r >= eo ? 1 / 0 : r } function Y0(n, r = 100, s) { const a = s({ ...n, keyframes: [0, r] }), u = Math.min(hu(a), eo); return { type: "keyframes", ease: f => a.next(u * f).value / r, duration: Pt(u) } } const X0 = 5; function _p(n, r, s) { const a = Math.max(r - X0, 0); return pp(s - n(a), r - a) } const Ne = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, pl = .001; function Q0({ duration: n = Ne.duration, bounce: r = Ne.bounce, velocity: s = Ne.velocity, mass: a = Ne.mass }) { let u, f, d = 1 - r; d = Yt(Ne.minDamping, Ne.maxDamping, d), n = Yt(Ne.minDuration, Ne.maxDuration, Pt(n)), d < 1 ? (u = v => { const y = v * d, x = y * n, S = y - s, N = Nl(v, d), b = Math.exp(-x); return pl - S / N * b }, f = v => { const x = v * d * n, S = x * s + s, N = Math.pow(d, 2) * Math.pow(v, 2) * n, b = Math.exp(-x), A = Nl(Math.pow(v, 2), d); return (-u(v) + pl > 0 ? -1 : 1) * ((S - N) * b) / A }) : (u = v => { const y = Math.exp(-v * n), x = (v - s) * n + 1; return -pl + y * x }, f = v => { const y = Math.exp(-v * n), x = (s - v) * (n * n); return y * x }); const h = 5 / n, p = J0(u, f, h); if (n = zt(n), isNaN(p)) return { stiffness: Ne.stiffness, damping: Ne.damping, duration: n }; { const v = Math.pow(p, 2) * a; return { stiffness: v, damping: d * 2 * Math.sqrt(a * v), duration: n } } } const Z0 = 12; function J0(n, r, s) { let a = s; for (let u = 1; u < Z0; u++)a = a - n(a) / r(a); return a } function Nl(n, r) { return n * Math.sqrt(1 - r * r) } const ev = ["duration", "bounce"], tv = ["stiffness", "damping", "mass"]; function Hf(n, r) { return r.some(s => n[s] !== void 0) } function nv(n) { let r = { velocity: Ne.velocity, stiffness: Ne.stiffness, damping: Ne.damping, mass: Ne.mass, isResolvedFromDuration: !1, ...n }; if (!Hf(n, tv) && Hf(n, ev)) if (n.visualDuration) { const s = n.visualDuration, a = 2 * Math.PI / (s * 1.2), u = a * a, f = 2 * Yt(.05, 1, 1 - (n.bounce || 0)) * Math.sqrt(u); r = { ...r, mass: Ne.mass, stiffness: u, damping: f } } else { const s = Q0(n); r = { ...r, ...s, mass: Ne.mass }, r.isResolvedFromDuration = !0 } return r } function to(n = Ne.visualDuration, r = Ne.bounce) { const s = typeof n != "object" ? { visualDuration: n, keyframes: [0, 1], bounce: r } : n; let { restSpeed: a, restDelta: u } = s; const f = s.keyframes[0], d = s.keyframes[s.keyframes.length - 1], h = { done: !1, value: f }, { stiffness: p, damping: v, mass: y, duration: x, velocity: S, isResolvedFromDuration: N } = nv({ ...s, velocity: -Pt(s.velocity || 0) }), b = S || 0, A = v / (2 * Math.sqrt(p * y)), R = d - f, I = Pt(Math.sqrt(p / y)), B = Math.abs(R) < 5; a || (a = B ? Ne.restSpeed.granular : Ne.restSpeed.default), u || (u = B ? Ne.restDelta.granular : Ne.restDelta.default); let z; if (A < 1) { const $ = Nl(I, A); z = Z => { const te = Math.exp(-A * I * Z); return d - te * ((b + A * I * R) / $ * Math.sin($ * Z) + R * Math.cos($ * Z)) } } else if (A === 1) z = $ => d - Math.exp(-I * $) * (R + (b + I * R) * $); else { const $ = I * Math.sqrt(A * A - 1); z = Z => { const te = Math.exp(-A * I * Z), Q = Math.min($ * Z, 300); return d - te * ((b + A * I * R) * Math.sinh(Q) + $ * R * Math.cosh(Q)) / $ } } const Y = { calculatedDuration: N && x || null, next: $ => { const Z = z($); if (N) h.done = $ >= x; else { let te = $ === 0 ? b : 0; A < 1 && (te = $ === 0 ? zt(b) : _p(z, $, Z)); const Q = Math.abs(te) <= a, pe = Math.abs(d - Z) <= u; h.done = Q && pe } return h.value = h.done ? d : Z, h }, toString: () => { const $ = Math.min(hu(Y), eo), Z = Lp(te => Y.next($ * te).value, $, 30); return $ + "ms " + Z }, toTransition: () => { } }; return Y } to.applyToOptions = n => { const r = Y0(n, 100, to); return n.ease = r.ease, n.duration = zt(r.duration), n.type = "keyframes", n }; function Ml({ keyframes: n, velocity: r = 0, power: s = .8, timeConstant: a = 325, bounceDamping: u = 10, bounceStiffness: f = 500, modifyTarget: d, min: h, max: p, restDelta: v = .5, restSpeed: y }) { const x = n[0], S = { done: !1, value: x }, N = Q => h !== void 0 && Q < h || p !== void 0 && Q > p, b = Q => h === void 0 ? p : p === void 0 || Math.abs(h - Q) < Math.abs(p - Q) ? h : p; let A = s * r; const R = x + A, I = d === void 0 ? R : d(R); I !== R && (A = I - x); const B = Q => -A * Math.exp(-Q / a), z = Q => I + B(Q), Y = Q => { const pe = B(Q), ve = z(Q); S.done = Math.abs(pe) <= v, S.value = S.done ? I : ve }; let $, Z; const te = Q => { N(S.value) && ($ = Q, Z = to({ keyframes: [S.value, b(S.value)], velocity: _p(z, Q, S.value), damping: u, stiffness: f, restDelta: v, restSpeed: y })) }; return te(0), { calculatedDuration: null, next: Q => { let pe = !1; return !Z && $ === void 0 && (pe = !0, Y(Q), te(Q)), $ !== void 0 && Q >= $ ? Z.next(Q - $) : (!pe && Y(Q), S) } } } function rv(n, r, s) { const a = [], u = s || Xt.mix || Dp, f = n.length - 1; for (let d = 0; d < f; d++) { let h = u(n[d], n[d + 1]); if (r) { const p = Array.isArray(r) ? r[d] || Et : r; h = Ri(p, h) } a.push(h) } return a } function iv(n, r, { clamp: s = !0, ease: a, mixer: u } = {}) { const f = n.length; if (ru(f === r.length), f === 1) return () => r[0]; if (f === 2 && r[0] === r[1]) return () => r[1]; const d = n[0] === n[1]; n[0] > n[f - 1] && (n = [...n].reverse(), r = [...r].reverse()); const h = rv(r, a, u), p = h.length, v = y => { if (d && y < n[0]) return r[0]; let x = 0; if (p > 1) for (; x < n.length - 2 && !(y < n[x + 1]); x++); const S = Si(n[x], n[x + 1], y); return h[x](S) }; return s ? y => v(Yt(n[0], n[f - 1], y)) : v } function sv(n, r) { const s = n[n.length - 1]; for (let a = 1; a <= r; a++) { const u = Si(0, r, a); n.push(je(s, 1, u)) } } function ov(n) { const r = [0]; return sv(r, n.length - 1), r } function av(n, r) { return n.map(s => s * r) } function lv(n, r) { return n.map(() => r || kp).splice(0, n.length - 1) } function yi({ duration: n = 300, keyframes: r, times: s, ease: a = "easeInOut" }) { const u = x0(a) ? a.map(Of) : Of(a), f = { done: !1, value: r[0] }, d = av(s && s.length === r.length ? s : ov(r), n), h = iv(d, r, { ease: Array.isArray(u) ? u : lv(r, u) }); return { calculatedDuration: n, next: p => (f.value = h(p), f.done = p >= n, f) } } const uv = n => n !== null; function pu(n, { repeat: r, repeatType: s = "loop" }, a, u = 1) { const f = n.filter(uv), h = u < 0 || r && s !== "loop" && r % 2 === 1 ? 0 : f.length - 1; return !h || a === void 0 ? f[h] : a } const cv = { decay: Ml, inertia: Ml, tween: yi, keyframes: yi, spring: to }; function Vp(n) { typeof n.type == "string" && (n.type = cv[n.type]) } class mu { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(r => { this.resolve = r }) } notifyFinished() { this.resolve() } then(r, s) { return this.finished.then(r, s) } } const dv = n => n / 100; class gu extends mu { constructor(r) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { const { motionValue: s } = this.options; s && s.updatedAt !== lt.now() && this.tick(lt.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.()) }, this.options = r, this.initAnimation(), this.play(), r.autoplay === !1 && this.pause() } initAnimation() { const { options: r } = this; Vp(r); const { type: s = yi, repeat: a = 0, repeatDelay: u = 0, repeatType: f, velocity: d = 0 } = r; let { keyframes: h } = r; const p = s || yi; p !== yi && typeof h[0] != "number" && (this.mixKeyframes = Ri(dv, Dp(h[0], h[1])), h = [0, 100]); const v = p({ ...r, keyframes: h }); f === "mirror" && (this.mirroredGenerator = p({ ...r, keyframes: [...h].reverse(), velocity: -d })), v.calculatedDuration === null && (v.calculatedDuration = hu(v)); const { calculatedDuration: y } = v; this.calculatedDuration = y, this.resolvedDuration = y + u, this.totalDuration = this.resolvedDuration * (a + 1) - u, this.generator = v } updateTime(r) { const s = Math.round(r - this.startTime) * this.playbackSpeed; this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = s } tick(r, s = !1) { const { generator: a, totalDuration: u, mixKeyframes: f, mirroredGenerator: d, resolvedDuration: h, calculatedDuration: p } = this; if (this.startTime === null) return a.next(0); const { delay: v = 0, keyframes: y, repeat: x, repeatType: S, repeatDelay: N, type: b, onUpdate: A, finalKeyframe: R } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, r) : this.speed < 0 && (this.startTime = Math.min(r - u / this.speed, this.startTime)), s ? this.currentTime = r : this.updateTime(r); const I = this.currentTime - v * (this.playbackSpeed >= 0 ? 1 : -1), B = this.playbackSpeed >= 0 ? I < 0 : I > u; this.currentTime = Math.max(I, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = u); let z = this.currentTime, Y = a; if (x) { const Q = Math.min(this.currentTime, u) / h; let pe = Math.floor(Q), ve = Q % 1; !ve && Q >= 1 && (ve = 1), ve === 1 && pe--, pe = Math.min(pe, x + 1), !!(pe % 2) && (S === "reverse" ? (ve = 1 - ve, N && (ve -= N / h)) : S === "mirror" && (Y = d)), z = Yt(0, 1, ve) * h } const $ = B ? { done: !1, value: y[0] } : Y.next(z); f && ($.value = f($.value)); let { done: Z } = $; !B && p !== null && (Z = this.playbackSpeed >= 0 ? this.currentTime >= u : this.currentTime <= 0); const te = this.holdTime === null && (this.state === "finished" || this.state === "running" && Z); return te && b !== Ml && ($.value = pu(y, this.options, R, this.speed)), A && A($.value), te && this.finish(), $ } then(r, s) { return this.finished.then(r, s) } get duration() { return Pt(this.calculatedDuration) } get iterationDuration() { const { delay: r = 0 } = this.options || {}; return this.duration + Pt(r) } get time() { return Pt(this.currentTime) } set time(r) { r = zt(r), this.currentTime = r, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = r : this.driver && (this.startTime = this.driver.now() - r / this.playbackSpeed), this.driver?.start(!1) } get speed() { return this.playbackSpeed } set speed(r) { this.updateTime(lt.now()); const s = this.playbackSpeed !== r; this.playbackSpeed = r, s && (this.time = Pt(this.currentTime)) } play() { if (this.isStopped) return; const { driver: r = q0, startTime: s } = this.options; this.driver || (this.driver = r(u => this.tick(u))), this.options.onPlay?.(); const a = this.driver.now(); this.state === "finished" ? (this.updateFinished(), this.startTime = a) : this.holdTime !== null ? this.startTime = a - this.holdTime : this.startTime || (this.startTime = s ?? a), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(lt.now()), this.holdTime = this.currentTime } complete() { this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null } finish() { this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.() } cancel() { this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.() } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(r) { return this.startTime = 0, this.tick(r, !0) } attachTimeline(r) { return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), r.observe(this) } } function fv(n) { for (let r = 1; r < n.length; r++)n[r] ?? (n[r] = n[r - 1]) } const On = n => n * 180 / Math.PI, Rl = n => { const r = On(Math.atan2(n[1], n[0])); return Al(r) }, hv = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: n => (Math.abs(n[0]) + Math.abs(n[3])) / 2, rotate: Rl, rotateZ: Rl, skewX: n => On(Math.atan(n[1])), skewY: n => On(Math.atan(n[2])), skew: n => (Math.abs(n[1]) + Math.abs(n[2])) / 2 }, Al = n => (n = n % 360, n < 0 && (n += 360), n), Wf = Rl, $f = n => Math.sqrt(n[0] * n[0] + n[1] * n[1]), Kf = n => Math.sqrt(n[4] * n[4] + n[5] * n[5]), pv = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: $f, scaleY: Kf, scale: n => ($f(n) + Kf(n)) / 2, rotateX: n => Al(On(Math.atan2(n[6], n[5]))), rotateY: n => Al(On(Math.atan2(-n[2], n[0]))), rotateZ: Wf, rotate: Wf, skewX: n => On(Math.atan(n[4])), skewY: n => On(Math.atan(n[1])), skew: n => (Math.abs(n[1]) + Math.abs(n[4])) / 2 }; function bl(n) { return n.includes("scale") ? 1 : 0 } function Dl(n, r) { if (!n || n === "none") return bl(r); const s = n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); let a, u; if (s) a = pv, u = s; else { const h = n.match(/^matrix\(([-\d.e\s,]+)\)$/u); a = hv, u = h } if (!u) return bl(r); const f = a[r], d = u[1].split(",").map(gv); return typeof f == "function" ? f(d) : d[f] } const mv = (n, r) => { const { transform: s = "none" } = getComputedStyle(n); return Dl(s, r) }; function gv(n) { return parseFloat(n.trim()) } const kr = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Pr = new Set(kr), Gf = n => n === Cr || n === ne, yv = new Set(["x", "y", "z"]), vv = kr.filter(n => !yv.has(n)); function xv(n) { const r = []; return vv.forEach(s => { const a = n.getValue(s); a !== void 0 && (r.push([s, a.get()]), a.set(s.startsWith("scale") ? 1 : 0)) }), r } const zn = { width: ({ x: n }, { paddingLeft: r = "0", paddingRight: s = "0" }) => n.max - n.min - parseFloat(r) - parseFloat(s), height: ({ y: n }, { paddingTop: r = "0", paddingBottom: s = "0" }) => n.max - n.min - parseFloat(r) - parseFloat(s), top: (n, { top: r }) => parseFloat(r), left: (n, { left: r }) => parseFloat(r), bottom: ({ y: n }, { top: r }) => parseFloat(r) + (n.max - n.min), right: ({ x: n }, { left: r }) => parseFloat(r) + (n.max - n.min), x: (n, { transform: r }) => Dl(r, "x"), y: (n, { transform: r }) => Dl(r, "y") }; zn.translateX = zn.x; zn.translateY = zn.y; const Fn = new Set; let Ll = !1, _l = !1, Vl = !1; function Ip() { if (_l) { const n = Array.from(Fn).filter(a => a.needsMeasurement), r = new Set(n.map(a => a.element)), s = new Map; r.forEach(a => { const u = xv(a); u.length && (s.set(a, u), a.render()) }), n.forEach(a => a.measureInitialState()), r.forEach(a => { a.render(); const u = s.get(a); u && u.forEach(([f, d]) => { a.getValue(f)?.set(d) }) }), n.forEach(a => a.measureEndState()), n.forEach(a => { a.suspendedScrollY !== void 0 && window.scrollTo(0, a.suspendedScrollY) }) } _l = !1, Ll = !1, Fn.forEach(n => n.complete(Vl)), Fn.clear() } function Op() { Fn.forEach(n => { n.readKeyframes(), n.needsMeasurement && (_l = !0) }) } function wv() { Vl = !0, Op(), Ip(), Vl = !1 } class yu { constructor(r, s, a, u, f, d = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...r], this.onComplete = s, this.name = a, this.motionValue = u, this.element = f, this.isAsync = d } scheduleResolve() { this.state = "scheduled", this.isAsync ? (Fn.add(this), Ll || (Ll = !0, ke.read(Op), ke.resolveKeyframes(Ip))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: r, name: s, element: a, motionValue: u } = this; if (r[0] === null) { const f = u?.get(), d = r[r.length - 1]; if (f !== void 0) r[0] = f; else if (a && s) { const h = a.readValue(s, d); h != null && (r[0] = h) } r[0] === void 0 && (r[0] = d), u && f === void 0 && u.set(r[0]) } fv(r) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(r = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, r), Fn.delete(this) } cancel() { this.state === "scheduled" && (Fn.delete(this), this.state = "pending") } resume() { this.state === "pending" && this.scheduleResolve() } } const Sv = n => n.startsWith("--"); function Cv(n, r, s) { Sv(r) ? n.style.setProperty(r, s) : n.style[r] = s } const kv = iu(() => window.ScrollTimeline !== void 0), Pv = {}; function Ev(n, r) { const s = iu(n); return () => Pv[r] ?? s() } const zp = Ev(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), pi = ([n, r, s, a]) => `cubic-bezier(${n}, ${r}, ${s}, ${a})`, qf = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: pi([0, .65, .55, 1]), circOut: pi([.55, 0, 1, .45]), backIn: pi([.31, .01, .66, -.59]), backOut: pi([.33, 1.53, .69, .99]) }; function Fp(n, r) { if (n) return typeof n == "function" ? zp() ? Lp(n, r) : "ease-out" : Pp(n) ? pi(n) : Array.isArray(n) ? n.map(s => Fp(s, r) || qf.easeOut) : qf[n] } function jv(n, r, s, { delay: a = 0, duration: u = 300, repeat: f = 0, repeatType: d = "loop", ease: h = "easeOut", times: p } = {}, v = void 0) { const y = { [r]: s }; p && (y.offset = p); const x = Fp(h, u); Array.isArray(x) && (y.easing = x); const S = { delay: a, duration: u, easing: Array.isArray(x) ? "linear" : x, fill: "both", iterations: f + 1, direction: d === "reverse" ? "alternate" : "normal" }; return v && (S.pseudoElement = v), n.animate(y, S) } function Bp(n) { return typeof n == "function" && "applyToOptions" in n } function Tv({ type: n, ...r }) { return Bp(n) && zp() ? n.applyToOptions(r) : (r.duration ?? (r.duration = 300), r.ease ?? (r.ease = "easeOut"), r) } class Nv extends mu { constructor(r) { if (super(), this.finishedTime = null, this.isStopped = !1, !r) return; const { element: s, name: a, keyframes: u, pseudoElement: f, allowFlatten: d = !1, finalKeyframe: h, onComplete: p } = r; this.isPseudoElement = !!f, this.allowFlatten = d, this.options = r, ru(typeof r.type != "string"); const v = Tv(r); this.animation = jv(s, a, u, v, f), v.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !f) { const y = pu(u, this.options, h, this.speed); this.updateMotionValue ? this.updateMotionValue(y) : Cv(s, a, y), this.animation.cancel() } p?.(), this.notifyFinished() } } play() { this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished()) } pause() { this.animation.pause() } complete() { this.animation.finish?.() } cancel() { try { this.animation.cancel() } catch { } } stop() { if (this.isStopped) return; this.isStopped = !0; const { state: r } = this; r === "idle" || r === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { this.isPseudoElement || this.animation.commitStyles?.() } get duration() { const r = this.animation.effect?.getComputedTiming?.().duration || 0; return Pt(Number(r)) } get iterationDuration() { const { delay: r = 0 } = this.options || {}; return this.duration + Pt(r) } get time() { return Pt(Number(this.animation.currentTime) || 0) } set time(r) { this.finishedTime = null, this.animation.currentTime = zt(r) } get speed() { return this.animation.playbackRate } set speed(r) { r < 0 && (this.finishedTime = null), this.animation.playbackRate = r } get state() { return this.finishedTime !== null ? "finished" : this.animation.playState } get startTime() { return Number(this.animation.startTime) } set startTime(r) { this.animation.startTime = r } attachTimeline({ timeline: r, observe: s }) { return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, r && kv() ? (this.animation.timeline = r, Et) : s(this) } } const Up = { anticipate: wp, backInOut: xp, circInOut: Cp }; function Mv(n) { return n in Up } function Rv(n) { typeof n.ease == "string" && Mv(n.ease) && (n.ease = Up[n.ease]) } const Yf = 10; class Av extends Nv { constructor(r) { Rv(r), Vp(r), super(r), r.startTime && (this.startTime = r.startTime), this.options = r } updateMotionValue(r) { const { motionValue: s, onUpdate: a, onComplete: u, element: f, ...d } = this.options; if (!s) return; if (r !== void 0) { s.set(r); return } const h = new gu({ ...d, autoplay: !1 }), p = zt(this.finishedTime ?? this.time); s.setWithVelocity(h.sample(p - Yf).value, h.sample(p).value, Yf), h.stop() } } const Xf = (n, r) => r === "zIndex" ? !1 : !!(typeof n == "number" || Array.isArray(n) || typeof n == "string" && (wn.test(n) || n === "0") && !n.startsWith("url(")); function bv(n) { const r = n[0]; if (n.length === 1) return !0; for (let s = 0; s < n.length; s++)if (n[s] !== r) return !0 } function Dv(n, r, s, a) { const u = n[0]; if (u === null) return !1; if (r === "display" || r === "visibility") return !0; const f = n[n.length - 1], d = Xf(u, r), h = Xf(f, r); return !d || !h ? !1 : bv(n) || (s === "spring" || Bp(s)) && a } function Il(n) { n.duration = 0, n.type = "keyframes" } const Lv = new Set(["opacity", "clipPath", "filter", "transform"]), _v = iu(() => Object.hasOwnProperty.call(Element.prototype, "animate")); function Vv(n) { const { motionValue: r, name: s, repeatDelay: a, repeatType: u, damping: f, type: d } = n; if (!(r?.owner?.current instanceof HTMLElement)) return !1; const { onUpdate: p, transformTemplate: v } = r.owner.getProps(); return _v() && s && Lv.has(s) && (s !== "transform" || !v) && !p && !a && u !== "mirror" && f !== 0 && d !== "inertia" } const Iv = 40; class Ov extends mu { constructor({ autoplay: r = !0, delay: s = 0, type: a = "keyframes", repeat: u = 0, repeatDelay: f = 0, repeatType: d = "loop", keyframes: h, name: p, motionValue: v, element: y, ...x }) { super(), this.stop = () => { this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel() }, this.createdAt = lt.now(); const S = { autoplay: r, delay: s, type: a, repeat: u, repeatDelay: f, repeatType: d, name: p, motionValue: v, element: y, ...x }, N = y?.KeyframeResolver || yu; this.keyframeResolver = new N(h, (b, A, R) => this.onKeyframesResolved(b, A, S, !R), p, v, y), this.keyframeResolver?.scheduleResolve() } onKeyframesResolved(r, s, a, u) { this.keyframeResolver = void 0; const { name: f, type: d, velocity: h, delay: p, isHandoff: v, onUpdate: y } = a; this.resolvedAt = lt.now(), Dv(r, f, d, h) || ((Xt.instantAnimations || !p) && y?.(pu(r, a, s)), r[0] = r[r.length - 1], Il(a), a.repeat = 0); const S = { startTime: u ? this.resolvedAt ? this.resolvedAt - this.createdAt > Iv ? this.resolvedAt : this.createdAt : this.createdAt : void 0, finalKeyframe: s, ...a, keyframes: r }, N = !v && Vv(S) ? new Av({ ...S, element: S.motionValue.owner.current }) : new gu(S); N.finished.then(() => this.notifyFinished()).catch(Et), this.pendingTimeline && (this.stopTimeline = N.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = N } get finished() { return this._animation ? this.animation.finished : this._finished } then(r, s) { return this.finished.finally(r).then(() => { }) } get animation() { return this._animation || (this.keyframeResolver?.resume(), wv()), this._animation } get duration() { return this.animation.duration } get iterationDuration() { return this.animation.iterationDuration } get time() { return this.animation.time } set time(r) { this.animation.time = r } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(r) { this.animation.speed = r } get startTime() { return this.animation.startTime } attachTimeline(r) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(r) : this.pendingTimeline = r, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { this._animation && this.animation.cancel(), this.keyframeResolver?.cancel() } } const zv = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function Fv(n) { const r = zv.exec(n); if (!r) return [,]; const [, s, a, u] = r; return [`--${s ?? a}`, u] } function Hp(n, r, s = 1) { const [a, u] = Fv(n); if (!a) return; const f = window.getComputedStyle(r).getPropertyValue(a); if (f) { const d = f.trim(); return dp(d) ? parseFloat(d) : d } return uu(u) ? Hp(u, r, s + 1) : u } function vu(n, r) { return n?.[r] ?? n?.default ?? n } const Wp = new Set(["width", "height", "top", "left", "right", "bottom", ...kr]), Bv = { test: n => n === "auto", parse: n => n }, $p = n => r => r.test(n), Kp = [Cr, ne, Ft, yn, b0, A0, Bv], Qf = n => Kp.find($p(n)); function Uv(n) { return typeof n == "number" ? n === 0 : n !== null ? n === "none" || n === "0" || hp(n) : !0 } const Hv = new Set(["brightness", "contrast", "saturate", "opacity"]); function Wv(n) { const [r, s] = n.slice(0, -1).split("("); if (r === "drop-shadow") return n; const [a] = s.match(cu) || []; if (!a) return n; const u = s.replace(a, ""); let f = Hv.has(r) ? 1 : 0; return a !== s && (f *= 100), r + "(" + f + u + ")" } const $v = /\b([a-z-]*)\(.*?\)/gu, Ol = { ...wn, getAnimatableNone: n => { const r = n.match($v); return r ? r.map(Wv).join(" ") : n } }, Zf = { ...Cr, transform: Math.round }, Kv = { rotate: yn, rotateX: yn, rotateY: yn, rotateZ: yn, scale: Ks, scaleX: Ks, scaleY: Ks, scaleZ: Ks, skew: yn, skewX: yn, skewY: yn, distance: ne, translateX: ne, translateY: ne, translateZ: ne, x: ne, y: ne, z: ne, perspective: ne, transformPerspective: ne, opacity: Ci, originX: zf, originY: zf, originZ: ne }, xu = { borderWidth: ne, borderTopWidth: ne, borderRightWidth: ne, borderBottomWidth: ne, borderLeftWidth: ne, borderRadius: ne, radius: ne, borderTopLeftRadius: ne, borderTopRightRadius: ne, borderBottomRightRadius: ne, borderBottomLeftRadius: ne, width: ne, maxWidth: ne, height: ne, maxHeight: ne, top: ne, right: ne, bottom: ne, left: ne, padding: ne, paddingTop: ne, paddingRight: ne, paddingBottom: ne, paddingLeft: ne, margin: ne, marginTop: ne, marginRight: ne, marginBottom: ne, marginLeft: ne, backgroundPositionX: ne, backgroundPositionY: ne, ...Kv, zIndex: Zf, fillOpacity: Ci, strokeOpacity: Ci, numOctaves: Zf }, Gv = { ...xu, color: De, backgroundColor: De, outlineColor: De, fill: De, stroke: De, borderColor: De, borderTopColor: De, borderRightColor: De, borderBottomColor: De, borderLeftColor: De, filter: Ol, WebkitFilter: Ol }, Gp = n => Gv[n]; function qp(n, r) { let s = Gp(n); return s !== Ol && (s = wn), s.getAnimatableNone ? s.getAnimatableNone(r) : void 0 } const qv = new Set(["auto", "none", "0"]); function Yv(n, r, s) { let a = 0, u; for (; a < n.length && !u;) { const f = n[a]; typeof f == "string" && !qv.has(f) && ki(f).values.length && (u = n[a]), a++ } if (u && s) for (const f of r) n[f] = qp(s, u) } class Xv extends yu { constructor(r, s, a, u, f) { super(r, s, a, u, f, !0) } readKeyframes() { const { unresolvedKeyframes: r, element: s, name: a } = this; if (!s || !s.current) return; super.readKeyframes(); for (let p = 0; p < r.length; p++) { let v = r[p]; if (typeof v == "string" && (v = v.trim(), uu(v))) { const y = Hp(v, s.current); y !== void 0 && (r[p] = y), p === r.length - 1 && (this.finalKeyframe = v) } } if (this.resolveNoneKeyframes(), !Wp.has(a) || r.length !== 2) return; const [u, f] = r, d = Qf(u), h = Qf(f); if (d !== h) if (Gf(d) && Gf(h)) for (let p = 0; p < r.length; p++) { const v = r[p]; typeof v == "string" && (r[p] = parseFloat(v)) } else zn[a] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { const { unresolvedKeyframes: r, name: s } = this, a = []; for (let u = 0; u < r.length; u++)(r[u] === null || Uv(r[u])) && a.push(u); a.length && Yv(r, a, s) } measureInitialState() { const { element: r, unresolvedKeyframes: s, name: a } = this; if (!r || !r.current) return; a === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = zn[a](r.measureViewportBox(), window.getComputedStyle(r.current)), s[0] = this.measuredOrigin; const u = s[s.length - 1]; u !== void 0 && r.getValue(a, u).jump(u, !1) } measureEndState() { const { element: r, name: s, unresolvedKeyframes: a } = this; if (!r || !r.current) return; const u = r.getValue(s); u && u.jump(this.measuredOrigin, !1); const f = a.length - 1, d = a[f]; a[f] = zn[s](r.measureViewportBox(), window.getComputedStyle(r.current)), d !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = d), this.removedTransforms?.length && this.removedTransforms.forEach(([h, p]) => { r.getValue(h).set(p) }), this.resolveNoneKeyframes() } } function Qv(n, r, s) { if (n instanceof EventTarget) return [n]; if (typeof n == "string") { let a = document; const u = s?.[n] ?? a.querySelectorAll(n); return u ? Array.from(u) : [] } return Array.from(n) } const Yp = (n, r) => r && typeof n == "number" ? r.transform(n) : n; function Xp(n) { return fp(n) && "offsetHeight" in n } const Jf = 30, Zv = n => !isNaN(parseFloat(n)); class Jv { constructor(r, s = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = a => { const u = lt.now(); if (this.updatedAt !== u && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(a), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents)) for (const f of this.dependents) f.dirty() }, this.hasAnimated = !1, this.setCurrent(r), this.owner = s.owner } setCurrent(r) { this.current = r, this.updatedAt = lt.now(), this.canTrackVelocity === null && r !== void 0 && (this.canTrackVelocity = Zv(this.current)) } setPrevFrameValue(r = this.current) { this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt } onChange(r) { return this.on("change", r) } on(r, s) { this.events[r] || (this.events[r] = new su); const a = this.events[r].add(s); return r === "change" ? () => { a(), ke.read(() => { this.events.change.getSize() || this.stop() }) } : a } clearListeners() { for (const r in this.events) this.events[r].clear() } attach(r, s) { this.passiveEffect = r, this.stopPassiveEffect = s } set(r) { this.passiveEffect ? this.passiveEffect(r, this.updateAndNotify) : this.updateAndNotify(r) } setWithVelocity(r, s, a) { this.set(s), this.prev = void 0, this.prevFrameValue = r, this.prevUpdatedAt = this.updatedAt - a } jump(r, s = !0) { this.updateAndNotify(r), this.prev = r, this.prevUpdatedAt = this.prevFrameValue = void 0, s && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { this.events.change?.notify(this.current) } addDependent(r) { this.dependents || (this.dependents = new Set), this.dependents.add(r) } removeDependent(r) { this.dependents && this.dependents.delete(r) } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const r = lt.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || r - this.updatedAt > Jf) return 0; const s = Math.min(this.updatedAt - this.prevUpdatedAt, Jf); return pp(parseFloat(this.current) - parseFloat(this.prevFrameValue), s) } start(r) { return this.stop(), new Promise(s => { this.hasAnimated = !0, this.animation = r(s), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function wr(n, r) { return new Jv(n, r) } const { schedule: wu } = Ep(queueMicrotask, !1), Dt = { x: !1, y: !1 }; function Qp() { return Dt.x || Dt.y } function ex(n) { return n === "x" || n === "y" ? Dt[n] ? null : (Dt[n] = !0, () => { Dt[n] = !1 }) : Dt.x || Dt.y ? null : (Dt.x = Dt.y = !0, () => { Dt.x = Dt.y = !1 }) } function Zp(n, r) { const s = Qv(n), a = new AbortController, u = { passive: !0, ...r, signal: a.signal }; return [s, u, () => a.abort()] } function eh(n) { return !(n.pointerType === "touch" || Qp()) } function tx(n, r, s = {}) { const [a, u, f] = Zp(n, s), d = h => { if (!eh(h)) return; const { target: p } = h, v = r(p, h); if (typeof v != "function" || !p) return; const y = x => { eh(x) && (v(x), p.removeEventListener("pointerleave", y)) }; p.addEventListener("pointerleave", y, u) }; return a.forEach(h => { h.addEventListener("pointerenter", d, u) }), f } const Jp = (n, r) => r ? n === r ? !0 : Jp(n, r.parentElement) : !1, Su = n => n.pointerType === "mouse" ? typeof n.button != "number" || n.button <= 0 : n.isPrimary !== !1, nx = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function rx(n) { return nx.has(n.tagName) || n.tabIndex !== -1 } const Xs = new WeakSet; function th(n) { return r => { r.key === "Enter" && n(r) } } function ml(n, r) { n.dispatchEvent(new PointerEvent("pointer" + r, { isPrimary: !0, bubbles: !0 })) } const ix = (n, r) => { const s = n.currentTarget; if (!s) return; const a = th(() => { if (Xs.has(s)) return; ml(s, "down"); const u = th(() => { ml(s, "up") }), f = () => ml(s, "cancel"); s.addEventListener("keyup", u, r), s.addEventListener("blur", f, r) }); s.addEventListener("keydown", a, r), s.addEventListener("blur", () => s.removeEventListener("keydown", a), r) }; function nh(n) { return Su(n) && !Qp() } function sx(n, r, s = {}) { const [a, u, f] = Zp(n, s), d = h => { const p = h.currentTarget; if (!nh(h)) return; Xs.add(p); const v = r(p, h), y = (N, b) => { window.removeEventListener("pointerup", x), window.removeEventListener("pointercancel", S), Xs.has(p) && Xs.delete(p), nh(N) && typeof v == "function" && v(N, { success: b }) }, x = N => { y(N, p === window || p === document || s.useGlobalTarget || Jp(p, N.target)) }, S = N => { y(N, !1) }; window.addEventListener("pointerup", x, u), window.addEventListener("pointercancel", S, u) }; return a.forEach(h => { (s.useGlobalTarget ? window : h).addEventListener("pointerdown", d, u), Xp(h) && (h.addEventListener("focus", v => ix(v, u)), !rx(h) && !h.hasAttribute("tabindex") && (h.tabIndex = 0)) }), f } function em(n) { return fp(n) && "ownerSVGElement" in n } function ox(n) { return em(n) && n.tagName === "svg" } const qe = n => !!(n && n.getVelocity), ax = [...Kp, De, wn], lx = n => ax.find($p(n)), Cu = M.createContext({ transformPagePoint: n => n, isStatic: !1, reducedMotion: "never" }); function rh(n, r) { if (typeof n == "function") return n(r); n != null && (n.current = r) } function ux(...n) { return r => { let s = !1; const a = n.map(u => { const f = rh(u, r); return !s && typeof f == "function" && (s = !0), f }); if (s) return () => { for (let u = 0; u < a.length; u++) { const f = a[u]; typeof f == "function" ? f() : rh(n[u], null) } } } } function cx(...n) { return M.useCallback(ux(...n), n) } class dx extends M.Component { getSnapshotBeforeUpdate(r) { const s = this.props.childRef.current; if (s && r.isPresent && !this.props.isPresent) { const a = s.offsetParent, u = Xp(a) && a.offsetWidth || 0, f = this.props.sizeRef.current; f.height = s.offsetHeight || 0, f.width = s.offsetWidth || 0, f.top = s.offsetTop, f.left = s.offsetLeft, f.right = u - f.width - f.left } return null } componentDidUpdate() { } render() { return this.props.children } } function fx({ children: n, isPresent: r, anchorX: s, root: a }) {
  const u = M.useId(), f = M.useRef(null), d = M.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0 }), { nonce: h } = M.useContext(Cu), p = cx(f, n?.ref); return M.useInsertionEffect(() => {
    const { width: v, height: y, top: x, left: S, right: N } = d.current; if (r || !f.current || !v || !y) return; const b = s === "left" ? `left: ${S}` : `right: ${N}`; f.current.dataset.motionPopId = u; const A = document.createElement("style"); h && (A.nonce = h); const R = a ?? document.head; return R.appendChild(A), A.sheet && A.sheet.insertRule(`
          [data-motion-pop-id="${u}"] {
            position: absolute !important;
            width: ${v}px !important;
            height: ${y}px !important;
            ${b}px !important;
            top: ${x}px !important;
          }
        `), () => { R.contains(A) && R.removeChild(A) }
  }, [r]), g.jsx(dx, { isPresent: r, childRef: f, sizeRef: d, children: M.cloneElement(n, { ref: p }) })
} const hx = ({ children: n, initial: r, isPresent: s, onExitComplete: a, custom: u, presenceAffectsLayout: f, mode: d, anchorX: h, root: p }) => { const v = Jl(px), y = M.useId(); let x = !0, S = M.useMemo(() => (x = !1, { id: y, initial: r, isPresent: s, custom: u, onExitComplete: N => { v.set(N, !0); for (const b of v.values()) if (!b) return; a && a() }, register: N => (v.set(N, !1), () => v.delete(N)) }), [s, v, a]); return f && x && (S = { ...S }), M.useMemo(() => { v.forEach((N, b) => v.set(b, !1)) }, [s]), M.useEffect(() => { !s && !v.size && a && a() }, [s]), d === "popLayout" && (n = g.jsx(fx, { isPresent: s, anchorX: h, root: p, children: n })), g.jsx(io.Provider, { value: S, children: n }) }; function px() { return new Map } function tm(n = !0) { const r = M.useContext(io); if (r === null) return [!0, null]; const { isPresent: s, onExitComplete: a, register: u } = r, f = M.useId(); M.useEffect(() => { if (n) return u(f) }, [n]); const d = M.useCallback(() => n && a && a(f), [f, a, n]); return !s && a ? [!1, d] : [!0] } const Gs = n => n.key || ""; function ih(n) { const r = []; return M.Children.forEach(n, s => { M.isValidElement(s) && r.push(s) }), r } const nm = ({ children: n, custom: r, initial: s = !0, onExitComplete: a, presenceAffectsLayout: u = !0, mode: f = "sync", propagate: d = !1, anchorX: h = "left", root: p }) => { const [v, y] = tm(d), x = M.useMemo(() => ih(n), [n]), S = d && !v ? [] : x.map(Gs), N = M.useRef(!0), b = M.useRef(x), A = Jl(() => new Map), [R, I] = M.useState(x), [B, z] = M.useState(x); cp(() => { N.current = !1, b.current = x; for (let Z = 0; Z < B.length; Z++) { const te = Gs(B[Z]); S.includes(te) ? A.delete(te) : A.get(te) !== !0 && A.set(te, !1) } }, [B, S.length, S.join("-")]); const Y = []; if (x !== R) { let Z = [...x]; for (let te = 0; te < B.length; te++) { const Q = B[te], pe = Gs(Q); S.includes(pe) || (Z.splice(te, 0, Q), Y.push(Q)) } return f === "wait" && Y.length && (Z = Y), z(ih(Z)), I(x), null } const { forceRender: $ } = M.useContext(Zl); return g.jsx(g.Fragment, { children: B.map(Z => { const te = Gs(Z), Q = d && !v ? !1 : x === B || S.includes(te), pe = () => { if (A.has(te)) A.set(te, !0); else return; let ve = !0; A.forEach(He => { He || (ve = !1) }), ve && ($?.(), z(b.current), d && y?.(), a && a()) }; return g.jsx(hx, { isPresent: Q, initial: !N.current || s ? void 0 : !1, custom: r, presenceAffectsLayout: u, mode: f, root: p, onExitComplete: Q ? void 0 : pe, anchorX: h, children: Z }, te) }) }) }, rm = M.createContext({ strict: !1 }), sh = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, Sr = {}; for (const n in sh) Sr[n] = { isEnabled: r => sh[n].some(s => !!r[s]) }; function mx(n) { for (const r in n) Sr[r] = { ...Sr[r], ...n[r] } } const gx = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function no(n) { return n.startsWith("while") || n.startsWith("drag") && n !== "draggable" || n.startsWith("layout") || n.startsWith("onTap") || n.startsWith("onPan") || n.startsWith("onLayout") || gx.has(n) } let im = n => !no(n); function yx(n) { typeof n == "function" && (im = r => r.startsWith("on") ? !no(r) : n(r)) } try { yx(require("@emotion/is-prop-valid").default) } catch { } function vx(n, r, s) { const a = {}; for (const u in n) u === "values" && typeof n.values == "object" || (im(u) || s === !0 && no(u) || !r && !no(u) || n.draggable && u.startsWith("onDrag")) && (a[u] = n[u]); return a } const so = M.createContext({}); function oo(n) { return n !== null && typeof n == "object" && typeof n.start == "function" } function Pi(n) { return typeof n == "string" || Array.isArray(n) } const ku = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], Pu = ["initial", ...ku]; function ao(n) { return oo(n.animate) || Pu.some(r => Pi(n[r])) } function sm(n) { return !!(ao(n) || n.variants) } function xx(n, r) { if (ao(n)) { const { initial: s, animate: a } = n; return { initial: s === !1 || Pi(s) ? s : void 0, animate: Pi(a) ? a : void 0 } } return n.inherit !== !1 ? r : {} } function wx(n) { const { initial: r, animate: s } = xx(n, M.useContext(so)); return M.useMemo(() => ({ initial: r, animate: s }), [oh(r), oh(s)]) } function oh(n) { return Array.isArray(n) ? n.join(" ") : n } const Ei = {}; function Sx(n) { for (const r in n) Ei[r] = n[r], lu(r) && (Ei[r].isCSSVariable = !0) } function om(n, { layout: r, layoutId: s }) { return Pr.has(n) || n.startsWith("origin") || (r || s !== void 0) && (!!Ei[n] || n === "opacity") } const Cx = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, kx = kr.length; function Px(n, r, s) { let a = "", u = !0; for (let f = 0; f < kx; f++) { const d = kr[f], h = n[d]; if (h === void 0) continue; let p = !0; if (typeof h == "number" ? p = h === (d.startsWith("scale") ? 1 : 0) : p = parseFloat(h) === 0, !p || s) { const v = Yp(h, xu[d]); if (!p) { u = !1; const y = Cx[d] || d; a += `${y}(${v}) ` } s && (r[d] = v) } } return a = a.trim(), s ? a = s(r, u ? "" : a) : u && (a = "none"), a } function Eu(n, r, s) { const { style: a, vars: u, transformOrigin: f } = n; let d = !1, h = !1; for (const p in r) { const v = r[p]; if (Pr.has(p)) { d = !0; continue } else if (lu(p)) { u[p] = v; continue } else { const y = Yp(v, xu[p]); p.startsWith("origin") ? (h = !0, f[p] = y) : a[p] = y } } if (r.transform || (d || s ? a.transform = Px(r, n.transform, s) : a.transform && (a.transform = "none")), h) { const { originX: p = "50%", originY: v = "50%", originZ: y = 0 } = f; a.transformOrigin = `${p} ${v} ${y}` } } const ju = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function am(n, r, s) { for (const a in r) !qe(r[a]) && !om(a, s) && (n[a] = r[a]) } function Ex({ transformTemplate: n }, r) { return M.useMemo(() => { const s = ju(); return Eu(s, r, n), Object.assign({}, s.vars, s.style) }, [r]) } function jx(n, r) { const s = n.style || {}, a = {}; return am(a, s, n), Object.assign(a, Ex(n, r)), a } function Tx(n, r) { const s = {}, a = jx(n, r); return n.drag && n.dragListener !== !1 && (s.draggable = !1, a.userSelect = a.WebkitUserSelect = a.WebkitTouchCallout = "none", a.touchAction = n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`), n.tabIndex === void 0 && (n.onTap || n.onTapStart || n.whileTap) && (s.tabIndex = 0), s.style = a, s } const Nx = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, Mx = { offset: "strokeDashoffset", array: "strokeDasharray" }; function Rx(n, r, s = 1, a = 0, u = !0) { n.pathLength = 1; const f = u ? Nx : Mx; n[f.offset] = ne.transform(-a); const d = ne.transform(r), h = ne.transform(s); n[f.array] = `${d} ${h}` } function lm(n, { attrX: r, attrY: s, attrScale: a, pathLength: u, pathSpacing: f = 1, pathOffset: d = 0, ...h }, p, v, y) { if (Eu(n, h, v), p) { n.style.viewBox && (n.attrs.viewBox = n.style.viewBox); return } n.attrs = n.style, n.style = {}; const { attrs: x, style: S } = n; x.transform && (S.transform = x.transform, delete x.transform), (S.transform || x.transformOrigin) && (S.transformOrigin = x.transformOrigin ?? "50% 50%", delete x.transformOrigin), S.transform && (S.transformBox = y?.transformBox ?? "fill-box", delete x.transformBox), r !== void 0 && (x.x = r), s !== void 0 && (x.y = s), a !== void 0 && (x.scale = a), u !== void 0 && Rx(x, u, f, d, !1) } const um = () => ({ ...ju(), attrs: {} }), cm = n => typeof n == "string" && n.toLowerCase() === "svg"; function Ax(n, r, s, a) { const u = M.useMemo(() => { const f = um(); return lm(f, r, cm(a), n.transformTemplate, n.style), { ...f.attrs, style: { ...f.style } } }, [r]); if (n.style) { const f = {}; am(f, n.style, n), u.style = { ...f, ...u.style } } return u } const bx = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Tu(n) { return typeof n != "string" || n.includes("-") ? !1 : !!(bx.indexOf(n) > -1 || /[A-Z]/u.test(n)) } function Dx(n, r, s, { latestValues: a }, u, f = !1) { const h = (Tu(n) ? Ax : Tx)(r, a, u, n), p = vx(r, typeof n == "string", f), v = n !== M.Fragment ? { ...p, ...h, ref: s } : {}, { children: y } = r, x = M.useMemo(() => qe(y) ? y.get() : y, [y]); return M.createElement(n, { ...v, children: x }) } function ah(n) { const r = [{}, {}]; return n?.values.forEach((s, a) => { r[0][a] = s.get(), r[1][a] = s.getVelocity() }), r } function Nu(n, r, s, a) { if (typeof r == "function") { const [u, f] = ah(a); r = r(s !== void 0 ? s : n.custom, u, f) } if (typeof r == "string" && (r = n.variants && n.variants[r]), typeof r == "function") { const [u, f] = ah(a); r = r(s !== void 0 ? s : n.custom, u, f) } return r } function Qs(n) { return qe(n) ? n.get() : n } function Lx({ scrapeMotionValuesFromProps: n, createRenderState: r }, s, a, u) { return { latestValues: _x(s, a, u, n), renderState: r() } } function _x(n, r, s, a) { const u = {}, f = a(n, {}); for (const S in f) u[S] = Qs(f[S]); let { initial: d, animate: h } = n; const p = ao(n), v = sm(n); r && v && !p && n.inherit !== !1 && (d === void 0 && (d = r.initial), h === void 0 && (h = r.animate)); let y = s ? s.initial === !1 : !1; y = y || d === !1; const x = y ? h : d; if (x && typeof x != "boolean" && !oo(x)) { const S = Array.isArray(x) ? x : [x]; for (let N = 0; N < S.length; N++) { const b = Nu(n, S[N]); if (b) { const { transitionEnd: A, transition: R, ...I } = b; for (const B in I) { let z = I[B]; if (Array.isArray(z)) { const Y = y ? z.length - 1 : 0; z = z[Y] } z !== null && (u[B] = z) } for (const B in A) u[B] = A[B] } } } return u } const dm = n => (r, s) => { const a = M.useContext(so), u = M.useContext(io), f = () => Lx(n, r, a, u); return s ? f() : Jl(f) }; function Mu(n, r, s) { const { style: a } = n, u = {}; for (const f in a) (qe(a[f]) || r.style && qe(r.style[f]) || om(f, n) || s?.getValue(f)?.liveStyle !== void 0) && (u[f] = a[f]); return u } const Vx = dm({ scrapeMotionValuesFromProps: Mu, createRenderState: ju }); function fm(n, r, s) { const a = Mu(n, r, s); for (const u in n) if (qe(n[u]) || qe(r[u])) { const f = kr.indexOf(u) !== -1 ? "attr" + u.charAt(0).toUpperCase() + u.substring(1) : u; a[f] = n[u] } return a } const Ix = dm({ scrapeMotionValuesFromProps: fm, createRenderState: um }), Ox = Symbol.for("motionComponentSymbol"); function mr(n) { return n && typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current") } function zx(n, r, s) { return M.useCallback(a => { a && n.onMount && n.onMount(a), r && (a ? r.mount(a) : r.unmount()), s && (typeof s == "function" ? s(a) : mr(s) && (s.current = a)) }, [r]) } const Ru = n => n.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), Fx = "framerAppearId", hm = "data-" + Ru(Fx), pm = M.createContext({}); function Bx(n, r, s, a, u) { const { visualElement: f } = M.useContext(so), d = M.useContext(rm), h = M.useContext(io), p = M.useContext(Cu).reducedMotion, v = M.useRef(null); a = a || d.renderer, !v.current && a && (v.current = a(n, { visualState: r, parent: f, props: s, presenceContext: h, blockInitialAnimation: h ? h.initial === !1 : !1, reducedMotionConfig: p })); const y = v.current, x = M.useContext(pm); y && !y.projection && u && (y.type === "html" || y.type === "svg") && Ux(v.current, s, u, x); const S = M.useRef(!1); M.useInsertionEffect(() => { y && S.current && y.update(s, h) }); const N = s[hm], b = M.useRef(!!N && !window.MotionHandoffIsComplete?.(N) && window.MotionHasOptimisedAnimation?.(N)); return cp(() => { y && (S.current = !0, window.MotionIsMounted = !0, y.updateFeatures(), y.scheduleRenderMicrotask(), b.current && y.animationState && y.animationState.animateChanges()) }), M.useEffect(() => { y && (!b.current && y.animationState && y.animationState.animateChanges(), b.current && (queueMicrotask(() => { window.MotionHandoffMarkAsComplete?.(N) }), b.current = !1), y.enteringChildren = void 0) }), y } function Ux(n, r, s, a) { const { layoutId: u, layout: f, drag: d, dragConstraints: h, layoutScroll: p, layoutRoot: v, layoutCrossfade: y } = r; n.projection = new s(n.latestValues, r["data-framer-portal-id"] ? void 0 : mm(n.parent)), n.projection.setOptions({ layoutId: u, layout: f, alwaysMeasureLayout: !!d || h && mr(h), visualElement: n, animationType: typeof f == "string" ? f : "both", initialPromotionConfig: a, crossfade: y, layoutScroll: p, layoutRoot: v }) } function mm(n) { if (n) return n.options.allowProjection !== !1 ? n.projection : mm(n.parent) } function gl(n, { forwardMotionProps: r = !1 } = {}, s, a) { s && mx(s); const u = Tu(n) ? Ix : Vx; function f(h, p) { let v; const y = { ...M.useContext(Cu), ...h, layoutId: Hx(h) }, { isStatic: x } = y, S = wx(h), N = u(h, x); if (!x && eu) { Wx(); const b = $x(y); v = b.MeasureLayout, S.visualElement = Bx(n, N, y, a, b.ProjectionNode) } return g.jsxs(so.Provider, { value: S, children: [v && S.visualElement ? g.jsx(v, { visualElement: S.visualElement, ...y }) : null, Dx(n, h, zx(N, S.visualElement, p), N, x, r)] }) } f.displayName = `motion.${typeof n == "string" ? n : `create(${n.displayName ?? n.name ?? ""})`}`; const d = M.forwardRef(f); return d[Ox] = n, d } function Hx({ layoutId: n }) { const r = M.useContext(Zl).id; return r && n !== void 0 ? r + "-" + n : n } function Wx(n, r) { M.useContext(rm).strict } function $x(n) { const { drag: r, layout: s } = Sr; if (!r && !s) return {}; const a = { ...r, ...s }; return { MeasureLayout: r?.isEnabled(n) || s?.isEnabled(n) ? a.MeasureLayout : void 0, ProjectionNode: a.ProjectionNode } } function Kx(n, r) { if (typeof Proxy > "u") return gl; const s = new Map, a = (f, d) => gl(f, d, n, r), u = (f, d) => a(f, d); return new Proxy(u, { get: (f, d) => d === "create" ? a : (s.has(d) || s.set(d, gl(d, void 0, n, r)), s.get(d)) }) } function gm({ top: n, left: r, right: s, bottom: a }) { return { x: { min: r, max: s }, y: { min: n, max: a } } } function Gx({ x: n, y: r }) { return { top: r.min, right: n.max, bottom: r.max, left: n.min } } function qx(n, r) { if (!r) return n; const s = r({ x: n.left, y: n.top }), a = r({ x: n.right, y: n.bottom }); return { top: s.y, left: s.x, bottom: a.y, right: a.x } } function yl(n) { return n === void 0 || n === 1 } function zl({ scale: n, scaleX: r, scaleY: s }) { return !yl(n) || !yl(r) || !yl(s) } function Vn(n) { return zl(n) || ym(n) || n.z || n.rotate || n.rotateX || n.rotateY || n.skewX || n.skewY } function ym(n) { return lh(n.x) || lh(n.y) } function lh(n) { return n && n !== "0%" } function ro(n, r, s) { const a = n - s, u = r * a; return s + u } function uh(n, r, s, a, u) { return u !== void 0 && (n = ro(n, u, a)), ro(n, s, a) + r } function Fl(n, r = 0, s = 1, a, u) { n.min = uh(n.min, r, s, a, u), n.max = uh(n.max, r, s, a, u) } function vm(n, { x: r, y: s }) { Fl(n.x, r.translate, r.scale, r.originPoint), Fl(n.y, s.translate, s.scale, s.originPoint) } const ch = .999999999999, dh = 1.0000000000001; function Yx(n, r, s, a = !1) { const u = s.length; if (!u) return; r.x = r.y = 1; let f, d; for (let h = 0; h < u; h++) { f = s[h], d = f.projectionDelta; const { visualElement: p } = f.options; p && p.props.style && p.props.style.display === "contents" || (a && f.options.layoutScroll && f.scroll && f !== f.root && yr(n, { x: -f.scroll.offset.x, y: -f.scroll.offset.y }), d && (r.x *= d.x.scale, r.y *= d.y.scale, vm(n, d)), a && Vn(f.latestValues) && yr(n, f.latestValues)) } r.x < dh && r.x > ch && (r.x = 1), r.y < dh && r.y > ch && (r.y = 1) } function gr(n, r) { n.min = n.min + r, n.max = n.max + r } function fh(n, r, s, a, u = .5) { const f = je(n.min, n.max, u); Fl(n, r, s, f, a) } function yr(n, r) { fh(n.x, r.x, r.scaleX, r.scale, r.originX), fh(n.y, r.y, r.scaleY, r.scale, r.originY) } function xm(n, r) { return gm(qx(n.getBoundingClientRect(), r)) } function Xx(n, r, s) { const a = xm(n, s), { scroll: u } = r; return u && (gr(a.x, u.offset.x), gr(a.y, u.offset.y)), a } const hh = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), vr = () => ({ x: hh(), y: hh() }), ph = () => ({ min: 0, max: 0 }), Ae = () => ({ x: ph(), y: ph() }), Bl = { current: null }, wm = { current: !1 }; function Qx() { if (wm.current = !0, !!eu) if (window.matchMedia) { const n = window.matchMedia("(prefers-reduced-motion)"), r = () => Bl.current = n.matches; n.addEventListener("change", r), r() } else Bl.current = !1 } const Zx = new WeakMap; function Jx(n, r, s) { for (const a in r) { const u = r[a], f = s[a]; if (qe(u)) n.addValue(a, u); else if (qe(f)) n.addValue(a, wr(u, { owner: n })); else if (f !== u) if (n.hasValue(a)) { const d = n.getValue(a); d.liveStyle === !0 ? d.jump(u) : d.hasAnimated || d.set(u) } else { const d = n.getStaticValue(a); n.addValue(a, wr(d !== void 0 ? d : u, { owner: n })) } } for (const a in s) r[a] === void 0 && n.removeValue(a); return r } const mh = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class e1 { scrapeMotionValuesFromProps(r, s, a) { return {} } constructor({ parent: r, props: s, presenceContext: a, reducedMotionConfig: u, blockInitialAnimation: f, visualState: d }, h = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = yu, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const S = lt.now(); this.renderScheduledAt < S && (this.renderScheduledAt = S, ke.render(this.render, !1, !0)) }; const { latestValues: p, renderState: v } = d; this.latestValues = p, this.baseTarget = { ...p }, this.initialValues = s.initial ? { ...p } : {}, this.renderState = v, this.parent = r, this.props = s, this.presenceContext = a, this.depth = r ? r.depth + 1 : 0, this.reducedMotionConfig = u, this.options = h, this.blockInitialAnimation = !!f, this.isControllingVariants = ao(s), this.isVariantNode = sm(s), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(r && r.current); const { willChange: y, ...x } = this.scrapeMotionValuesFromProps(s, {}, this); for (const S in x) { const N = x[S]; p[S] !== void 0 && qe(N) && N.set(p[S]) } } mount(r) { this.current = r, Zx.set(r, this), this.projection && !this.projection.instance && this.projection.mount(r), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((s, a) => this.bindToMotionValue(a, s)), wm.current || Qx(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Bl.current, this.parent?.addChild(this), this.update(this.props, this.presenceContext) } unmount() { this.projection && this.projection.unmount(), xn(this.notifyUpdate), xn(this.render), this.valueSubscriptions.forEach(r => r()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this); for (const r in this.events) this.events[r].clear(); for (const r in this.features) { const s = this.features[r]; s && (s.unmount(), s.isMounted = !1) } this.current = null } addChild(r) { this.children.add(r), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(r) } removeChild(r) { this.children.delete(r), this.enteringChildren && this.enteringChildren.delete(r) } bindToMotionValue(r, s) { this.valueSubscriptions.has(r) && this.valueSubscriptions.get(r)(); const a = Pr.has(r); a && this.onBindTransform && this.onBindTransform(); const u = s.on("change", d => { this.latestValues[r] = d, this.props.onUpdate && ke.preRender(this.notifyUpdate), a && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender() }); let f; window.MotionCheckAppearSync && (f = window.MotionCheckAppearSync(this, r, s)), this.valueSubscriptions.set(r, () => { u(), f && f(), s.owner && s.stop() }) } sortNodePosition(r) { return !this.current || !this.sortInstanceNodePosition || this.type !== r.type ? 0 : this.sortInstanceNodePosition(this.current, r.current) } updateFeatures() { let r = "animation"; for (r in Sr) { const s = Sr[r]; if (!s) continue; const { isEnabled: a, Feature: u } = s; if (!this.features[r] && u && a(this.props) && (this.features[r] = new u(this)), this.features[r]) { const f = this.features[r]; f.isMounted ? f.update() : (f.mount(), f.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Ae() } getStaticValue(r) { return this.latestValues[r] } setStaticValue(r, s) { this.latestValues[r] = s } update(r, s) { (r.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = r, this.prevPresenceContext = this.presenceContext, this.presenceContext = s; for (let a = 0; a < mh.length; a++) { const u = mh[a]; this.propEventSubscriptions[u] && (this.propEventSubscriptions[u](), delete this.propEventSubscriptions[u]); const f = "on" + u, d = r[f]; d && (this.propEventSubscriptions[u] = this.on(u, d)) } this.prevMotionValues = Jx(this, this.scrapeMotionValuesFromProps(r, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(r) { return this.props.variants ? this.props.variants[r] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(r) { const s = this.getClosestVariantNode(); if (s) return s.variantChildren && s.variantChildren.add(r), () => s.variantChildren.delete(r) } addValue(r, s) { const a = this.values.get(r); s !== a && (a && this.removeValue(r), this.bindToMotionValue(r, s), this.values.set(r, s), this.latestValues[r] = s.get()) } removeValue(r) { this.values.delete(r); const s = this.valueSubscriptions.get(r); s && (s(), this.valueSubscriptions.delete(r)), delete this.latestValues[r], this.removeValueFromRenderState(r, this.renderState) } hasValue(r) { return this.values.has(r) } getValue(r, s) { if (this.props.values && this.props.values[r]) return this.props.values[r]; let a = this.values.get(r); return a === void 0 && s !== void 0 && (a = wr(s === null ? void 0 : s, { owner: this }), this.addValue(r, a)), a } readValue(r, s) { let a = this.latestValues[r] !== void 0 || !this.current ? this.latestValues[r] : this.getBaseTargetFromProps(this.props, r) ?? this.readValueFromInstance(this.current, r, this.options); return a != null && (typeof a == "string" && (dp(a) || hp(a)) ? a = parseFloat(a) : !lx(a) && wn.test(s) && (a = qp(r, s)), this.setBaseTarget(r, qe(a) ? a.get() : a)), qe(a) ? a.get() : a } setBaseTarget(r, s) { this.baseTarget[r] = s } getBaseTarget(r) { const { initial: s } = this.props; let a; if (typeof s == "string" || typeof s == "object") { const f = Nu(this.props, s, this.presenceContext?.custom); f && (a = f[r]) } if (s && a !== void 0) return a; const u = this.getBaseTargetFromProps(this.props, r); return u !== void 0 && !qe(u) ? u : this.initialValues[r] !== void 0 && a === void 0 ? void 0 : this.baseTarget[r] } on(r, s) { return this.events[r] || (this.events[r] = new su), this.events[r].add(s) } notify(r, ...s) { this.events[r] && this.events[r].notify(...s) } scheduleRenderMicrotask() { wu.render(this.render) } } class Sm extends e1 { constructor() { super(...arguments), this.KeyframeResolver = Xv } sortInstanceNodePosition(r, s) { return r.compareDocumentPosition(s) & 2 ? 1 : -1 } getBaseTargetFromProps(r, s) { return r.style ? r.style[s] : void 0 } removeValueFromRenderState(r, { vars: s, style: a }) { delete s[r], delete a[r] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: r } = this.props; qe(r) && (this.childSubscription = r.on("change", s => { this.current && (this.current.textContent = `${s}`) })) } } function Cm(n, { style: r, vars: s }, a, u) { const f = n.style; let d; for (d in r) f[d] = r[d]; u?.applyProjectionStyles(f, a); for (d in s) f.setProperty(d, s[d]) } function t1(n) { return window.getComputedStyle(n) } class n1 extends Sm { constructor() { super(...arguments), this.type = "html", this.renderInstance = Cm } readValueFromInstance(r, s) { if (Pr.has(s)) return this.projection?.isProjecting ? bl(s) : mv(r, s); { const a = t1(r), u = (lu(s) ? a.getPropertyValue(s) : a[s]) || 0; return typeof u == "string" ? u.trim() : u } } measureInstanceViewportBox(r, { transformPagePoint: s }) { return xm(r, s) } build(r, s, a) { Eu(r, s, a.transformTemplate) } scrapeMotionValuesFromProps(r, s, a) { return Mu(r, s, a) } } const km = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function r1(n, r, s, a) { Cm(n, r, void 0, a); for (const u in r.attrs) n.setAttribute(km.has(u) ? u : Ru(u), r.attrs[u]) } class i1 extends Sm { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Ae } getBaseTargetFromProps(r, s) { return r[s] } readValueFromInstance(r, s) { if (Pr.has(s)) { const a = Gp(s); return a && a.default || 0 } return s = km.has(s) ? s : Ru(s), r.getAttribute(s) } scrapeMotionValuesFromProps(r, s, a) { return fm(r, s, a) } build(r, s, a) { lm(r, s, this.isSVGTag, a.transformTemplate, a.style) } renderInstance(r, s, a, u) { r1(r, s, a, u) } mount(r) { this.isSVGTag = cm(r.tagName), super.mount(r) } } const s1 = (n, r) => Tu(n) ? new i1(r) : new n1(r, { allowProjection: n !== M.Fragment }); function xr(n, r, s) { const a = n.getProps(); return Nu(a, r, s !== void 0 ? s : a.custom, n) } const Ul = n => Array.isArray(n); function o1(n, r, s) { n.hasValue(r) ? n.getValue(r).set(s) : n.addValue(r, wr(s)) } function a1(n) { return Ul(n) ? n[n.length - 1] || 0 : n } function l1(n, r) { const s = xr(n, r); let { transitionEnd: a = {}, transition: u = {}, ...f } = s || {}; f = { ...f, ...a }; for (const d in f) { const h = a1(f[d]); o1(n, d, h) } } function u1(n) { return !!(qe(n) && n.add) } function Hl(n, r) { const s = n.getValue("willChange"); if (u1(s)) return s.add(r); if (!s && Xt.WillChange) { const a = new Xt.WillChange("auto"); n.addValue("willChange", a), a.add(r) } } function Pm(n) { return n.props[hm] } const c1 = n => n !== null; function d1(n, { repeat: r, repeatType: s = "loop" }, a) { const u = n.filter(c1), f = r && s !== "loop" && r % 2 === 1 ? 0 : u.length - 1; return u[f] } const f1 = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, h1 = n => ({ type: "spring", stiffness: 550, damping: n === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), p1 = { type: "keyframes", duration: .8 }, m1 = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, g1 = (n, { keyframes: r }) => r.length > 2 ? p1 : Pr.has(n) ? n.startsWith("scale") ? h1(r[1]) : f1 : m1; function y1({ when: n, delay: r, delayChildren: s, staggerChildren: a, staggerDirection: u, repeat: f, repeatType: d, repeatDelay: h, from: p, elapsed: v, ...y }) { return !!Object.keys(y).length } const Au = (n, r, s, a = {}, u, f) => d => { const h = vu(a, n) || {}, p = h.delay || a.delay || 0; let { elapsed: v = 0 } = a; v = v - zt(p); const y = { keyframes: Array.isArray(s) ? s : [null, s], ease: "easeOut", velocity: r.getVelocity(), ...h, delay: -v, onUpdate: S => { r.set(S), h.onUpdate && h.onUpdate(S) }, onComplete: () => { d(), h.onComplete && h.onComplete() }, name: n, motionValue: r, element: f ? void 0 : u }; y1(h) || Object.assign(y, g1(n, y)), y.duration && (y.duration = zt(y.duration)), y.repeatDelay && (y.repeatDelay = zt(y.repeatDelay)), y.from !== void 0 && (y.keyframes[0] = y.from); let x = !1; if ((y.type === !1 || y.duration === 0 && !y.repeatDelay) && (Il(y), y.delay === 0 && (x = !0)), (Xt.instantAnimations || Xt.skipAnimations) && (x = !0, Il(y), y.delay = 0), y.allowFlatten = !h.type && !h.ease, x && !f && r.get() !== void 0) { const S = d1(y.keyframes, h); if (S !== void 0) { ke.update(() => { y.onUpdate(S), y.onComplete() }); return } } return h.isSync ? new gu(y) : new Ov(y) }; function v1({ protectedKeys: n, needsAnimating: r }, s) { const a = n.hasOwnProperty(s) && r[s] !== !0; return r[s] = !1, a } function Em(n, r, { delay: s = 0, transitionOverride: a, type: u } = {}) { let { transition: f = n.getDefaultTransition(), transitionEnd: d, ...h } = r; a && (f = a); const p = [], v = u && n.animationState && n.animationState.getState()[u]; for (const y in h) { const x = n.getValue(y, n.latestValues[y] ?? null), S = h[y]; if (S === void 0 || v && v1(v, y)) continue; const N = { delay: s, ...vu(f || {}, y) }, b = x.get(); if (b !== void 0 && !x.isAnimating && !Array.isArray(S) && S === b && !N.velocity) continue; let A = !1; if (window.MotionHandoffAnimation) { const I = Pm(n); if (I) { const B = window.MotionHandoffAnimation(I, y, ke); B !== null && (N.startTime = B, A = !0) } } Hl(n, y), x.start(Au(y, x, S, n.shouldReduceMotion && Wp.has(y) ? { type: !1 } : N, n, A)); const R = x.animation; R && p.push(R) } return d && Promise.all(p).then(() => { ke.update(() => { d && l1(n, d) }) }), p } function jm(n, r, s, a = 0, u = 1) { const f = Array.from(n).sort((v, y) => v.sortNodePosition(y)).indexOf(r), d = n.size, h = (d - 1) * a; return typeof s == "function" ? s(f, d) : u === 1 ? f * a : h - f * a } function Wl(n, r, s = {}) { const a = xr(n, r, s.type === "exit" ? n.presenceContext?.custom : void 0); let { transition: u = n.getDefaultTransition() || {} } = a || {}; s.transitionOverride && (u = s.transitionOverride); const f = a ? () => Promise.all(Em(n, a, s)) : () => Promise.resolve(), d = n.variantChildren && n.variantChildren.size ? (p = 0) => { const { delayChildren: v = 0, staggerChildren: y, staggerDirection: x } = u; return x1(n, r, p, v, y, x, s) } : () => Promise.resolve(), { when: h } = u; if (h) { const [p, v] = h === "beforeChildren" ? [f, d] : [d, f]; return p().then(() => v()) } else return Promise.all([f(), d(s.delay)]) } function x1(n, r, s = 0, a = 0, u = 0, f = 1, d) { const h = []; for (const p of n.variantChildren) p.notify("AnimationStart", r), h.push(Wl(p, r, { ...d, delay: s + (typeof a == "function" ? 0 : a) + jm(n.variantChildren, p, a, u, f) }).then(() => p.notify("AnimationComplete", r))); return Promise.all(h) } function w1(n, r, s = {}) { n.notify("AnimationStart", r); let a; if (Array.isArray(r)) { const u = r.map(f => Wl(n, f, s)); a = Promise.all(u) } else if (typeof r == "string") a = Wl(n, r, s); else { const u = typeof r == "function" ? xr(n, r, s.custom) : r; a = Promise.all(Em(n, u, s)) } return a.then(() => { n.notify("AnimationComplete", r) }) } function Tm(n, r) { if (!Array.isArray(r)) return !1; const s = r.length; if (s !== n.length) return !1; for (let a = 0; a < s; a++)if (r[a] !== n[a]) return !1; return !0 } const S1 = Pu.length; function Nm(n) { if (!n) return; if (!n.isControllingVariants) { const s = n.parent ? Nm(n.parent) || {} : {}; return n.props.initial !== void 0 && (s.initial = n.props.initial), s } const r = {}; for (let s = 0; s < S1; s++) { const a = Pu[s], u = n.props[a]; (Pi(u) || u === !1) && (r[a] = u) } return r } const C1 = [...ku].reverse(), k1 = ku.length; function P1(n) { return r => Promise.all(r.map(({ animation: s, options: a }) => w1(n, s, a))) } function E1(n) { let r = P1(n), s = gh(), a = !0; const u = p => (v, y) => { const x = xr(n, y, p === "exit" ? n.presenceContext?.custom : void 0); if (x) { const { transition: S, transitionEnd: N, ...b } = x; v = { ...v, ...b, ...N } } return v }; function f(p) { r = p(n) } function d(p) { const { props: v } = n, y = Nm(n.parent) || {}, x = [], S = new Set; let N = {}, b = 1 / 0; for (let R = 0; R < k1; R++) { const I = C1[R], B = s[I], z = v[I] !== void 0 ? v[I] : y[I], Y = Pi(z), $ = I === p ? B.isActive : null; $ === !1 && (b = R); let Z = z === y[I] && z !== v[I] && Y; if (Z && a && n.manuallyAnimateOnMount && (Z = !1), B.protectedKeys = { ...N }, !B.isActive && $ === null || !z && !B.prevProp || oo(z) || typeof z == "boolean") continue; const te = j1(B.prevProp, z); let Q = te || I === p && B.isActive && !Z && Y || R > b && Y, pe = !1; const ve = Array.isArray(z) ? z : [z]; let He = ve.reduce(u(I), {}); $ === !1 && (He = {}); const { prevResolvedValues: ut = {} } = B, Xe = { ...ut, ...He }, tt = ie => { Q = !0, S.has(ie) && (pe = !0, S.delete(ie)), B.needsAnimating[ie] = !0; const F = n.getValue(ie); F && (F.liveStyle = !1) }; for (const ie in Xe) { const F = He[ie], X = ut[ie]; if (N.hasOwnProperty(ie)) continue; let U = !1; Ul(F) && Ul(X) ? U = !Tm(F, X) : U = F !== X, U ? F != null ? tt(ie) : S.add(ie) : F !== void 0 && S.has(ie) ? tt(ie) : B.protectedKeys[ie] = !0 } B.prevProp = z, B.prevResolvedValues = He, B.isActive && (N = { ...N, ...He }), a && n.blockInitialAnimation && (Q = !1); const ct = Z && te; Q && (!ct || pe) && x.push(...ve.map(ie => { const F = { type: I }; if (typeof ie == "string" && a && !ct && n.manuallyAnimateOnMount && n.parent) { const { parent: X } = n, U = xr(X, ie); if (X.enteringChildren && U) { const { delayChildren: P } = U.transition || {}; F.delay = jm(X.enteringChildren, n, P) } } return { animation: ie, options: F } })) } if (S.size) { const R = {}; if (typeof v.initial != "boolean") { const I = xr(n, Array.isArray(v.initial) ? v.initial[0] : v.initial); I && I.transition && (R.transition = I.transition) } S.forEach(I => { const B = n.getBaseTarget(I), z = n.getValue(I); z && (z.liveStyle = !0), R[I] = B ?? null }), x.push({ animation: R }) } let A = !!x.length; return a && (v.initial === !1 || v.initial === v.animate) && !n.manuallyAnimateOnMount && (A = !1), a = !1, A ? r(x) : Promise.resolve() } function h(p, v) { if (s[p].isActive === v) return Promise.resolve(); n.variantChildren?.forEach(x => x.animationState?.setActive(p, v)), s[p].isActive = v; const y = d(p); for (const x in s) s[x].protectedKeys = {}; return y } return { animateChanges: d, setActive: h, setAnimateFunction: f, getState: () => s, reset: () => { s = gh() } } } function j1(n, r) { return typeof r == "string" ? r !== n : Array.isArray(r) ? !Tm(r, n) : !1 } function _n(n = !1) { return { isActive: n, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function gh() { return { animate: _n(!0), whileInView: _n(), whileHover: _n(), whileTap: _n(), whileDrag: _n(), whileFocus: _n(), exit: _n() } } class Sn { constructor(r) { this.isMounted = !1, this.node = r } update() { } } class T1 extends Sn { constructor(r) { super(r), r.animationState || (r.animationState = E1(r)) } updateAnimationControlsSubscription() { const { animate: r } = this.node.getProps(); oo(r) && (this.unmountControls = r.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: r } = this.node.getProps(), { animate: s } = this.node.prevProps || {}; r !== s && this.updateAnimationControlsSubscription() } unmount() { this.node.animationState.reset(), this.unmountControls?.() } } let N1 = 0; class M1 extends Sn { constructor() { super(...arguments), this.id = N1++ } update() { if (!this.node.presenceContext) return; const { isPresent: r, onExitComplete: s } = this.node.presenceContext, { isPresent: a } = this.node.prevPresenceContext || {}; if (!this.node.animationState || r === a) return; const u = this.node.animationState.setActive("exit", !r); s && !r && u.then(() => { s(this.id) }) } mount() { const { register: r, onExitComplete: s } = this.node.presenceContext || {}; s && s(this.id), r && (this.unmount = r(this.id)) } unmount() { } } const R1 = { animation: { Feature: T1 }, exit: { Feature: M1 } }; function ji(n, r, s, a = { passive: !0 }) { return n.addEventListener(r, s, a), () => n.removeEventListener(r, s) } function Di(n) { return { point: { x: n.pageX, y: n.pageY } } } const A1 = n => r => Su(r) && n(r, Di(r)); function vi(n, r, s, a) { return ji(n, r, A1(s), a) } const Mm = 1e-4, b1 = 1 - Mm, D1 = 1 + Mm, Rm = .01, L1 = 0 - Rm, _1 = 0 + Rm; function et(n) { return n.max - n.min } function V1(n, r, s) { return Math.abs(n - r) <= s } function yh(n, r, s, a = .5) { n.origin = a, n.originPoint = je(r.min, r.max, n.origin), n.scale = et(s) / et(r), n.translate = je(s.min, s.max, n.origin) - n.originPoint, (n.scale >= b1 && n.scale <= D1 || isNaN(n.scale)) && (n.scale = 1), (n.translate >= L1 && n.translate <= _1 || isNaN(n.translate)) && (n.translate = 0) } function xi(n, r, s, a) { yh(n.x, r.x, s.x, a ? a.originX : void 0), yh(n.y, r.y, s.y, a ? a.originY : void 0) } function vh(n, r, s) { n.min = s.min + r.min, n.max = n.min + et(r) } function I1(n, r, s) { vh(n.x, r.x, s.x), vh(n.y, r.y, s.y) } function xh(n, r, s) { n.min = r.min - s.min, n.max = n.min + et(r) } function wi(n, r, s) { xh(n.x, r.x, s.x), xh(n.y, r.y, s.y) } function kt(n) { return [n("x"), n("y")] } const Am = ({ current: n }) => n ? n.ownerDocument.defaultView : null, wh = (n, r) => Math.abs(n - r); function O1(n, r) { const s = wh(n.x, r.x), a = wh(n.y, r.y); return Math.sqrt(s ** 2 + a ** 2) } class bm { constructor(r, s, { transformPagePoint: a, contextWindow: u = window, dragSnapToOrigin: f = !1, distanceThreshold: d = 3 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const S = xl(this.lastMoveEventInfo, this.history), N = this.startEvent !== null, b = O1(S.offset, { x: 0, y: 0 }) >= this.distanceThreshold; if (!N && !b) return; const { point: A } = S, { timestamp: R } = Ue; this.history.push({ ...A, timestamp: R }); const { onStart: I, onMove: B } = this.handlers; N || (I && I(this.lastMoveEvent, S), this.startEvent = this.lastMoveEvent), B && B(this.lastMoveEvent, S) }, this.handlePointerMove = (S, N) => { this.lastMoveEvent = S, this.lastMoveEventInfo = vl(N, this.transformPagePoint), ke.update(this.updatePoint, !0) }, this.handlePointerUp = (S, N) => { this.end(); const { onEnd: b, onSessionEnd: A, resumeAnimation: R } = this.handlers; if (this.dragSnapToOrigin && R && R(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const I = xl(S.type === "pointercancel" ? this.lastMoveEventInfo : vl(N, this.transformPagePoint), this.history); this.startEvent && b && b(S, I), A && A(S, I) }, !Su(r)) return; this.dragSnapToOrigin = f, this.handlers = s, this.transformPagePoint = a, this.distanceThreshold = d, this.contextWindow = u || window; const h = Di(r), p = vl(h, this.transformPagePoint), { point: v } = p, { timestamp: y } = Ue; this.history = [{ ...v, timestamp: y }]; const { onSessionStart: x } = s; x && x(r, xl(p, this.history)), this.removeListeners = Ri(vi(this.contextWindow, "pointermove", this.handlePointerMove), vi(this.contextWindow, "pointerup", this.handlePointerUp), vi(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(r) { this.handlers = r } end() { this.removeListeners && this.removeListeners(), xn(this.updatePoint) } } function vl(n, r) { return r ? { point: r(n.point) } : n } function Sh(n, r) { return { x: n.x - r.x, y: n.y - r.y } } function xl({ point: n }, r) { return { point: n, delta: Sh(n, Dm(r)), offset: Sh(n, z1(r)), velocity: F1(r, .1) } } function z1(n) { return n[0] } function Dm(n) { return n[n.length - 1] } function F1(n, r) { if (n.length < 2) return { x: 0, y: 0 }; let s = n.length - 1, a = null; const u = Dm(n); for (; s >= 0 && (a = n[s], !(u.timestamp - a.timestamp > zt(r)));)s--; if (!a) return { x: 0, y: 0 }; const f = Pt(u.timestamp - a.timestamp); if (f === 0) return { x: 0, y: 0 }; const d = { x: (u.x - a.x) / f, y: (u.y - a.y) / f }; return d.x === 1 / 0 && (d.x = 0), d.y === 1 / 0 && (d.y = 0), d } function B1(n, { min: r, max: s }, a) { return r !== void 0 && n < r ? n = a ? je(r, n, a.min) : Math.max(n, r) : s !== void 0 && n > s && (n = a ? je(s, n, a.max) : Math.min(n, s)), n } function Ch(n, r, s) { return { min: r !== void 0 ? n.min + r : void 0, max: s !== void 0 ? n.max + s - (n.max - n.min) : void 0 } } function U1(n, { top: r, left: s, bottom: a, right: u }) { return { x: Ch(n.x, s, u), y: Ch(n.y, r, a) } } function kh(n, r) { let s = r.min - n.min, a = r.max - n.max; return r.max - r.min < n.max - n.min && ([s, a] = [a, s]), { min: s, max: a } } function H1(n, r) { return { x: kh(n.x, r.x), y: kh(n.y, r.y) } } function W1(n, r) { let s = .5; const a = et(n), u = et(r); return u > a ? s = Si(r.min, r.max - a, n.min) : a > u && (s = Si(n.min, n.max - u, r.min)), Yt(0, 1, s) } function $1(n, r) { const s = {}; return r.min !== void 0 && (s.min = r.min - n.min), r.max !== void 0 && (s.max = r.max - n.min), s } const $l = .35; function K1(n = $l) { return n === !1 ? n = 0 : n === !0 && (n = $l), { x: Ph(n, "left", "right"), y: Ph(n, "top", "bottom") } } function Ph(n, r, s) { return { min: Eh(n, r), max: Eh(n, s) } } function Eh(n, r) { return typeof n == "number" ? n : n[r] || 0 } const G1 = new WeakMap; class q1 { constructor(r) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Ae(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = r } start(r, { snapToCursor: s = !1, distanceThreshold: a } = {}) { const { presenceContext: u } = this.visualElement; if (u && u.isPresent === !1) return; const f = x => { const { dragSnapToOrigin: S } = this.getProps(); S ? this.pauseAnimation() : this.stopAnimation(), s && this.snapToCursor(Di(x).point) }, d = (x, S) => { const { drag: N, dragPropagation: b, onDragStart: A } = this.getProps(); if (N && !b && (this.openDragLock && this.openDragLock(), this.openDragLock = ex(N), !this.openDragLock)) return; this.latestPointerEvent = x, this.latestPanInfo = S, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), kt(I => { let B = this.getAxisMotionValue(I).get() || 0; if (Ft.test(B)) { const { projection: z } = this.visualElement; if (z && z.layout) { const Y = z.layout.layoutBox[I]; Y && (B = et(Y) * (parseFloat(B) / 100)) } } this.originPoint[I] = B }), A && ke.postRender(() => A(x, S)), Hl(this.visualElement, "transform"); const { animationState: R } = this.visualElement; R && R.setActive("whileDrag", !0) }, h = (x, S) => { this.latestPointerEvent = x, this.latestPanInfo = S; const { dragPropagation: N, dragDirectionLock: b, onDirectionLock: A, onDrag: R } = this.getProps(); if (!N && !this.openDragLock) return; const { offset: I } = S; if (b && this.currentDirection === null) { this.currentDirection = Y1(I), this.currentDirection !== null && A && A(this.currentDirection); return } this.updateAxis("x", S.point, I), this.updateAxis("y", S.point, I), this.visualElement.render(), R && R(x, S) }, p = (x, S) => { this.latestPointerEvent = x, this.latestPanInfo = S, this.stop(x, S), this.latestPointerEvent = null, this.latestPanInfo = null }, v = () => kt(x => this.getAnimationState(x) === "paused" && this.getAxisMotionValue(x).animation?.play()), { dragSnapToOrigin: y } = this.getProps(); this.panSession = new bm(r, { onSessionStart: f, onStart: d, onMove: h, onSessionEnd: p, resumeAnimation: v }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: y, distanceThreshold: a, contextWindow: Am(this.visualElement) }) } stop(r, s) { const a = r || this.latestPointerEvent, u = s || this.latestPanInfo, f = this.isDragging; if (this.cancel(), !f || !u || !a) return; const { velocity: d } = u; this.startAnimation(d); const { onDragEnd: h } = this.getProps(); h && ke.postRender(() => h(a, u)) } cancel() { this.isDragging = !1; const { projection: r, animationState: s } = this.visualElement; r && (r.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: a } = this.getProps(); !a && this.openDragLock && (this.openDragLock(), this.openDragLock = null), s && s.setActive("whileDrag", !1) } updateAxis(r, s, a) { const { drag: u } = this.getProps(); if (!a || !qs(r, u, this.currentDirection)) return; const f = this.getAxisMotionValue(r); let d = this.originPoint[r] + a[r]; this.constraints && this.constraints[r] && (d = B1(d, this.constraints[r], this.elastic[r])), f.set(d) } resolveConstraints() { const { dragConstraints: r, dragElastic: s } = this.getProps(), a = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, u = this.constraints; r && mr(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && a ? this.constraints = U1(a.layoutBox, r) : this.constraints = !1, this.elastic = K1(s), u !== this.constraints && a && this.constraints && !this.hasMutatedConstraints && kt(f => { this.constraints !== !1 && this.getAxisMotionValue(f) && (this.constraints[f] = $1(a.layoutBox[f], this.constraints[f])) }) } resolveRefConstraints() { const { dragConstraints: r, onMeasureDragConstraints: s } = this.getProps(); if (!r || !mr(r)) return !1; const a = r.current, { projection: u } = this.visualElement; if (!u || !u.layout) return !1; const f = Xx(a, u.root, this.visualElement.getTransformPagePoint()); let d = H1(u.layout.layoutBox, f); if (s) { const h = s(Gx(d)); this.hasMutatedConstraints = !!h, h && (d = gm(h)) } return d } startAnimation(r) { const { drag: s, dragMomentum: a, dragElastic: u, dragTransition: f, dragSnapToOrigin: d, onDragTransitionEnd: h } = this.getProps(), p = this.constraints || {}, v = kt(y => { if (!qs(y, s, this.currentDirection)) return; let x = p && p[y] || {}; d && (x = { min: 0, max: 0 }); const S = u ? 200 : 1e6, N = u ? 40 : 1e7, b = { type: "inertia", velocity: a ? r[y] : 0, bounceStiffness: S, bounceDamping: N, timeConstant: 750, restDelta: 1, restSpeed: 10, ...f, ...x }; return this.startAxisValueAnimation(y, b) }); return Promise.all(v).then(h) } startAxisValueAnimation(r, s) { const a = this.getAxisMotionValue(r); return Hl(this.visualElement, r), a.start(Au(r, a, 0, s, this.visualElement, !1)) } stopAnimation() { kt(r => this.getAxisMotionValue(r).stop()) } pauseAnimation() { kt(r => this.getAxisMotionValue(r).animation?.pause()) } getAnimationState(r) { return this.getAxisMotionValue(r).animation?.state } getAxisMotionValue(r) { const s = `_drag${r.toUpperCase()}`, a = this.visualElement.getProps(), u = a[s]; return u || this.visualElement.getValue(r, (a.initial ? a.initial[r] : void 0) || 0) } snapToCursor(r) { kt(s => { const { drag: a } = this.getProps(); if (!qs(s, a, this.currentDirection)) return; const { projection: u } = this.visualElement, f = this.getAxisMotionValue(s); if (u && u.layout) { const { min: d, max: h } = u.layout.layoutBox[s]; f.set(r[s] - je(d, h, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: r, dragConstraints: s } = this.getProps(), { projection: a } = this.visualElement; if (!mr(s) || !a || !this.constraints) return; this.stopAnimation(); const u = { x: 0, y: 0 }; kt(d => { const h = this.getAxisMotionValue(d); if (h && this.constraints !== !1) { const p = h.get(); u[d] = W1({ min: p, max: p }, this.constraints[d]) } }); const { transformTemplate: f } = this.visualElement.getProps(); this.visualElement.current.style.transform = f ? f({}, "") : "none", a.root && a.root.updateScroll(), a.updateLayout(), this.resolveConstraints(), kt(d => { if (!qs(d, r, null)) return; const h = this.getAxisMotionValue(d), { min: p, max: v } = this.constraints[d]; h.set(je(p, v, u[d])) }) } addListeners() { if (!this.visualElement.current) return; G1.set(this.visualElement, this); const r = this.visualElement.current, s = vi(r, "pointerdown", p => { const { drag: v, dragListener: y = !0 } = this.getProps(); v && y && this.start(p) }), a = () => { const { dragConstraints: p } = this.getProps(); mr(p) && p.current && (this.constraints = this.resolveRefConstraints()) }, { projection: u } = this.visualElement, f = u.addEventListener("measure", a); u && !u.layout && (u.root && u.root.updateScroll(), u.updateLayout()), ke.read(a); const d = ji(window, "resize", () => this.scalePositionWithinConstraints()), h = u.addEventListener("didUpdate", (({ delta: p, hasLayoutChanged: v }) => { this.isDragging && v && (kt(y => { const x = this.getAxisMotionValue(y); x && (this.originPoint[y] += p[y].translate, x.set(x.get() + p[y].translate)) }), this.visualElement.render()) })); return () => { d(), s(), f(), h && h() } } getProps() { const r = this.visualElement.getProps(), { drag: s = !1, dragDirectionLock: a = !1, dragPropagation: u = !1, dragConstraints: f = !1, dragElastic: d = $l, dragMomentum: h = !0 } = r; return { ...r, drag: s, dragDirectionLock: a, dragPropagation: u, dragConstraints: f, dragElastic: d, dragMomentum: h } } } function qs(n, r, s) { return (r === !0 || r === n) && (s === null || s === n) } function Y1(n, r = 10) { let s = null; return Math.abs(n.y) > r ? s = "y" : Math.abs(n.x) > r && (s = "x"), s } class X1 extends Sn { constructor(r) { super(r), this.removeGroupControls = Et, this.removeListeners = Et, this.controls = new q1(r) } mount() { const { dragControls: r } = this.node.getProps(); r && (this.removeGroupControls = r.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Et } unmount() { this.removeGroupControls(), this.removeListeners() } } const jh = n => (r, s) => { n && ke.postRender(() => n(r, s)) }; class Q1 extends Sn { constructor() { super(...arguments), this.removePointerDownListener = Et } onPointerDown(r) { this.session = new bm(r, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: Am(this.node) }) } createPanHandlers() { const { onPanSessionStart: r, onPanStart: s, onPan: a, onPanEnd: u } = this.node.getProps(); return { onSessionStart: jh(r), onStart: jh(s), onMove: a, onEnd: (f, d) => { delete this.session, u && ke.postRender(() => u(f, d)) } } } mount() { this.removePointerDownListener = vi(this.node.current, "pointerdown", r => this.onPointerDown(r)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const Zs = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function Th(n, r) { return r.max === r.min ? 0 : n / (r.max - r.min) * 100 } const hi = { correct: (n, r) => { if (!r.target) return n; if (typeof n == "string") if (ne.test(n)) n = parseFloat(n); else return n; const s = Th(n, r.target.x), a = Th(n, r.target.y); return `${s}% ${a}%` } }, Z1 = { correct: (n, { treeScale: r, projectionDelta: s }) => { const a = n, u = wn.parse(n); if (u.length > 5) return a; const f = wn.createTransformer(n), d = typeof u[0] != "number" ? 1 : 0, h = s.x.scale * r.x, p = s.y.scale * r.y; u[0 + d] /= h, u[1 + d] /= p; const v = je(h, p, .5); return typeof u[2 + d] == "number" && (u[2 + d] /= v), typeof u[3 + d] == "number" && (u[3 + d] /= v), f(u) } }; let wl = !1; class J1 extends M.Component { componentDidMount() { const { visualElement: r, layoutGroup: s, switchLayoutGroup: a, layoutId: u } = this.props, { projection: f } = r; Sx(ew), f && (s.group && s.group.add(f), a && a.register && u && a.register(f), wl && f.root.didUpdate(), f.addEventListener("animationComplete", () => { this.safeToRemove() }), f.setOptions({ ...f.options, onExitComplete: () => this.safeToRemove() })), Zs.hasEverUpdated = !0 } getSnapshotBeforeUpdate(r) { const { layoutDependency: s, visualElement: a, drag: u, isPresent: f } = this.props, { projection: d } = a; return d && (d.isPresent = f, wl = !0, u || r.layoutDependency !== s || s === void 0 || r.isPresent !== f ? d.willUpdate() : this.safeToRemove(), r.isPresent !== f && (f ? d.promote() : d.relegate() || ke.postRender(() => { const h = d.getStack(); (!h || !h.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: r } = this.props.visualElement; r && (r.root.didUpdate(), wu.postRender(() => { !r.currentAnimation && r.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: r, layoutGroup: s, switchLayoutGroup: a } = this.props, { projection: u } = r; wl = !0, u && (u.scheduleCheckAfterUnmount(), s && s.group && s.group.remove(u), a && a.deregister && a.deregister(u)) } safeToRemove() { const { safeToRemove: r } = this.props; r && r() } render() { return null } } function Lm(n) { const [r, s] = tm(), a = M.useContext(Zl); return g.jsx(J1, { ...n, layoutGroup: a, switchLayoutGroup: M.useContext(pm), isPresent: r, safeToRemove: s }) } const ew = { borderRadius: { ...hi, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: hi, borderTopRightRadius: hi, borderBottomLeftRadius: hi, borderBottomRightRadius: hi, boxShadow: Z1 }; function tw(n, r, s) { const a = qe(n) ? n : wr(n); return a.start(Au("", a, r, s)), a.animation } const nw = (n, r) => n.depth - r.depth; class rw { constructor() { this.children = [], this.isDirty = !1 } add(r) { tu(this.children, r), this.isDirty = !0 } remove(r) { nu(this.children, r), this.isDirty = !0 } forEach(r) { this.isDirty && this.children.sort(nw), this.isDirty = !1, this.children.forEach(r) } } function iw(n, r) { const s = lt.now(), a = ({ timestamp: u }) => { const f = u - s; f >= r && (xn(a), n(f - r)) }; return ke.setup(a, !0), () => xn(a) } const _m = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], sw = _m.length, Nh = n => typeof n == "string" ? parseFloat(n) : n, Mh = n => typeof n == "number" || ne.test(n); function ow(n, r, s, a, u, f) { u ? (n.opacity = je(0, s.opacity ?? 1, aw(a)), n.opacityExit = je(r.opacity ?? 1, 0, lw(a))) : f && (n.opacity = je(r.opacity ?? 1, s.opacity ?? 1, a)); for (let d = 0; d < sw; d++) { const h = `border${_m[d]}Radius`; let p = Rh(r, h), v = Rh(s, h); if (p === void 0 && v === void 0) continue; p || (p = 0), v || (v = 0), p === 0 || v === 0 || Mh(p) === Mh(v) ? (n[h] = Math.max(je(Nh(p), Nh(v), a), 0), (Ft.test(v) || Ft.test(p)) && (n[h] += "%")) : n[h] = v } (r.rotate || s.rotate) && (n.rotate = je(r.rotate || 0, s.rotate || 0, a)) } function Rh(n, r) { return n[r] !== void 0 ? n[r] : n.borderRadius } const aw = Vm(0, .5, Sp), lw = Vm(.5, .95, Et); function Vm(n, r, s) { return a => a < n ? 0 : a > r ? 1 : s(Si(n, r, a)) } function Ah(n, r) { n.min = r.min, n.max = r.max } function Ct(n, r) { Ah(n.x, r.x), Ah(n.y, r.y) } function bh(n, r) { n.translate = r.translate, n.scale = r.scale, n.originPoint = r.originPoint, n.origin = r.origin } function Dh(n, r, s, a, u) { return n -= r, n = ro(n, 1 / s, a), u !== void 0 && (n = ro(n, 1 / u, a)), n } function uw(n, r = 0, s = 1, a = .5, u, f = n, d = n) { if (Ft.test(r) && (r = parseFloat(r), r = je(d.min, d.max, r / 100) - d.min), typeof r != "number") return; let h = je(f.min, f.max, a); n === f && (h -= r), n.min = Dh(n.min, r, s, h, u), n.max = Dh(n.max, r, s, h, u) } function Lh(n, r, [s, a, u], f, d) { uw(n, r[s], r[a], r[u], r.scale, f, d) } const cw = ["x", "scaleX", "originX"], dw = ["y", "scaleY", "originY"]; function _h(n, r, s, a) { Lh(n.x, r, cw, s ? s.x : void 0, a ? a.x : void 0), Lh(n.y, r, dw, s ? s.y : void 0, a ? a.y : void 0) } function Vh(n) { return n.translate === 0 && n.scale === 1 } function Im(n) { return Vh(n.x) && Vh(n.y) } function Ih(n, r) { return n.min === r.min && n.max === r.max } function fw(n, r) { return Ih(n.x, r.x) && Ih(n.y, r.y) } function Oh(n, r) { return Math.round(n.min) === Math.round(r.min) && Math.round(n.max) === Math.round(r.max) } function Om(n, r) { return Oh(n.x, r.x) && Oh(n.y, r.y) } function zh(n) { return et(n.x) / et(n.y) } function Fh(n, r) { return n.translate === r.translate && n.scale === r.scale && n.originPoint === r.originPoint } class hw { constructor() { this.members = [] } add(r) { tu(this.members, r), r.scheduleRender() } remove(r) { if (nu(this.members, r), r === this.prevLead && (this.prevLead = void 0), r === this.lead) { const s = this.members[this.members.length - 1]; s && this.promote(s) } } relegate(r) { const s = this.members.findIndex(u => r === u); if (s === 0) return !1; let a; for (let u = s; u >= 0; u--) { const f = this.members[u]; if (f.isPresent !== !1) { a = f; break } } return a ? (this.promote(a), !0) : !1 } promote(r, s) { const a = this.lead; if (r !== a && (this.prevLead = a, this.lead = r, r.show(), a)) { a.instance && a.scheduleRender(), r.scheduleRender(), r.resumeFrom = a, s && (r.resumeFrom.preserveOpacity = !0), a.snapshot && (r.snapshot = a.snapshot, r.snapshot.latestValues = a.animationValues || a.latestValues), r.root && r.root.isUpdating && (r.isLayoutDirty = !0); const { crossfade: u } = r.options; u === !1 && a.hide() } } exitAnimationComplete() { this.members.forEach(r => { const { options: s, resumingFrom: a } = r; s.onExitComplete && s.onExitComplete(), a && a.options.onExitComplete && a.options.onExitComplete() }) } scheduleRender() { this.members.forEach(r => { r.instance && r.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function pw(n, r, s) { let a = ""; const u = n.x.translate / r.x, f = n.y.translate / r.y, d = s?.z || 0; if ((u || f || d) && (a = `translate3d(${u}px, ${f}px, ${d}px) `), (r.x !== 1 || r.y !== 1) && (a += `scale(${1 / r.x}, ${1 / r.y}) `), s) { const { transformPerspective: v, rotate: y, rotateX: x, rotateY: S, skewX: N, skewY: b } = s; v && (a = `perspective(${v}px) ${a}`), y && (a += `rotate(${y}deg) `), x && (a += `rotateX(${x}deg) `), S && (a += `rotateY(${S}deg) `), N && (a += `skewX(${N}deg) `), b && (a += `skewY(${b}deg) `) } const h = n.x.scale * r.x, p = n.y.scale * r.y; return (h !== 1 || p !== 1) && (a += `scale(${h}, ${p})`), a || "none" } const Sl = ["", "X", "Y", "Z"], mw = 1e3; let gw = 0; function Cl(n, r, s, a) { const { latestValues: u } = r; u[n] && (s[n] = u[n], r.setStaticValue(n, 0), a && (a[n] = 0)) } function zm(n) { if (n.hasCheckedOptimisedAppear = !0, n.root === n) return; const { visualElement: r } = n.options; if (!r) return; const s = Pm(r); if (window.MotionHasOptimisedAnimation(s, "transform")) { const { layout: u, layoutId: f } = n.options; window.MotionCancelOptimisedAnimation(s, "transform", ke, !(u || f)) } const { parent: a } = n; a && !a.hasCheckedOptimisedAppear && zm(a) } function Fm({ attachResizeListener: n, defaultParent: r, measureScroll: s, checkIsScrollRoot: a, resetTransform: u }) { return class { constructor(d = {}, h = r?.()) { this.id = gw++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(xw), this.nodes.forEach(kw), this.nodes.forEach(Pw), this.nodes.forEach(ww) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = d, this.root = h ? h.root || h : this, this.path = h ? [...h.path, h] : [], this.parent = h, this.depth = h ? h.depth + 1 : 0; for (let p = 0; p < this.path.length; p++)this.path[p].shouldResetTransform = !0; this.root === this && (this.nodes = new rw) } addEventListener(d, h) { return this.eventHandlers.has(d) || this.eventHandlers.set(d, new su), this.eventHandlers.get(d).add(h) } notifyListeners(d, ...h) { const p = this.eventHandlers.get(d); p && p.notify(...h) } hasListeners(d) { return this.eventHandlers.has(d) } mount(d) { if (this.instance) return; this.isSVG = em(d) && !ox(d), this.instance = d; const { layoutId: h, layout: p, visualElement: v } = this.options; if (v && !v.current && v.mount(d), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (p || h) && (this.isLayoutDirty = !0), n) { let y, x = 0; const S = () => this.root.updateBlockedByResize = !1; ke.read(() => { x = window.innerWidth }), n(d, () => { const N = window.innerWidth; N !== x && (x = N, this.root.updateBlockedByResize = !0, y && y(), y = iw(S, 250), Zs.hasAnimatedSinceResize && (Zs.hasAnimatedSinceResize = !1, this.nodes.forEach(Hh))) }) } h && this.root.registerSharedNode(h, this), this.options.animate !== !1 && v && (h || p) && this.addEventListener("didUpdate", ({ delta: y, hasLayoutChanged: x, hasRelativeLayoutChanged: S, layout: N }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const b = this.options.transition || v.getDefaultTransition() || Mw, { onLayoutAnimationStart: A, onLayoutAnimationComplete: R } = v.getProps(), I = !this.targetLayout || !Om(this.targetLayout, N), B = !x && S; if (this.options.layoutRoot || this.resumeFrom || B || x && (I || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); const z = { ...vu(b, "layout"), onPlay: A, onComplete: R }; (v.shouldReduceMotion || this.options.layoutRoot) && (z.delay = 0, z.type = !1), this.startAnimation(z), this.setAnimationOrigin(y, B) } else x || Hh(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = N }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const d = this.getStack(); d && d.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), xn(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Ew), this.animationId++) } getTransformTemplate() { const { visualElement: d } = this.options; return d && d.getProps().transformTemplate } willUpdate(d = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && zm(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let y = 0; y < this.path.length; y++) { const x = this.path[y]; x.shouldResetTransform = !0, x.updateScroll("snapshot"), x.options.layoutRoot && x.willUpdate(!1) } const { layoutId: h, layout: p } = this.options; if (h === void 0 && !p) return; const v = this.getTransformTemplate(); this.prevTransformTemplateValue = v ? v(this.latestValues, "") : void 0, this.updateSnapshot(), d && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Bh); return } if (this.animationId <= this.animationCommitId) { this.nodes.forEach(Uh); return } this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(Cw), this.nodes.forEach(yw), this.nodes.forEach(vw)) : this.nodes.forEach(Uh), this.clearAllSnapshots(); const h = lt.now(); Ue.delta = Yt(0, 1e3 / 60, h - Ue.timestamp), Ue.timestamp = h, Ue.isProcessing = !0, cl.update.process(Ue), cl.preRender.process(Ue), cl.render.process(Ue), Ue.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, wu.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(Sw), this.sharedNodes.forEach(jw) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, ke.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { ke.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !et(this.snapshot.measuredBox.x) && !et(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let p = 0; p < this.path.length; p++)this.path[p].updateScroll(); const d = this.layout; this.layout = this.measure(!1), this.layoutCorrected = Ae(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: h } = this.options; h && h.notify("LayoutMeasure", this.layout.layoutBox, d ? d.layoutBox : void 0) } updateScroll(d = "measure") { let h = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === d && (h = !1), h && this.instance) { const p = a(this.instance); this.scroll = { animationId: this.root.animationId, phase: d, isRoot: p, offset: s(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : p } } } resetTransform() { if (!u) return; const d = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, h = this.projectionDelta && !Im(this.projectionDelta), p = this.getTransformTemplate(), v = p ? p(this.latestValues, "") : void 0, y = v !== this.prevTransformTemplateValue; d && this.instance && (h || Vn(this.latestValues) || y) && (u(this.instance, v), this.shouldResetTransform = !1, this.scheduleRender()) } measure(d = !0) { const h = this.measurePageBox(); let p = this.removeElementScroll(h); return d && (p = this.removeTransform(p)), Rw(p), { animationId: this.root.animationId, measuredBox: h, layoutBox: p, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: d } = this.options; if (!d) return Ae(); const h = d.measureViewportBox(); if (!(this.scroll?.wasRoot || this.path.some(Aw))) { const { scroll: v } = this.root; v && (gr(h.x, v.offset.x), gr(h.y, v.offset.y)) } return h } removeElementScroll(d) { const h = Ae(); if (Ct(h, d), this.scroll?.wasRoot) return h; for (let p = 0; p < this.path.length; p++) { const v = this.path[p], { scroll: y, options: x } = v; v !== this.root && y && x.layoutScroll && (y.wasRoot && Ct(h, d), gr(h.x, y.offset.x), gr(h.y, y.offset.y)) } return h } applyTransform(d, h = !1) { const p = Ae(); Ct(p, d); for (let v = 0; v < this.path.length; v++) { const y = this.path[v]; !h && y.options.layoutScroll && y.scroll && y !== y.root && yr(p, { x: -y.scroll.offset.x, y: -y.scroll.offset.y }), Vn(y.latestValues) && yr(p, y.latestValues) } return Vn(this.latestValues) && yr(p, this.latestValues), p } removeTransform(d) { const h = Ae(); Ct(h, d); for (let p = 0; p < this.path.length; p++) { const v = this.path[p]; if (!v.instance || !Vn(v.latestValues)) continue; zl(v.latestValues) && v.updateSnapshot(); const y = Ae(), x = v.measurePageBox(); Ct(y, x), _h(h, v.latestValues, v.snapshot ? v.snapshot.layoutBox : void 0, y) } return Vn(this.latestValues) && _h(h, this.latestValues), h } setTargetDelta(d) { this.targetDelta = d, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(d) { this.options = { ...this.options, ...d, crossfade: d.crossfade !== void 0 ? d.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ue.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(d = !1) { const h = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = h.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = h.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = h.isSharedProjectionDirty); const p = !!this.resumingFrom || this !== h; if (!(d || p && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: y, layoutId: x } = this.options; if (!(!this.layout || !(y || x))) { if (this.resolvedRelativeTargetAt = Ue.timestamp, !this.targetDelta && !this.relativeTarget) { const S = this.getClosestProjectingParent(); S && S.layout && this.animationProgress !== 1 ? (this.relativeParent = S, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ae(), this.relativeTargetOrigin = Ae(), wi(this.relativeTargetOrigin, this.layout.layoutBox, S.layout.layoutBox), Ct(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Ae(), this.targetWithTransforms = Ae()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), I1(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Ct(this.target, this.layout.layoutBox), vm(this.target, this.targetDelta)) : Ct(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) { this.attemptToResolveRelativeTarget = !1; const S = this.getClosestProjectingParent(); S && !!S.resumingFrom == !!this.resumingFrom && !S.options.layoutScroll && S.target && this.animationProgress !== 1 ? (this.relativeParent = S, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Ae(), this.relativeTargetOrigin = Ae(), wi(this.relativeTargetOrigin, this.target, S.target), Ct(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } } } getClosestProjectingParent() { if (!(!this.parent || zl(this.parent.latestValues) || ym(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { const d = this.getLead(), h = !!this.resumingFrom || this !== d; let p = !0; if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (p = !1), h && (this.isSharedProjectionDirty || this.isTransformDirty) && (p = !1), this.resolvedRelativeTargetAt === Ue.timestamp && (p = !1), p) return; const { layout: v, layoutId: y } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(v || y)) return; Ct(this.layoutCorrected, this.layout.layoutBox); const x = this.treeScale.x, S = this.treeScale.y; Yx(this.layoutCorrected, this.treeScale, this.path, h), d.layout && !d.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (d.target = d.layout.layoutBox, d.targetWithTransforms = Ae()); const { target: N } = d; if (!N) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (bh(this.prevProjectionDelta.x, this.projectionDelta.x), bh(this.prevProjectionDelta.y, this.projectionDelta.y)), xi(this.projectionDelta, this.layoutCorrected, N, this.latestValues), (this.treeScale.x !== x || this.treeScale.y !== S || !Fh(this.projectionDelta.x, this.prevProjectionDelta.x) || !Fh(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", N)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(d = !0) { if (this.options.visualElement?.scheduleRender(), d) { const h = this.getStack(); h && h.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = vr(), this.projectionDelta = vr(), this.projectionDeltaWithTransform = vr() } setAnimationOrigin(d, h = !1) { const p = this.snapshot, v = p ? p.latestValues : {}, y = { ...this.latestValues }, x = vr(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !h; const S = Ae(), N = p ? p.source : void 0, b = this.layout ? this.layout.source : void 0, A = N !== b, R = this.getStack(), I = !R || R.members.length <= 1, B = !!(A && !I && this.options.crossfade === !0 && !this.path.some(Nw)); this.animationProgress = 0; let z; this.mixTargetDelta = Y => { const $ = Y / 1e3; Wh(x.x, d.x, $), Wh(x.y, d.y, $), this.setTargetDelta(x), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (wi(S, this.layout.layoutBox, this.relativeParent.layout.layoutBox), Tw(this.relativeTarget, this.relativeTargetOrigin, S, $), z && fw(this.relativeTarget, z) && (this.isProjectionDirty = !1), z || (z = Ae()), Ct(z, this.relativeTarget)), A && (this.animationValues = y, ow(y, v, this.latestValues, $, B, I)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = $ }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(d) { this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (xn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = ke.update(() => { Zs.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = wr(0)), this.currentAnimation = tw(this.motionValue, [0, 1e3], { ...d, velocity: 0, isSync: !0, onUpdate: h => { this.mixTargetDelta(h), d.onUpdate && d.onUpdate(h) }, onStop: () => { }, onComplete: () => { d.onComplete && d.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const d = this.getStack(); d && d.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(mw), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const d = this.getLead(); let { targetWithTransforms: h, target: p, layout: v, latestValues: y } = d; if (!(!h || !p || !v)) { if (this !== d && this.layout && v && Bm(this.options.animationType, this.layout.layoutBox, v.layoutBox)) { p = this.target || Ae(); const x = et(this.layout.layoutBox.x); p.x.min = d.target.x.min, p.x.max = p.x.min + x; const S = et(this.layout.layoutBox.y); p.y.min = d.target.y.min, p.y.max = p.y.min + S } Ct(h, p), yr(h, y), xi(this.projectionDeltaWithTransform, this.layoutCorrected, h, y) } } registerSharedNode(d, h) { this.sharedNodes.has(d) || this.sharedNodes.set(d, new hw), this.sharedNodes.get(d).add(h); const v = h.options.initialPromotionConfig; h.promote({ transition: v ? v.transition : void 0, preserveFollowOpacity: v && v.shouldPreserveFollowOpacity ? v.shouldPreserveFollowOpacity(h) : void 0 }) } isLead() { const d = this.getStack(); return d ? d.lead === this : !0 } getLead() { const { layoutId: d } = this.options; return d ? this.getStack()?.lead || this : this } getPrevLead() { const { layoutId: d } = this.options; return d ? this.getStack()?.prevLead : void 0 } getStack() { const { layoutId: d } = this.options; if (d) return this.root.sharedNodes.get(d) } promote({ needsReset: d, transition: h, preserveFollowOpacity: p } = {}) { const v = this.getStack(); v && v.promote(this, p), d && (this.projectionDelta = void 0, this.needsReset = !0), h && this.setOptions({ transition: h }) } relegate() { const d = this.getStack(); return d ? d.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: d } = this.options; if (!d) return; let h = !1; const { latestValues: p } = d; if ((p.z || p.rotate || p.rotateX || p.rotateY || p.rotateZ || p.skewX || p.skewY) && (h = !0), !h) return; const v = {}; p.z && Cl("z", d, v, this.animationValues); for (let y = 0; y < Sl.length; y++)Cl(`rotate${Sl[y]}`, d, v, this.animationValues), Cl(`skew${Sl[y]}`, d, v, this.animationValues); d.render(); for (const y in v) d.setStaticValue(y, v[y]), this.animationValues && (this.animationValues[y] = v[y]); d.scheduleRender() } applyProjectionStyles(d, h) { if (!this.instance || this.isSVG) return; if (!this.isVisible) { d.visibility = "hidden"; return } const p = this.getTransformTemplate(); if (this.needsReset) { this.needsReset = !1, d.visibility = "", d.opacity = "", d.pointerEvents = Qs(h?.pointerEvents) || "", d.transform = p ? p(this.latestValues, "") : "none"; return } const v = this.getLead(); if (!this.projectionDelta || !this.layout || !v.target) { this.options.layoutId && (d.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, d.pointerEvents = Qs(h?.pointerEvents) || ""), this.hasProjected && !Vn(this.latestValues) && (d.transform = p ? p({}, "") : "none", this.hasProjected = !1); return } d.visibility = ""; const y = v.animationValues || v.latestValues; this.applyTransformsToTarget(); let x = pw(this.projectionDeltaWithTransform, this.treeScale, y); p && (x = p(y, x)), d.transform = x; const { x: S, y: N } = this.projectionDelta; d.transformOrigin = `${S.origin * 100}% ${N.origin * 100}% 0`, v.animationValues ? d.opacity = v === this ? y.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : y.opacityExit : d.opacity = v === this ? y.opacity !== void 0 ? y.opacity : "" : y.opacityExit !== void 0 ? y.opacityExit : 0; for (const b in Ei) { if (y[b] === void 0) continue; const { correct: A, applyTo: R, isCSSVariable: I } = Ei[b], B = x === "none" ? y[b] : A(y[b], v); if (R) { const z = R.length; for (let Y = 0; Y < z; Y++)d[R[Y]] = B } else I ? this.options.visualElement.renderState.vars[b] = B : d[b] = B } this.options.layoutId && (d.pointerEvents = v === this ? Qs(h?.pointerEvents) || "" : "none") } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(d => d.currentAnimation?.stop()), this.root.nodes.forEach(Bh), this.root.sharedNodes.clear() } } } function yw(n) { n.updateLayout() } function vw(n) { const r = n.resumeFrom?.snapshot || n.snapshot; if (n.isLead() && n.layout && r && n.hasListeners("didUpdate")) { const { layoutBox: s, measuredBox: a } = n.layout, { animationType: u } = n.options, f = r.source !== n.layout.source; u === "size" ? kt(y => { const x = f ? r.measuredBox[y] : r.layoutBox[y], S = et(x); x.min = s[y].min, x.max = x.min + S }) : Bm(u, r.layoutBox, s) && kt(y => { const x = f ? r.measuredBox[y] : r.layoutBox[y], S = et(s[y]); x.max = x.min + S, n.relativeTarget && !n.currentAnimation && (n.isProjectionDirty = !0, n.relativeTarget[y].max = n.relativeTarget[y].min + S) }); const d = vr(); xi(d, s, r.layoutBox); const h = vr(); f ? xi(h, n.applyTransform(a, !0), r.measuredBox) : xi(h, s, r.layoutBox); const p = !Im(d); let v = !1; if (!n.resumeFrom) { const y = n.getClosestProjectingParent(); if (y && !y.resumeFrom) { const { snapshot: x, layout: S } = y; if (x && S) { const N = Ae(); wi(N, r.layoutBox, x.layoutBox); const b = Ae(); wi(b, s, S.layoutBox), Om(N, b) || (v = !0), y.options.layoutRoot && (n.relativeTarget = b, n.relativeTargetOrigin = N, n.relativeParent = y) } } } n.notifyListeners("didUpdate", { layout: s, snapshot: r, delta: h, layoutDelta: d, hasLayoutChanged: p, hasRelativeLayoutChanged: v }) } else if (n.isLead()) { const { onExitComplete: s } = n.options; s && s() } n.options.transition = void 0 } function xw(n) { n.parent && (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty), n.isSharedProjectionDirty || (n.isSharedProjectionDirty = !!(n.isProjectionDirty || n.parent.isProjectionDirty || n.parent.isSharedProjectionDirty)), n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty)) } function ww(n) { n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1 } function Sw(n) { n.clearSnapshot() } function Bh(n) { n.clearMeasurements() } function Uh(n) { n.isLayoutDirty = !1 } function Cw(n) { const { visualElement: r } = n.options; r && r.getProps().onBeforeLayoutMeasure && r.notify("BeforeLayoutMeasure"), n.resetTransform() } function Hh(n) { n.finishAnimation(), n.targetDelta = n.relativeTarget = n.target = void 0, n.isProjectionDirty = !0 } function kw(n) { n.resolveTargetDelta() } function Pw(n) { n.calcProjection() } function Ew(n) { n.resetSkewAndRotation() } function jw(n) { n.removeLeadSnapshot() } function Wh(n, r, s) { n.translate = je(r.translate, 0, s), n.scale = je(r.scale, 1, s), n.origin = r.origin, n.originPoint = r.originPoint } function $h(n, r, s, a) { n.min = je(r.min, s.min, a), n.max = je(r.max, s.max, a) } function Tw(n, r, s, a) { $h(n.x, r.x, s.x, a), $h(n.y, r.y, s.y, a) } function Nw(n) { return n.animationValues && n.animationValues.opacityExit !== void 0 } const Mw = { duration: .45, ease: [.4, 0, .1, 1] }, Kh = n => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(n), Gh = Kh("applewebkit/") && !Kh("chrome/") ? Math.round : Et; function qh(n) { n.min = Gh(n.min), n.max = Gh(n.max) } function Rw(n) { qh(n.x), qh(n.y) } function Bm(n, r, s) { return n === "position" || n === "preserve-aspect" && !V1(zh(r), zh(s), .2) } function Aw(n) { return n !== n.root && n.scroll?.wasRoot } const bw = Fm({ attachResizeListener: (n, r) => ji(n, "resize", r), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), kl = { current: void 0 }, Um = Fm({ measureScroll: n => ({ x: n.scrollLeft, y: n.scrollTop }), defaultParent: () => { if (!kl.current) { const n = new bw({}); n.mount(window), n.setOptions({ layoutScroll: !0 }), kl.current = n } return kl.current }, resetTransform: (n, r) => { n.style.transform = r !== void 0 ? r : "none" }, checkIsScrollRoot: n => window.getComputedStyle(n).position === "fixed" }), Dw = { pan: { Feature: Q1 }, drag: { Feature: X1, ProjectionNode: Um, MeasureLayout: Lm } }; function Yh(n, r, s) { const { props: a } = n; n.animationState && a.whileHover && n.animationState.setActive("whileHover", s === "Start"); const u = "onHover" + s, f = a[u]; f && ke.postRender(() => f(r, Di(r))) } class Lw extends Sn { mount() { const { current: r } = this.node; r && (this.unmount = tx(r, (s, a) => (Yh(this.node, a, "Start"), u => Yh(this.node, u, "End")))) } unmount() { } } class _w extends Sn { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let r = !1; try { r = this.node.current.matches(":focus-visible") } catch { r = !0 } !r || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = Ri(ji(this.node.current, "focus", () => this.onFocus()), ji(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function Xh(n, r, s) { const { props: a } = n; if (n.current instanceof HTMLButtonElement && n.current.disabled) return; n.animationState && a.whileTap && n.animationState.setActive("whileTap", s === "Start"); const u = "onTap" + (s === "End" ? "" : s), f = a[u]; f && ke.postRender(() => f(r, Di(r))) } class Vw extends Sn { mount() { const { current: r } = this.node; r && (this.unmount = sx(r, (s, a) => (Xh(this.node, a, "Start"), (u, { success: f }) => Xh(this.node, u, f ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const Kl = new WeakMap, Pl = new WeakMap, Iw = n => { const r = Kl.get(n.target); r && r(n) }, Ow = n => { n.forEach(Iw) }; function zw({ root: n, ...r }) { const s = n || document; Pl.has(s) || Pl.set(s, {}); const a = Pl.get(s), u = JSON.stringify(r); return a[u] || (a[u] = new IntersectionObserver(Ow, { root: n, ...r })), a[u] } function Fw(n, r, s) { const a = zw(r); return Kl.set(n, s), a.observe(n), () => { Kl.delete(n), a.unobserve(n) } } const Bw = { some: 0, all: 1 }; class Uw extends Sn { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: r = {} } = this.node.getProps(), { root: s, margin: a, amount: u = "some", once: f } = r, d = { root: s ? s.current : void 0, rootMargin: a, threshold: typeof u == "number" ? u : Bw[u] }, h = p => { const { isIntersecting: v } = p; if (this.isInView === v || (this.isInView = v, f && !v && this.hasEnteredView)) return; v && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", v); const { onViewportEnter: y, onViewportLeave: x } = this.node.getProps(), S = v ? y : x; S && S(p) }; return Fw(this.node.current, d, h) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: r, prevProps: s } = this.node;["amount", "margin", "root"].some(Hw(r, s)) && this.startObserver() } unmount() { } } function Hw({ viewport: n = {} }, { viewport: r = {} } = {}) { return s => n[s] !== r[s] } const Ww = { inView: { Feature: Uw }, tap: { Feature: Vw }, focus: { Feature: _w }, hover: { Feature: Lw } }, $w = { layout: { ProjectionNode: Um, MeasureLayout: Lm } }, Kw = { ...R1, ...Ww, ...Dw, ...$w }, Ye = Kx(Kw, s1); up();/**
 * @remix-run/router v1.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Ti() { return Ti = Object.assign ? Object.assign.bind() : function (n) { for (var r = 1; r < arguments.length; r++) { var s = arguments[r]; for (var a in s) Object.prototype.hasOwnProperty.call(s, a) && (n[a] = s[a]) } return n }, Ti.apply(this, arguments) } var vn; (function (n) { n.Pop = "POP", n.Push = "PUSH", n.Replace = "REPLACE" })(vn || (vn = {})); const Qh = "popstate"; function Gw(n) { n === void 0 && (n = {}); function r(a, u) { let { pathname: f, search: d, hash: h } = a.location; return Gl("", { pathname: f, search: d, hash: h }, u.state && u.state.usr || null, u.state && u.state.key || "default") } function s(a, u) { return typeof u == "string" ? u : Hm(u) } return Yw(r, s, null, n) } function Ve(n, r) { if (n === !1 || n === null || typeof n > "u") throw new Error(r) } function bu(n, r) { if (!n) { typeof console < "u" && console.warn(r); try { throw new Error(r) } catch { } } } function qw() { return Math.random().toString(36).substr(2, 8) } function Zh(n, r) { return { usr: n.state, key: n.key, idx: r } } function Gl(n, r, s, a) { return s === void 0 && (s = null), Ti({ pathname: typeof n == "string" ? n : n.pathname, search: "", hash: "" }, typeof r == "string" ? Er(r) : r, { state: s, key: r && r.key || a || qw() }) } function Hm(n) { let { pathname: r = "/", search: s = "", hash: a = "" } = n; return s && s !== "?" && (r += s.charAt(0) === "?" ? s : "?" + s), a && a !== "#" && (r += a.charAt(0) === "#" ? a : "#" + a), r } function Er(n) { let r = {}; if (n) { let s = n.indexOf("#"); s >= 0 && (r.hash = n.substr(s), n = n.substr(0, s)); let a = n.indexOf("?"); a >= 0 && (r.search = n.substr(a), n = n.substr(0, a)), n && (r.pathname = n) } return r } function Yw(n, r, s, a) { a === void 0 && (a = {}); let { window: u = document.defaultView, v5Compat: f = !1 } = a, d = u.history, h = vn.Pop, p = null, v = y(); v == null && (v = 0, d.replaceState(Ti({}, d.state, { idx: v }), "")); function y() { return (d.state || { idx: null }).idx } function x() { h = vn.Pop; let R = y(), I = R == null ? null : R - v; v = R, p && p({ action: h, location: A.location, delta: I }) } function S(R, I) { h = vn.Push; let B = Gl(A.location, R, I); v = y() + 1; let z = Zh(B, v), Y = A.createHref(B); try { d.pushState(z, "", Y) } catch ($) { if ($ instanceof DOMException && $.name === "DataCloneError") throw $; u.location.assign(Y) } f && p && p({ action: h, location: A.location, delta: 1 }) } function N(R, I) { h = vn.Replace; let B = Gl(A.location, R, I); v = y(); let z = Zh(B, v), Y = A.createHref(B); d.replaceState(z, "", Y), f && p && p({ action: h, location: A.location, delta: 0 }) } function b(R) { let I = u.location.origin !== "null" ? u.location.origin : u.location.href, B = typeof R == "string" ? R : Hm(R); return B = B.replace(/ $/, "%20"), Ve(I, "No window.location.(origin|href) available to create URL for href: " + B), new URL(B, I) } let A = { get action() { return h }, get location() { return n(u, d) }, listen(R) { if (p) throw new Error("A history only accepts one active listener"); return u.addEventListener(Qh, x), p = R, () => { u.removeEventListener(Qh, x), p = null } }, createHref(R) { return r(u, R) }, createURL: b, encodeLocation(R) { let I = b(R); return { pathname: I.pathname, search: I.search, hash: I.hash } }, push: S, replace: N, go(R) { return d.go(R) } }; return A } var Jh; (function (n) { n.data = "data", n.deferred = "deferred", n.redirect = "redirect", n.error = "error" })(Jh || (Jh = {})); function Xw(n, r, s) { return s === void 0 && (s = "/"), Qw(n, r, s) } function Qw(n, r, s, a) { let u = typeof r == "string" ? Er(r) : r, f = Km(u.pathname || "/", s); if (f == null) return null; let d = Wm(n); Zw(d); let h = null; for (let p = 0; h == null && p < d.length; ++p) { let v = cS(f); h = aS(d[p], v) } return h } function Wm(n, r, s, a) { r === void 0 && (r = []), s === void 0 && (s = []), a === void 0 && (a = ""); let u = (f, d, h) => { let p = { relativePath: h === void 0 ? f.path || "" : h, caseSensitive: f.caseSensitive === !0, childrenIndex: d, route: f }; p.relativePath.startsWith("/") && (Ve(p.relativePath.startsWith(a), 'Absolute route path "' + p.relativePath + '" nested under path ' + ('"' + a + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), p.relativePath = p.relativePath.slice(a.length)); let v = Bn([a, p.relativePath]), y = s.concat(p); f.children && f.children.length > 0 && (Ve(f.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + v + '".')), Wm(f.children, r, y, v)), !(f.path == null && !f.index) && r.push({ path: v, score: sS(v, f.index), routesMeta: y }) }; return n.forEach((f, d) => { var h; if (f.path === "" || !((h = f.path) != null && h.includes("?"))) u(f, d); else for (let p of $m(f.path)) u(f, d, p) }), r } function $m(n) { let r = n.split("/"); if (r.length === 0) return []; let [s, ...a] = r, u = s.endsWith("?"), f = s.replace(/\?$/, ""); if (a.length === 0) return u ? [f, ""] : [f]; let d = $m(a.join("/")), h = []; return h.push(...d.map(p => p === "" ? f : [f, p].join("/"))), u && h.push(...d), h.map(p => n.startsWith("/") && p === "" ? "/" : p) } function Zw(n) { n.sort((r, s) => r.score !== s.score ? s.score - r.score : oS(r.routesMeta.map(a => a.childrenIndex), s.routesMeta.map(a => a.childrenIndex))) } const Jw = /^:[\w-]+$/, eS = 3, tS = 2, nS = 1, rS = 10, iS = -2, ep = n => n === "*"; function sS(n, r) { let s = n.split("/"), a = s.length; return s.some(ep) && (a += iS), r && (a += tS), s.filter(u => !ep(u)).reduce((u, f) => u + (Jw.test(f) ? eS : f === "" ? nS : rS), a) } function oS(n, r) { return n.length === r.length && n.slice(0, -1).every((a, u) => a === r[u]) ? n[n.length - 1] - r[r.length - 1] : 0 } function aS(n, r, s) { let { routesMeta: a } = n, u = {}, f = "/", d = []; for (let h = 0; h < a.length; ++h) { let p = a[h], v = h === a.length - 1, y = f === "/" ? r : r.slice(f.length) || "/", x = lS({ path: p.relativePath, caseSensitive: p.caseSensitive, end: v }, y), S = p.route; if (!x) return null; Object.assign(u, x.params), d.push({ params: u, pathname: Bn([f, x.pathname]), pathnameBase: yS(Bn([f, x.pathnameBase])), route: S }), x.pathnameBase !== "/" && (f = Bn([f, x.pathnameBase])) } return d } function lS(n, r) { typeof n == "string" && (n = { path: n, caseSensitive: !1, end: !0 }); let [s, a] = uS(n.path, n.caseSensitive, n.end), u = r.match(s); if (!u) return null; let f = u[0], d = f.replace(/(.)\/+$/, "$1"), h = u.slice(1); return { params: a.reduce((v, y, x) => { let { paramName: S, isOptional: N } = y; if (S === "*") { let A = h[x] || ""; d = f.slice(0, f.length - A.length).replace(/(.)\/+$/, "$1") } const b = h[x]; return N && !b ? v[S] = void 0 : v[S] = (b || "").replace(/%2F/g, "/"), v }, {}), pathname: f, pathnameBase: d, pattern: n } } function uS(n, r, s) { r === void 0 && (r = !1), s === void 0 && (s = !0), bu(n === "*" || !n.endsWith("*") || n.endsWith("/*"), 'Route path "' + n + '" will be treated as if it were ' + ('"' + n.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + n.replace(/\*$/, "/*") + '".')); let a = [], u = "^" + n.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (d, h, p) => (a.push({ paramName: h, isOptional: p != null }), p ? "/?([^\\/]+)?" : "/([^\\/]+)")); return n.endsWith("*") ? (a.push({ paramName: "*" }), u += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : s ? u += "\\/*$" : n !== "" && n !== "/" && (u += "(?:(?=\\/|$))"), [new RegExp(u, r ? void 0 : "i"), a] } function cS(n) { try { return n.split("/").map(r => decodeURIComponent(r).replace(/\//g, "%2F")).join("/") } catch (r) { return bu(!1, 'The URL path "' + n + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + r + ").")), n } } function Km(n, r) { if (r === "/") return n; if (!n.toLowerCase().startsWith(r.toLowerCase())) return null; let s = r.endsWith("/") ? r.length - 1 : r.length, a = n.charAt(s); return a && a !== "/" ? null : n.slice(s) || "/" } const dS = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, fS = n => dS.test(n); function hS(n, r) { r === void 0 && (r = "/"); let { pathname: s, search: a = "", hash: u = "" } = typeof n == "string" ? Er(n) : n, f; if (s) if (fS(s)) f = s; else { if (s.includes("//")) { let d = s; s = s.replace(/\/\/+/g, "/"), bu(!1, "Pathnames cannot have embedded double slashes - normalizing " + (d + " -> " + s)) } s.startsWith("/") ? f = tp(s.substring(1), "/") : f = tp(s, r) } else f = r; return { pathname: f, search: vS(a), hash: xS(u) } } function tp(n, r) { let s = r.replace(/\/+$/, "").split("/"); return n.split("/").forEach(u => { u === ".." ? s.length > 1 && s.pop() : u !== "." && s.push(u) }), s.length > 1 ? s.join("/") : "/" } function El(n, r, s, a) { return "Cannot include a '" + n + "' character in a manually specified " + ("`to." + r + "` field [" + JSON.stringify(a) + "].  Please separate it out to the ") + ("`to." + s + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function pS(n) { return n.filter((r, s) => s === 0 || r.route.path && r.route.path.length > 0) } function mS(n, r) { let s = pS(n); return r ? s.map((a, u) => u === s.length - 1 ? a.pathname : a.pathnameBase) : s.map(a => a.pathnameBase) } function gS(n, r, s, a) { a === void 0 && (a = !1); let u; typeof n == "string" ? u = Er(n) : (u = Ti({}, n), Ve(!u.pathname || !u.pathname.includes("?"), El("?", "pathname", "search", u)), Ve(!u.pathname || !u.pathname.includes("#"), El("#", "pathname", "hash", u)), Ve(!u.search || !u.search.includes("#"), El("#", "search", "hash", u))); let f = n === "" || u.pathname === "", d = f ? "/" : u.pathname, h; if (d == null) h = s; else { let x = r.length - 1; if (!a && d.startsWith("..")) { let S = d.split("/"); for (; S[0] === "..";)S.shift(), x -= 1; u.pathname = S.join("/") } h = x >= 0 ? r[x] : "/" } let p = hS(u, h), v = d && d !== "/" && d.endsWith("/"), y = (f || d === ".") && s.endsWith("/"); return !p.pathname.endsWith("/") && (v || y) && (p.pathname += "/"), p } const Bn = n => n.join("/").replace(/\/\/+/g, "/"), yS = n => n.replace(/\/+$/, "").replace(/^\/*/, "/"), vS = n => !n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n, xS = n => !n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n; function wS(n) { return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.internal == "boolean" && "data" in n } const Gm = ["post", "put", "patch", "delete"]; new Set(Gm); const SS = ["get", ...Gm]; new Set(SS);/**
 * React Router v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Ni() { return Ni = Object.assign ? Object.assign.bind() : function (n) { for (var r = 1; r < arguments.length; r++) { var s = arguments[r]; for (var a in s) Object.prototype.hasOwnProperty.call(s, a) && (n[a] = s[a]) } return n }, Ni.apply(this, arguments) } const Du = M.createContext(null), CS = M.createContext(null), lo = M.createContext(null), uo = M.createContext(null), jr = M.createContext({ outlet: null, matches: [], isDataRoute: !1 }), qm = M.createContext(null); function co() { return M.useContext(uo) != null } function Ym() { return co() || Ve(!1), M.useContext(uo).location } function Xm(n) { M.useContext(lo).static || M.useLayoutEffect(n) } function kS() { let { isDataRoute: n } = M.useContext(jr); return n ? VS() : PS() } function PS() { co() || Ve(!1); let n = M.useContext(Du), { basename: r, future: s, navigator: a } = M.useContext(lo), { matches: u } = M.useContext(jr), { pathname: f } = Ym(), d = JSON.stringify(mS(u, s.v7_relativeSplatPath)), h = M.useRef(!1); return Xm(() => { h.current = !0 }), M.useCallback(function (v, y) { if (y === void 0 && (y = {}), !h.current) return; if (typeof v == "number") { a.go(v); return } let x = gS(v, JSON.parse(d), f, y.relative === "path"); n == null && r !== "/" && (x.pathname = x.pathname === "/" ? r : Bn([r, x.pathname])), (y.replace ? a.replace : a.push)(x, y.state, y) }, [r, a, d, f, n]) } function ES(n, r) { return jS(n, r) } function jS(n, r, s, a) { co() || Ve(!1); let { navigator: u } = M.useContext(lo), { matches: f } = M.useContext(jr), d = f[f.length - 1], h = d ? d.params : {}; d && d.pathname; let p = d ? d.pathnameBase : "/"; d && d.route; let v = Ym(), y; if (r) { var x; let R = typeof r == "string" ? Er(r) : r; p === "/" || (x = R.pathname) != null && x.startsWith(p) || Ve(!1), y = R } else y = v; let S = y.pathname || "/", N = S; if (p !== "/") { let R = p.replace(/^\//, "").split("/"); N = "/" + S.replace(/^\//, "").split("/").slice(R.length).join("/") } let b = Xw(n, { pathname: N }), A = AS(b && b.map(R => Object.assign({}, R, { params: Object.assign({}, h, R.params), pathname: Bn([p, u.encodeLocation ? u.encodeLocation(R.pathname).pathname : R.pathname]), pathnameBase: R.pathnameBase === "/" ? p : Bn([p, u.encodeLocation ? u.encodeLocation(R.pathnameBase).pathname : R.pathnameBase]) })), f, s, a); return r && A ? M.createElement(uo.Provider, { value: { location: Ni({ pathname: "/", search: "", hash: "", state: null, key: "default" }, y), navigationType: vn.Pop } }, A) : A } function TS() { let n = _S(), r = wS(n) ? n.status + " " + n.statusText : n instanceof Error ? n.message : JSON.stringify(n), s = n instanceof Error ? n.stack : null, u = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return M.createElement(M.Fragment, null, M.createElement("h2", null, "Unexpected Application Error!"), M.createElement("h3", { style: { fontStyle: "italic" } }, r), s ? M.createElement("pre", { style: u }, s) : null, null) } const NS = M.createElement(TS, null); class MS extends M.Component { constructor(r) { super(r), this.state = { location: r.location, revalidation: r.revalidation, error: r.error } } static getDerivedStateFromError(r) { return { error: r } } static getDerivedStateFromProps(r, s) { return s.location !== r.location || s.revalidation !== "idle" && r.revalidation === "idle" ? { error: r.error, location: r.location, revalidation: r.revalidation } : { error: r.error !== void 0 ? r.error : s.error, location: s.location, revalidation: r.revalidation || s.revalidation } } componentDidCatch(r, s) { console.error("React Router caught the following error during render", r, s) } render() { return this.state.error !== void 0 ? M.createElement(jr.Provider, { value: this.props.routeContext }, M.createElement(qm.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function RS(n) { let { routeContext: r, match: s, children: a } = n, u = M.useContext(Du); return u && u.static && u.staticContext && (s.route.errorElement || s.route.ErrorBoundary) && (u.staticContext._deepestRenderedBoundaryId = s.route.id), M.createElement(jr.Provider, { value: r }, a) } function AS(n, r, s, a) { var u; if (r === void 0 && (r = []), s === void 0 && (s = null), a === void 0 && (a = null), n == null) { var f; if (!s) return null; if (s.errors) n = s.matches; else if ((f = a) != null && f.v7_partialHydration && r.length === 0 && !s.initialized && s.matches.length > 0) n = s.matches; else return null } let d = n, h = (u = s) == null ? void 0 : u.errors; if (h != null) { let y = d.findIndex(x => x.route.id && h?.[x.route.id] !== void 0); y >= 0 || Ve(!1), d = d.slice(0, Math.min(d.length, y + 1)) } let p = !1, v = -1; if (s && a && a.v7_partialHydration) for (let y = 0; y < d.length; y++) { let x = d[y]; if ((x.route.HydrateFallback || x.route.hydrateFallbackElement) && (v = y), x.route.id) { let { loaderData: S, errors: N } = s, b = x.route.loader && S[x.route.id] === void 0 && (!N || N[x.route.id] === void 0); if (x.route.lazy || b) { p = !0, v >= 0 ? d = d.slice(0, v + 1) : d = [d[0]]; break } } } return d.reduceRight((y, x, S) => { let N, b = !1, A = null, R = null; s && (N = h && x.route.id ? h[x.route.id] : void 0, A = x.route.errorElement || NS, p && (v < 0 && S === 0 ? (IS("route-fallback"), b = !0, R = null) : v === S && (b = !0, R = x.route.hydrateFallbackElement || null))); let I = r.concat(d.slice(0, S + 1)), B = () => { let z; return N ? z = A : b ? z = R : x.route.Component ? z = M.createElement(x.route.Component, null) : x.route.element ? z = x.route.element : z = y, M.createElement(RS, { match: x, routeContext: { outlet: y, matches: I, isDataRoute: s != null }, children: z }) }; return s && (x.route.ErrorBoundary || x.route.errorElement || S === 0) ? M.createElement(MS, { location: s.location, revalidation: s.revalidation, component: A, error: N, children: B(), routeContext: { outlet: null, matches: I, isDataRoute: !0 } }) : B() }, null) } var Qm = (function (n) { return n.UseBlocker = "useBlocker", n.UseRevalidator = "useRevalidator", n.UseNavigateStable = "useNavigate", n })(Qm || {}), Zm = (function (n) { return n.UseBlocker = "useBlocker", n.UseLoaderData = "useLoaderData", n.UseActionData = "useActionData", n.UseRouteError = "useRouteError", n.UseNavigation = "useNavigation", n.UseRouteLoaderData = "useRouteLoaderData", n.UseMatches = "useMatches", n.UseRevalidator = "useRevalidator", n.UseNavigateStable = "useNavigate", n.UseRouteId = "useRouteId", n })(Zm || {}); function bS(n) { let r = M.useContext(Du); return r || Ve(!1), r } function DS(n) { let r = M.useContext(CS); return r || Ve(!1), r } function LS(n) { let r = M.useContext(jr); return r || Ve(!1), r } function Jm(n) { let r = LS(), s = r.matches[r.matches.length - 1]; return s.route.id || Ve(!1), s.route.id } function _S() { var n; let r = M.useContext(qm), s = DS(), a = Jm(); return r !== void 0 ? r : (n = s.errors) == null ? void 0 : n[a] } function VS() { let { router: n } = bS(Qm.UseNavigateStable), r = Jm(Zm.UseNavigateStable), s = M.useRef(!1); return Xm(() => { s.current = !0 }), M.useCallback(function (u, f) { f === void 0 && (f = {}), s.current && (typeof u == "number" ? n.navigate(u) : n.navigate(u, Ni({ fromRouteId: r }, f))) }, [n, r]) } const np = {}; function IS(n, r, s) { np[n] || (np[n] = !0) } function OS(n, r) { n?.v7_startTransition, n?.v7_relativeSplatPath } function hr(n) { Ve(!1) } function zS(n) { let { basename: r = "/", children: s = null, location: a, navigationType: u = vn.Pop, navigator: f, static: d = !1, future: h } = n; co() && Ve(!1); let p = r.replace(/^\/*/, "/"), v = M.useMemo(() => ({ basename: p, navigator: f, static: d, future: Ni({ v7_relativeSplatPath: !1 }, h) }), [p, h, f, d]); typeof a == "string" && (a = Er(a)); let { pathname: y = "/", search: x = "", hash: S = "", state: N = null, key: b = "default" } = a, A = M.useMemo(() => { let R = Km(y, p); return R == null ? null : { location: { pathname: R, search: x, hash: S, state: N, key: b }, navigationType: u } }, [p, y, x, S, N, b, u]); return A == null ? null : M.createElement(lo.Provider, { value: v }, M.createElement(uo.Provider, { children: s, value: A })) } function FS(n) { let { children: r, location: s } = n; return ES(ql(r), s) } new Promise(() => { }); function ql(n, r) { r === void 0 && (r = []); let s = []; return M.Children.forEach(n, (a, u) => { if (!M.isValidElement(a)) return; let f = [...r, u]; if (a.type === M.Fragment) { s.push.apply(s, ql(a.props.children, f)); return } a.type !== hr && Ve(!1), !a.props.index || !a.props.children || Ve(!1); let d = { id: a.props.id || f.join("-"), caseSensitive: a.props.caseSensitive, element: a.props.element, Component: a.props.Component, index: a.props.index, path: a.props.path, loader: a.props.loader, action: a.props.action, errorElement: a.props.errorElement, ErrorBoundary: a.props.ErrorBoundary, hasErrorBoundary: a.props.ErrorBoundary != null || a.props.errorElement != null, shouldRevalidate: a.props.shouldRevalidate, handle: a.props.handle, lazy: a.props.lazy }; a.props.children && (d.children = ql(a.props.children, f)), s.push(d) }), s }/**
 * React Router DOM v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */const BS = "6"; try { window.__reactRouterVersion = BS } catch { } const US = "startTransition", rp = f0[US]; function HS(n) { let { basename: r, children: s, future: a, window: u } = n, f = M.useRef(); f.current == null && (f.current = Gw({ window: u, v5Compat: !0 })); let d = f.current, [h, p] = M.useState({ action: d.action, location: d.location }), { v7_startTransition: v } = a || {}, y = M.useCallback(x => { v && rp ? rp(() => p(x)) : p(x) }, [p, v]); return M.useLayoutEffect(() => d.listen(y), [d, y]), M.useEffect(() => OS(a), [a]), M.createElement(zS, { basename: r, children: s, location: h.location, navigationType: h.action, navigator: d, future: a }) } var ip; (function (n) { n.UseScrollRestoration = "useScrollRestoration", n.UseSubmit = "useSubmit", n.UseSubmitFetcher = "useSubmitFetcher", n.UseFetcher = "useFetcher", n.useViewTransitionState = "useViewTransitionState" })(ip || (ip = {})); var sp; (function (n) { n.UseFetcher = "useFetcher", n.UseFetchers = "useFetchers", n.UseScrollRestoration = "useScrollRestoration" })(sp || (sp = {}));/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const WS = n => n.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), $S = n => n.replace(/^([A-Z])|[\s-_]+(\w)/g, (r, s, a) => a ? a.toUpperCase() : s.toLowerCase()), op = n => { const r = $S(n); return r.charAt(0).toUpperCase() + r.slice(1) }, eg = (...n) => n.filter((r, s, a) => !!r && r.trim() !== "" && a.indexOf(r) === s).join(" ").trim();/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var KS = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const GS = M.forwardRef(({ color: n = "currentColor", size: r = 24, strokeWidth: s = 2, absoluteStrokeWidth: a, className: u = "", children: f, iconNode: d, ...h }, p) => M.createElement("svg", { ref: p, ...KS, width: r, height: r, stroke: n, strokeWidth: a ? Number(s) * 24 / Number(r) : s, className: eg("lucide", u), ...h }, [...d.map(([v, y]) => M.createElement(v, y)), ...Array.isArray(f) ? f : [f]]));/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const me = (n, r) => { const s = M.forwardRef(({ className: a, ...u }, f) => M.createElement(GS, { ref: f, iconNode: r, className: eg(`lucide-${WS(op(n))}`, `lucide-${n}`, a), ...u })); return s.displayName = op(n), s };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const qS = [["path", { d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2", key: "169zse" }]], YS = me("activity", qS);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const XS = [["path", { d: "M12 20.94c1.5 0 2.75 1.06 4 1.06 3 0 6-8 6-12.22A4.91 4.91 0 0 0 17 5c-2.22 0-4 1.44-5 2-1-.56-2.78-2-5-2a4.9 4.9 0 0 0-5 4.78C2 14 5 22 8 22c1.25 0 2.5-1.06 4-1.06Z", key: "3s7exb" }], ["path", { d: "M10 2c1 .5 2 2 2 5", key: "fcco2y" }]], QS = me("apple", XS);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ZS = [["path", { d: "m12 19-7-7 7-7", key: "1l729n" }], ["path", { d: "M19 12H5", key: "x3x0zl" }]], Mi = me("arrow-left", ZS);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const JS = [["path", { d: "M9 12h.01", key: "157uk2" }], ["path", { d: "M15 12h.01", key: "1k8ypt" }], ["path", { d: "M10 16c.5.3 1.2.5 2 .5s1.5-.2 2-.5", key: "1u7htd" }], ["path", { d: "M19 6.3a9 9 0 0 1 1.8 3.9 2 2 0 0 1 0 3.6 9 9 0 0 1-17.6 0 2 2 0 0 1 0-3.6A9 9 0 0 1 12 3c2 0 3.5 1.1 3.5 2.5s-.9 2.5-2 2.5c-.8 0-1.5-.4-1.5-1", key: "5yv0yz" }]], tg = me("baby", JS);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const e2 = [["path", { d: "M17 10c.7-.7 1.69 0 2.5 0a2.5 2.5 0 1 0 0-5 .5.5 0 0 1-.5-.5 2.5 2.5 0 1 0-5 0c0 .81.7 1.8 0 2.5l-7 7c-.7.7-1.69 0-2.5 0a2.5 2.5 0 0 0 0 5c.28 0 .5.22.5.5a2.5 2.5 0 1 0 5 0c0-.81-.7-1.8 0-2.5Z", key: "w610uw" }]], t2 = me("bone", e2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const n2 = [["path", { d: "M12 7v14", key: "1akyts" }], ["path", { d: "M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z", key: "ruj8y" }]], r2 = me("book-open", n2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const i2 = [["path", { d: "m8 2 1.88 1.88", key: "fmnt4t" }], ["path", { d: "M14.12 3.88 16 2", key: "qol33r" }], ["path", { d: "M9 7.13v-1a3.003 3.003 0 1 1 6 0v1", key: "d7y7pr" }], ["path", { d: "M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6", key: "xs1cw7" }], ["path", { d: "M12 20v-9", key: "1qisl0" }], ["path", { d: "M6.53 9C4.6 8.8 3 7.1 3 5", key: "32zzws" }], ["path", { d: "M6 13H2", key: "82j7cp" }], ["path", { d: "M3 21c0-2.1 1.7-3.9 3.8-4", key: "4p0ekp" }], ["path", { d: "M20.97 5c0 2.1-1.6 3.8-3.5 4", key: "18gb23" }], ["path", { d: "M22 13h-4", key: "1jl80f" }], ["path", { d: "M17.2 17c2.1.1 3.8 1.9 3.8 4", key: "k3fwyw" }]], s2 = me("bug", i2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const o2 = [["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2", key: "1nb95v" }], ["line", { x1: "8", x2: "16", y1: "6", y2: "6", key: "x4nwl0" }], ["line", { x1: "16", x2: "16", y1: "14", y2: "18", key: "wjye3r" }], ["path", { d: "M16 10h.01", key: "1m94wz" }], ["path", { d: "M12 10h.01", key: "1nrarc" }], ["path", { d: "M8 10h.01", key: "19clt8" }], ["path", { d: "M12 14h.01", key: "1etili" }], ["path", { d: "M8 14h.01", key: "6423bh" }], ["path", { d: "M12 18h.01", key: "mhygvu" }], ["path", { d: "M8 18h.01", key: "lrp35t" }]], ng = me("calculator", o2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const a2 = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], l2 = me("check", a2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const u2 = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]], mi = me("circle-alert", u2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const c2 = [["path", { d: "M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3.5-4-4-6.5c-.5 2.5-2 4.9-4 6.5C6 11.1 5 13 5 15a7 7 0 0 0 7 7z", key: "c7niix" }]], d2 = me("droplet", c2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const f2 = [["path", { d: "M15 3h6v6", key: "1q9fwt" }], ["path", { d: "M10 14 21 3", key: "gplh6r" }], ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]], h2 = me("external-link", f2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const p2 = [["path", { d: "M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z", key: "96xj49" }]], m2 = me("flame", p2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const g2 = [["path", { d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z", key: "c3ymky" }], ["path", { d: "M3.22 12H9.5l.5-1 2 4.5 2-7 1.5 3.5h5.27", key: "1uw2ng" }]], y2 = me("heart-pulse", g2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const v2 = [["path", { d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z", key: "c3ymky" }]], x2 = me("heart", v2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const w2 = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 16v-4", key: "1dtifu" }], ["path", { d: "M12 8h.01", key: "e9boi3" }]], rg = me("info", w2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const S2 = [["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }], ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]], C2 = me("mail", S2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const k2 = [["path", { d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z", key: "1lielz" }]], Yl = me("message-square", k2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const P2 = [["path", { d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z", key: "foiqr5" }]], ap = me("phone", P2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const E2 = [["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }], ["path", { d: "M21 3v5h-5", key: "1q7to0" }], ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }], ["path", { d: "M8 16H3v5", key: "1cv678" }]], j2 = me("refresh-cw", E2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const T2 = [["path", { d: "m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z", key: "7g6ntu" }], ["path", { d: "m2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z", key: "ijws7r" }], ["path", { d: "M7 21h10", key: "1b0cd5" }], ["path", { d: "M12 3v18", key: "108xh3" }], ["path", { d: "M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2", key: "3gwbw2" }]], N2 = me("scale", T2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const M2 = [["path", { d: "M11 2v2", key: "1539x4" }], ["path", { d: "M5 2v2", key: "1yf1q8" }], ["path", { d: "M5 3H4a2 2 0 0 0-2 2v4a6 6 0 0 0 12 0V5a2 2 0 0 0-2-2h-1", key: "rb5t3r" }], ["path", { d: "M8 15a6 6 0 0 0 12 0v-3", key: "x18d4x" }], ["circle", { cx: "20", cy: "10", r: "2", key: "ts1r5v" }]], ig = me("stethoscope", M2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const R2 = [["path", { d: "m18 2 4 4", key: "22kx64" }], ["path", { d: "m17 7 3-3", key: "1w1zoj" }], ["path", { d: "M19 9 8.7 19.3c-1 1-2.5 1-3.4 0l-.6-.6c-1-1-1-2.5 0-3.4L15 5", key: "1exhtz" }], ["path", { d: "m9 11 4 4", key: "rovt3i" }], ["path", { d: "m5 19-3 3", key: "59f2uf" }], ["path", { d: "m14 4 6 6", key: "yqp9t2" }]], A2 = me("syringe", R2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const b2 = [["path", { d: "M14 4v10.54a4 4 0 1 1-4 0V4a2 2 0 0 1 4 0Z", key: "17jzev" }]], D2 = me("thermometer", b2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const L2 = [["path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3", key: "wmoenq" }], ["path", { d: "M12 9v4", key: "juzpu7" }], ["path", { d: "M12 17h.01", key: "p32p05" }]], lp = me("triangle-alert", L2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _2 = [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]], Xl = me("x", _2);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const V2 = [["path", { d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z", key: "1xq2db" }]], I2 = me("zap", V2); function O2({ isOpen: n, onClose: r }) { const [s, a] = M.useState(null), u = "https://forms.gle/7BLqXuBZewnhse1R7", f = "https://forms.gle/sdUy4rzBSJ2aMhUWA", d = "hernan.david.hd@gmail.com", h = () => { window.open(u, "_blank"), r() }, p = () => { window.open(f, "_blank"), r() }, v = () => { const y = s === "bug" ? "Reporte de Error - App Pediatra" : "Sugerencia - App Pediatra"; window.location.href = `mailto:${d}?subject=${encodeURIComponent(y)}&body=${encodeURIComponent("Describe aqu tu " + (s === "bug" ? "error" : "sugerencia") + ":")}` }; return g.jsx(nm, { children: n && g.jsxs(g.Fragment, { children: [g.jsx(Ye.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, onClick: r, className: "fixed inset-0 bg-black/50 z-50 backdrop-blur-sm" }), g.jsxs(Ye.div, { initial: { opacity: 0, scale: .9, y: 20 }, animate: { opacity: 1, scale: 1, y: 0 }, exit: { opacity: 0, scale: .9, y: 20 }, className: "fixed inset-0 m-auto w-full max-w-md h-fit bg-white rounded-3xl shadow-2xl z-50 overflow-hidden", children: [g.jsxs("div", { className: "p-6 bg-gradient-to-r from-blue-600 to-indigo-600 text-white flex justify-between items-center", children: [g.jsx("h2", { className: "text-xl font-bold", children: "Contctanos" }), g.jsx("button", { onClick: r, className: "p-2 hover:bg-white/20 rounded-full transition-colors", children: g.jsx(Xl, { className: "w-6 h-6" }) })] }), g.jsx("div", { className: "p-6", children: s ? g.jsxs("div", { className: "space-y-4", children: [g.jsx("button", { onClick: () => a(null), className: "text-sm text-gray-500 hover:text-gray-700 flex items-center gap-1", children: " Volver" }), g.jsx("h3", { className: "font-bold text-gray-800 text-lg", children: s === "bug" ? "Reportar Error" : "Sugerir Mejora" }), g.jsx("p", { className: "text-sm text-gray-600", children: "Selecciona cmo prefieres contactarnos:" }), g.jsxs("button", { onClick: s === "bug" ? h : p, className: "w-full py-4 px-5 bg-blue-600 text-white rounded-xl font-medium hover:bg-blue-700 transition-all flex items-center justify-between gap-3 group", children: [g.jsxs("div", { className: "flex items-center gap-3", children: [g.jsx(Yl, { className: "w-5 h-5" }), g.jsxs("div", { className: "text-left", children: [g.jsx("div", { className: "font-bold", children: "Formulario Rpido" }), g.jsx("div", { className: "text-xs text-blue-100", children: "Preferido - Respuestas organizadas" })] })] }), g.jsx(h2, { className: "w-5 h-5 group-hover:translate-x-1 transition-transform" })] }), g.jsxs("button", { onClick: v, className: "w-full py-3 px-5 bg-gray-100 text-gray-700 rounded-xl font-medium hover:bg-gray-200 transition-all flex items-center justify-between gap-3", children: [g.jsxs("div", { className: "flex items-center gap-3", children: [g.jsx(C2, { className: "w-5 h-5" }), g.jsx("span", { children: "Enviar por Email" })] }), g.jsx("span", { className: "text-xs text-gray-500", children: d })] }), g.jsxs("div", { className: "bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm text-blue-800", children: [g.jsx("p", { className: "font-medium mb-1", children: " Tip para reportes efectivos:" }), g.jsxs("ul", { className: "text-xs space-y-1 text-blue-700", children: [g.jsx("li", { children: " Describe qu esperabas que pasara" }), g.jsx("li", { children: " Qu pas en realidad" }), g.jsx("li", { children: " En qu seccin ocurri" })] })] })] }) : g.jsxs("div", { className: "space-y-4", children: [g.jsx("p", { className: "text-gray-600 text-sm mb-4", children: "Tu feedback es fundamental para mejorar esta herramienta. Selecciona una opcin:" }), g.jsxs("button", { onClick: () => a("bug"), className: "w-full p-4 bg-red-50 hover:bg-red-100 border-2 border-red-200 rounded-xl flex items-center gap-4 transition-all group", children: [g.jsx("div", { className: "p-3 bg-red-100 rounded-lg group-hover:bg-red-200 transition-colors", children: g.jsx(s2, { className: "w-6 h-6 text-red-600" }) }), g.jsxs("div", { className: "text-left", children: [g.jsx("h3", { className: "font-bold text-red-700", children: "Reportar un Error" }), g.jsx("p", { className: "text-sm text-red-600/80", children: "Algo no funciona como debera" })] })] }), g.jsxs("button", { onClick: () => a("suggestion"), className: "w-full p-4 bg-blue-50 hover:bg-blue-100 border-2 border-blue-200 rounded-xl flex items-center gap-4 transition-all group", children: [g.jsx("div", { className: "p-3 bg-blue-100 rounded-lg group-hover:bg-blue-200 transition-colors", children: g.jsx(Yl, { className: "w-6 h-6 text-blue-600" }) }), g.jsxs("div", { className: "text-left", children: [g.jsx("h3", { className: "font-bold text-blue-700", children: "Sugerir Mejora" }), g.jsx("p", { className: "text-sm text-blue-600/80", children: "Ideas para nuevas funciones" })] })] }), g.jsx("div", { className: "pt-4 border-t border-gray-200", children: g.jsx("p", { className: "text-xs text-gray-500 text-center", children: "Creado por padres para padres" }) })] }) })] })] }) }) } function z2() { const n = kS(), [r, s] = M.useState(!1), a = [{ title: "Ingresar Sntomas ", description: "Gua para describir qu siente tu hijo", icon: ig, color: "blue", path: "/symptoms" }, { title: "Calculadora Lavado ", description: "Prepara la solucin salina exacta", icon: ng, color: "cyan", path: "/nasal-calc" }, { title: "Informacin Padres ", description: "Consejos de cuidado, vacunas y ms", icon: r2, color: "green", path: "/parent-info" }, { title: "Emergencia ", description: "Guas rpidas de primeros auxilios", icon: mi, color: "red", path: "/emergency-parent" }]; return g.jsxs(Ye.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-50 p-6 pb-24", children: [g.jsxs("div", { className: "max-w-md mx-auto space-y-8", children: [g.jsxs("div", { className: "text-center space-y-2 pt-8", children: [g.jsx("div", { className: "inline-block p-4 bg-white rounded-full shadow-md mb-4", children: g.jsx(tg, { className: "w-12 h-12 text-blue-500" }) }), g.jsx("h1", { className: "text-3xl font-bold text-gray-900", children: "Pediatra para Padres " }), g.jsx("p", { className: "text-gray-700 font-medium", children: "Cuidando la salud de tus hijos, paso a paso. " })] }), g.jsx("div", { className: "grid gap-6", children: a.map((u, f) => g.jsx(Ye.button, { initial: { y: 20, opacity: 0 }, animate: { y: 0, opacity: 1 }, transition: { delay: f * .1 }, onClick: () => n(u.path), className: `group relative overflow-hidden bg-${u.color}-100 rounded-3xl shadow-lg hover:shadow-xl transition-all active:scale-98 text-left h-32 flex items-center border-2 border-${u.color}-200`, children: g.jsxs("div", { className: "relative z-10 flex items-center gap-5 p-6 w-full", children: [g.jsx("div", { className: `p-4 bg-white rounded-2xl shadow-sm text-${u.color}-600`, children: g.jsx(u.icon, { className: "w-8 h-8" }) }), g.jsxs("div", { children: [g.jsx("h2", { className: "text-xl font-bold text-gray-900 leading-tight mb-1", children: u.title }), g.jsx("p", { className: "text-sm text-gray-800 font-medium", children: u.description })] })] }) }, u.title)) }), g.jsxs(Ye.button, { onClick: () => s(!0), animate: { rotate: [0, -5, 5, -5, 5, 0] }, transition: { duration: .5, repeat: 1 / 0, repeatDelay: 2, ease: "easeInOut" }, className: "w-full mt-4 flex items-center justify-center gap-2 text-gray-500 hover:text-gray-700 transition-colors py-4 bg-white/50 rounded-2xl border border-gray-100 shadow-sm", children: [g.jsx(Yl, { className: "w-5 h-5" }), g.jsx("span", { className: "font-medium", children: "Sugerencias y Reportes" })] }), g.jsxs("div", { className: "text-center text-sm text-gray-500 mt-12 font-medium", children: [g.jsx("p", { children: "Esta aplicacin es una gua informativa. " }), g.jsx("p", { children: "Ante cualquier duda, consulte a su mdico. " })] })] }), g.jsx(O2, { isOpen: r, onClose: () => s(!1) })] }) } const F2 = [{ id: "resfriado", name: "Resfriado Comn", symptoms: ["mocos", "tos", "estornudos", "fiebre_leve", "malestar"], description: "Infeccin viral comn de la nariz y garganta.", advice: "Reposo, hidratacin y lavados nasales. Consulte si hay dificultad respiratoria." }, { id: "gripe", name: "Gripe (Influenza)", symptoms: ["fiebre_alta", "dolor_cuerpo", "tos_seca", "fatiga", "dolor_cabeza"], description: "Infeccin viral que ataca el sistema respiratorio.", advice: "Mucho lquido y descanso. Consulte si la fiebre es persistente o hay dificultad para respirar." }, { id: "gastroenteritis", name: "Gastroenteritis", symptoms: ["diarrea", "vomitos", "dolor_abdominal", "fiebre_leve"], description: "Inflamacin del estmago e intestinos.", advice: "Lo ms importante es la hidratacin. Ofrezca suero oral poco a poco." }, { id: "otitis", name: "Otitis Media", symptoms: ["dolor_oido", "fiebre", "irritabilidad", "secrecion_oido"], description: "Infeccin del odo medio.", advice: "Puede requerir antibiticos. Consulte a su pediatra para evaluacin." }, { id: "bronquiolitis", name: "Bronquiolitis", symptoms: ["dificultad_respiratoria", "sibilancias", "tos", "fiebre", "rechazo_alimento"], description: "Infeccin pulmonar comn en nios pequeos.", advice: "REQUIERE ATENCIN MDICA. Vigile signos de dificultad respiratoria." }, { id: "roseola", name: "Rosola", symptoms: ["fiebre_alta_repentina", "erupcion_cutanea", "irritabilidad"], description: "Infeccin viral comn que causa fiebre y luego sarpullido.", advice: "Manejo de la fiebre. El sarpullido suele aparecer cuando baja la fiebre." }, { id: "mano_pie_boca", name: "Enfermedad Mano-Pie-Boca", symptoms: ["fiebre", "llagas_boca", "sarpullido_manos_pies", "dolor_garganta"], description: "Infeccin viral contagiosa comn en nios pequeos.", advice: "Alimentos fros y blandos. Hidratacin. Es muy contagioso." }], B2 = [{ id: "fiebre_leve", label: "Fiebre leve (< 38.5C)" }, { id: "fiebre_alta", label: "Fiebre alta (> 38.5C)" }, { id: "fiebre_alta_repentina", label: "Fiebre alta repentina" }, { id: "tos", label: "Tos" }, { id: "tos_seca", label: "Tos seca" }, { id: "mocos", label: "Mocos / Congestin" }, { id: "estornudos", label: "Estornudos" }, { id: "dolor_garganta", label: "Dolor de garganta" }, { id: "dificultad_respiratoria", label: "Dificultad para respirar" }, { id: "sibilancias", label: "Silbidos al respirar" }, { id: "dolor_oido", label: "Dolor de odo" }, { id: "secrecion_oido", label: "Secrecin del odo" }, { id: "vomitos", label: "Vmitos" }, { id: "diarrea", label: "Diarrea" }, { id: "dolor_abdominal", label: "Dolor de barriga" }, { id: "erupcion_cutanea", label: "Manchas en la piel" }, { id: "sarpullido_manos_pies", label: "Granitos en manos/pies" }, { id: "llagas_boca", label: "Llagas en la boca" }, { id: "dolor_cabeza", label: "Dolor de cabeza" }, { id: "dolor_cuerpo", label: "Dolor de cuerpo" }, { id: "fatiga", label: "Cansancio excesivo" }, { id: "irritabilidad", label: "Irritabilidad / Llanto" }, { id: "rechazo_alimento", label: "No quiere comer" }]; function U2() { const [n, r] = M.useState([]), [s, a] = M.useState(!1), u = h => { r(p => p.includes(h) ? p.filter(v => v !== h) : [...p, h]) }, f = () => n.length === 0 ? [] : F2.map(h => { const p = h.symptoms.filter(v => n.includes(v)).length; return { ...h, matchCount: p } }).filter(h => h.matchCount > 0).sort((h, p) => p.matchCount - h.matchCount), d = () => { r([]), a(!1) }; return g.jsxs(Ye.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "min-h-screen bg-slate-50 p-6 pb-24", children: [g.jsxs("div", { className: "flex items-center gap-4 mb-6", children: [g.jsx("button", { onClick: () => window.history.back(), className: "p-2 bg-white rounded-full shadow-sm hover:bg-gray-100 transition-colors", children: g.jsx(Mi, { className: "w-6 h-6 text-gray-600" }) }), g.jsx("h1", { className: "text-2xl font-bold text-slate-800", children: "Chequeo de Sntomas" })] }), g.jsx("div", { className: "bg-blue-100 border-l-4 border-blue-500 p-4 mb-6 rounded-r-lg", children: g.jsxs("div", { className: "flex items-start gap-3", children: [g.jsx(rg, { className: "w-6 h-6 text-blue-600 flex-shrink-0 mt-1" }), g.jsxs("p", { className: "text-sm text-blue-800", children: ["Esta herramienta es solo una gua informativa y ", g.jsx("strong", { children: "NO sustituye el diagnstico mdico" }), ". Si su hijo parece muy enfermo, acuda a urgencias."] })] }) }), s ? g.jsxs(Ye.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, children: [g.jsxs("div", { className: "flex justify-between items-center mb-4", children: [g.jsx("h2", { className: "text-xl font-bold text-gray-800", children: "Posibles Causas" }), g.jsxs("button", { onClick: d, className: "text-blue-600 font-medium flex items-center gap-1 hover:underline", children: [g.jsx(j2, { className: "w-4 h-4" }), "Reiniciar"] })] }), g.jsx("div", { className: "space-y-4 mb-20", children: f().length > 0 ? f().map((h, p) => g.jsxs("div", { className: "bg-white p-5 rounded-2xl shadow-md border-2 border-transparent hover:border-blue-100 transition-colors", children: [g.jsxs("div", { className: "flex justify-between items-start mb-2", children: [g.jsx("h3", { className: "text-lg font-bold text-gray-900", children: h.name }), g.jsxs("span", { className: "px-3 py-1 bg-blue-100 text-blue-700 text-xs font-bold rounded-full", children: [h.matchCount, " coincidencias"] })] }), g.jsx("p", { className: "text-gray-600 text-sm mb-3", children: h.description }), g.jsx("div", { className: "bg-yellow-50 p-3 rounded-lg border border-yellow-200", children: g.jsxs("p", { className: "text-yellow-800 text-sm font-medium flex gap-2", children: [g.jsx(lp, { className: "w-4 h-4 flex-shrink-0 mt-0.5" }), h.advice] }) })] }, h.id)) : g.jsxs("div", { className: "text-center py-12 bg-white rounded-3xl shadow-sm", children: [g.jsx("p", { className: "text-gray-500", children: "No encontramos coincidencias exactas en nuestra base de datos simplificada." }), g.jsx("p", { className: "text-gray-500 mt-2", children: "Por favor, consulte a un mdico para una evaluacin completa." })] }) }), g.jsx("div", { className: "fixed bottom-6 left-0 right-0 px-6", children: g.jsxs("a", { href: "tel:911", className: "w-full max-w-md mx-auto py-4 bg-red-600 text-white rounded-2xl font-bold text-lg shadow-xl hover:bg-red-700 active:scale-95 transition-all flex items-center justify-center gap-2", children: [g.jsx(lp, { className: "w-6 h-6" }), "Llamar a Emergencias"] }) })] }) : g.jsxs(g.Fragment, { children: [g.jsx("p", { className: "text-gray-600 mb-4 font-medium", children: "Seleccione los sntomas que presenta el nio:" }), g.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 gap-3 mb-8", children: B2.map(h => g.jsxs("button", { onClick: () => u(h.id), className: `p-4 rounded-xl text-left transition-all flex items-center justify-between border-2 ${n.includes(h.id) ? "bg-blue-50 border-blue-500 text-blue-700 shadow-md" : "bg-white border-transparent shadow-sm hover:bg-gray-50"}`, children: [g.jsx("span", { className: "font-medium", children: h.label }), n.includes(h.id) && g.jsx(l2, { className: "w-5 h-5 text-blue-600" })] }, h.id)) }), g.jsx("div", { className: "fixed bottom-6 left-0 right-0 px-6", children: g.jsxs("button", { onClick: () => a(!0), disabled: n.length === 0, className: `w-full max-w-md mx-auto py-4 rounded-2xl font-bold text-lg shadow-xl transition-all flex items-center justify-center gap-2 ${n.length > 0 ? "bg-blue-600 text-white hover:bg-blue-700 active:scale-95" : "bg-gray-300 text-gray-500 cursor-not-allowed"}`, children: [g.jsx(ig, { className: "w-6 h-6" }), "Analizar Sntomas"] }) })] })] }) } function H2() { const [n, r] = M.useState(""), [s, a] = M.useState(null), u = () => { const f = parseFloat(n); if (!f || f <= 0) return; let d = 0; f < 10 ? d = 5 : f < 20 ? d = 10 : d = 20, a(d) }; return g.jsxs(Ye.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "min-h-screen bg-cyan-50 p-6", children: [g.jsxs("div", { className: "flex items-center gap-4 mb-8", children: [g.jsx("button", { onClick: () => window.history.back(), className: "p-2 bg-white rounded-full shadow-sm hover:bg-gray-100 transition-colors", children: g.jsx(Mi, { className: "w-6 h-6 text-gray-600" }) }), g.jsx("h1", { className: "text-2xl font-bold text-cyan-900", children: "Calculadora Lavado" })] }), g.jsxs("div", { className: "max-w-md mx-auto space-y-6", children: [g.jsxs("div", { className: "bg-white p-6 rounded-3xl shadow-lg border border-cyan-100", children: [g.jsxs("div", { className: "flex items-center gap-3 mb-6", children: [g.jsx("div", { className: "p-3 bg-cyan-100 rounded-2xl text-cyan-600", children: g.jsx(N2, { className: "w-6 h-6" }) }), g.jsx("h2", { className: "text-lg font-bold text-gray-800", children: "Peso del Nio" })] }), g.jsxs("div", { className: "space-y-4", children: [g.jsxs("div", { children: [g.jsx("label", { className: "block text-sm font-medium text-gray-600 mb-2", children: "Ingrese el peso en Kilogramos (kg)" }), g.jsxs("div", { className: "relative", children: [g.jsx("input", { type: "number", value: n, onChange: f => r(f.target.value), placeholder: "Ej: 12.5", className: "w-full p-4 text-2xl font-bold text-center border-2 border-cyan-200 rounded-2xl focus:border-cyan-500 focus:outline-none text-cyan-900 placeholder-cyan-200" }), g.jsx("span", { className: "absolute right-6 top-1/2 -translate-y-1/2 text-gray-400 font-medium", children: "kg" })] })] }), g.jsxs("button", { onClick: u, disabled: !n, className: `w-full py-4 rounded-xl font-bold text-lg shadow-md transition-all flex items-center justify-center gap-2 ${n ? "bg-cyan-600 text-white hover:bg-cyan-700 active:scale-95" : "bg-gray-200 text-gray-400 cursor-not-allowed"}`, children: [g.jsx(ng, { className: "w-5 h-5" }), "Calcular"] })] })] }), s !== null && g.jsxs(Ye.div, { initial: { opacity: 0, scale: .9 }, animate: { opacity: 1, scale: 1 }, className: "bg-white p-6 rounded-3xl shadow-xl border-2 border-cyan-400", children: [g.jsx("h3", { className: "text-center text-gray-600 font-medium mb-2", children: "Cantidad Recomendada" }), g.jsxs("div", { className: "text-center mb-4", children: [g.jsxs("span", { className: "text-5xl font-black text-cyan-600", children: [s, " - ", s * 2] }), g.jsx("span", { className: "text-xl text-gray-500 font-bold ml-2", children: "ml" })] }), g.jsx("p", { className: "text-center text-cyan-800 font-medium bg-cyan-50 py-2 rounded-lg", children: "por cada fosa nasal" })] }), g.jsx("div", { className: "bg-blue-50 p-5 rounded-2xl border border-blue-200", children: g.jsxs("div", { className: "flex items-start gap-3", children: [g.jsx(rg, { className: "w-5 h-5 text-blue-600 flex-shrink-0 mt-0.5" }), g.jsxs("div", { className: "space-y-2", children: [g.jsx("p", { className: "text-sm text-blue-900 font-medium", children: "Cmo realizar el lavado?" }), g.jsxs("ul", { className: "text-sm text-blue-800 space-y-1 list-disc pl-4", children: [g.jsx("li", { children: "Use suero fisiolgico tibio." }), g.jsx("li", { children: "Incline la cabeza del nio hacia un lado." }), g.jsx("li", { children: "Introduzca el suero con presin constante pero suave." }), g.jsx("li", { children: "Repita en el otro lado." })] })] })] }) })] })] }) } function W2() {
  const [n, r] = M.useState("main"), s = { cuidado: { titulo: "Cuidado Infantil", temas: [{ titulo: "Higiene del beb", contenido: ["Bao diario con agua tibia (no caliente)", "Limpieza del cordn umbilical con alcohol al 70%", "Cambio frecuente de paales", "Limpieza de genitales de adelante hacia atrs", "Corte de uas cuando sea necesario"] }, { titulo: "Sueo seguro", contenido: ["Siempre boca arriba para dormir", "Superficie firme sin almohadas ni peluches", "Temperatura ambiente confortable (18-20C)", "Evitar el sobreabrigo", "Compartir habitacin pero no la cama"] }, { titulo: "Seales de alarma", contenido: ["Fiebre mayor a 38C en menores de 3 meses", "Rechazo completo del alimento", "Llanto inconsolable por ms de 2 horas", "Somnolencia excesiva o dificultad para despertar", "Dificultad respiratoria o labios azulados", "Vmitos persistentes o con sangre", "Diarrea con sangre o signos de deshidratacin"] }] }, alimentacion: { titulo: "Alimentacin Infantil", temas: [{ titulo: "Lactancia materna (0-6 meses)", contenido: ["Exclusiva durante los primeros 6 meses", "A demanda, sin horarios fijos", "Posicin correcta: boca amplia, labios evertidos", "Alternar pechos en cada toma", "La madre debe tener una dieta balanceada", "Hidratacin adecuada de la madre"] }, { titulo: "Alimentacin complementaria (6+ meses)", contenido: ["Inicio a los 6 meses, nunca antes de los 4", "Texturas progresivas: papillas, trozos pequeos", "Un alimento nuevo cada 3-5 das", "Evitar sal, azcar y miel en el primer ao", "Incluir frutas, verduras, cereales, protenas", "Continuar lactancia materna hasta los 2 aos o ms"] }, { titulo: "Alimentos a evitar", contenido: ["Miel (primer ao): riesgo de botulismo", "Frutos secos enteros: riesgo de aspiracin", "Alimentos con mucha sal o azcar", "Bebidas azucaradas y gaseosas", "Embutidos y alimentos procesados"] }] }, vacunacion: { titulo: "Calendario de Vacunacin", temas: [{ titulo: "Vacunas del primer ao", contenido: ["Al nacer: BCG, Hepatitis B", "2 meses: Pentavalente, Rotavirus, Neumococo", "4 meses: Pentavalente, Rotavirus, Neumococo", "6 meses: Pentavalente, Hepatitis B, Influenza", "12 meses: SRP (Sarampin, Rubeola, Parotiditis), Neumococo"] }, { titulo: "Importancia de las vacunas", contenido: ["Previenen enfermedades graves", "Protegen a toda la comunidad", "Son seguras y efectivas", "Pueden producir efectos leves temporales", "El riesgo de enfermarse sin vacuna es mucho mayor"] }, { titulo: "Despus de vacunar", contenido: ["Puede haber fiebre leve o dolor en el sitio", "Aplicar paos fros si hay molestia", "Dar acetaminofn si hay fiebre", "Observar al nio las primeras 24-48 horas", "Consultar si hay reacciones graves"] }] }, desarrollo: { titulo: "Desarrollo Infantil", temas: [{ titulo: "Hitos del desarrollo 0-12 meses", contenido: ["2 meses: Sonre, sigue objetos con la mirada", "4 meses: Se re, agarra objetos, sostiene la cabeza", "6 meses: Se sienta con apoyo, balbucea", '9 meses: Gatea, dice "mam/pap", se para con apoyo', "12 meses: Camina con ayuda, dice 2-3 palabras, seala"] }, { titulo: "Hitos del desarrollo 1-3 aos", contenido: ["18 meses: Camina solo, usa 10-20 palabras, come con cuchara", "2 aos: Corre, sube escaleras, frases de 2 palabras", "3 aos: Salta, pedalea triciclo, frases completas"] }, { titulo: "Estimulacin temprana", contenido: ["Hablar mucho con el beb desde el nacimiento", "Juegos de estimulacin visual y auditiva", "Tiempo boca abajo cuando est despierto", "Lectura de cuentos desde pequeos", "Juego libre y tiempo de calidad", "Evitar pantallas antes de los 2 aos"] }] }, enfermedades: { titulo: "Enfermedades Comunes", temas: [{ titulo: "Resfriado comn", contenido: ["Sntomas: Congestin, mocos, tos, fiebre leve", "Tratamiento: Hidratacin, lavados nasales, reposo", "Duracin: 7-10 das", "Consultar si: fiebre alta persistente, dificultad respiratoria"] }, { titulo: "Diarrea", contenido: ["Causas: Virus, bacterias, intolerancia alimentaria", "Tratamiento: Hidratacin oral frecuente", "Continuar alimentacin normal", "Evitar bebidas azucaradas", "Consultar si: sangre en heces, signos de deshidratacin"] }, { titulo: "Dermatitis del paal", contenido: ["Cambio frecuente de paales", "Limpiar suavemente con agua tibia", "Dejar secar al aire cuando sea posible", "Crema protectora con xido de zinc", "Consultar si no mejora en 3 das"] }] } }; return g.jsx(Ye.div, {
    initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "min-h-screen bg-gradient-to-br from-green-50 to-teal-50 p-6 pb-24", children: g.jsxs("div", {
      className: "max-w-4xl mx-auto", children: [g.jsxs("div", { className: "flex items-center gap-4 mb-6", children: [g.jsx("button", { onClick: () => n === "main" ? window.history.back() : r("main"), className: "p-3 bg-white rounded-full shadow-sm hover:bg-gray-100 transition-all", children: g.jsx(Mi, { className: "w-6 h-6 text-gray-600" }) }), g.jsx("h1", { className: "text-2xl font-bold text-teal-900", children: n === "main" ? "Informacin para Padres" : s[n]?.titulo || "Gua" })] }), n === "main" && g.jsxs(Ye.div, {
        initial: { opacity: 0 }, animate: { opacity: 1 }, className: "grid gap-4", children: [g.jsxs("button", {
          onClick: () => r("cuidado"), className: `w-full bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl active:scale-98 transition-all
                       border-2 border-blue-200 hover:border-blue-400 flex items-center gap-4`, children: [g.jsx("div", { className: "w-16 h-16 bg-blue-100 rounded-xl flex items-center justify-center", children: g.jsx(tg, { className: "w-8 h-8 text-blue-600" }) }), g.jsxs("div", { className: "flex-1 text-left", children: [g.jsx("h3", { className: "text-blue-600 font-bold text-lg", children: "Cuidado Infantil" }), g.jsx("p", { className: "text-gray-600", children: "Higiene, sueo seguro, seales de alarma" })] })]
        }), g.jsxs("button", {
          onClick: () => r("alimentacion"), className: `w-full bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl active:scale-98 transition-all
                       border-2 border-orange-200 hover:border-orange-400 flex items-center gap-4`, children: [g.jsx("div", { className: "w-16 h-16 bg-orange-100 rounded-xl flex items-center justify-center", children: g.jsx(QS, { className: "w-8 h-8 text-orange-600" }) }), g.jsxs("div", { className: "flex-1 text-left", children: [g.jsx("h3", { className: "text-orange-600 font-bold text-lg", children: "Alimentacin" }), g.jsx("p", { className: "text-gray-600", children: "Lactancia, alimentacin complementaria" })] })]
        }), g.jsxs("button", {
          onClick: () => r("vacunacion"), className: `w-full bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl active:scale-98 transition-all
                       border-2 border-purple-200 hover:border-purple-400 flex items-center gap-4`, children: [g.jsx("div", { className: "w-16 h-16 bg-purple-100 rounded-xl flex items-center justify-center", children: g.jsx(A2, { className: "w-8 h-8 text-purple-600" }) }), g.jsxs("div", { className: "flex-1 text-left", children: [g.jsx("h3", { className: "text-purple-600 font-bold text-lg", children: "Vacunacin" }), g.jsx("p", { className: "text-gray-600", children: "Calendario, importancia, efectos" })] })]
        }), g.jsxs("button", {
          onClick: () => r("desarrollo"), className: `w-full bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl active:scale-98 transition-all
                       border-2 border-green-200 hover:border-green-400 flex items-center gap-4`, children: [g.jsx("div", { className: "w-16 h-16 bg-green-100 rounded-xl flex items-center justify-center", children: g.jsx(YS, { className: "w-8 h-8 text-green-600" }) }), g.jsxs("div", { className: "flex-1 text-left", children: [g.jsx("h3", { className: "text-green-600 font-bold text-lg", children: "Desarrollo Infantil" }), g.jsx("p", { className: "text-gray-600", children: "Hitos del desarrollo, estimulacin" })] })]
        }), g.jsxs("button", {
          onClick: () => r("enfermedades"), className: `w-full bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl active:scale-98 transition-all
                       border-2 border-red-200 hover:border-red-400 flex items-center gap-4`, children: [g.jsx("div", { className: "w-16 h-16 bg-red-100 rounded-xl flex items-center justify-center", children: g.jsx(y2, { className: "w-8 h-8 text-red-600" }) }), g.jsxs("div", { className: "flex-1 text-left", children: [g.jsx("h3", { className: "text-red-600 font-bold text-lg", children: "Enfermedades Comunes" }), g.jsx("p", { className: "text-gray-600", children: "Resfriado, diarrea, dermatitis" })] })]
        }), g.jsxs("button", {
          onClick: () => r("sintomas"), className: `w-full bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl active:scale-98 transition-all
                       border-2 border-yellow-200 hover:border-yellow-400 flex items-center gap-4`, children: [g.jsx("div", { className: "w-16 h-16 bg-yellow-100 rounded-xl flex items-center justify-center", children: g.jsx(D2, { className: "w-8 h-8 text-yellow-600" }) }), g.jsxs("div", { className: "flex-1 text-left", children: [g.jsx("h3", { className: "text-yellow-600 font-bold text-lg", children: "Manejo de Sntomas" }), g.jsx("p", { className: "text-gray-600", children: "Fiebre, tos, dolor de cabeza" })] })]
        })]
      }), (n === "cuidado" || n === "alimentacion" || n === "vacunacion" || n === "desarrollo" || n === "enfermedades") && g.jsx(Ye.div, { initial: { opacity: 0, x: 20 }, animate: { opacity: 1, x: 0 }, className: "bg-white rounded-2xl p-6 shadow-xl", children: g.jsx("div", { className: "space-y-6", children: s[n].temas.map((a, u) => g.jsx("div", { children: n === "alimentacion" && a.titulo === "Alimentos a evitar" ? g.jsxs("div", { className: "bg-red-100 p-6 rounded-xl border-4 border-red-500", children: [g.jsxs("h3", { className: "text-red-700 mb-4 flex items-center gap-2 font-bold", children: [g.jsx(Xl, { className: "w-6 h-6" }), a.titulo] }), g.jsx("ul", { className: "space-y-3", children: a.contenido.map((f, d) => g.jsxs("li", { className: "flex items-start gap-3", children: [g.jsx(Xl, { className: "w-5 h-5 text-red-600 flex-shrink-0 mt-1" }), g.jsx("span", { className: "flex-1 text-red-900", children: f })] }, d)) })] }) : g.jsxs("div", { className: "bg-green-50 p-6 rounded-xl border-2 border-green-200", children: [g.jsx("h3", { className: "text-green-700 mb-4 font-bold", children: a.titulo }), g.jsx("ul", { className: "space-y-3", children: a.contenido.map((f, d) => g.jsxs("li", { className: "flex items-start gap-3", children: [g.jsx("div", { className: "w-2 h-2 bg-green-600 rounded-full flex-shrink-0 mt-2" }), g.jsx("span", { className: "flex-1 text-gray-700", children: f })] }, d)) })] }) }, u)) }) }), n === "sintomas" && g.jsx(Ye.div, { initial: { opacity: 0, x: 20 }, animate: { opacity: 1, x: 0 }, className: "bg-white rounded-2xl p-6 shadow-xl", children: g.jsxs("div", { className: "space-y-6", children: [g.jsxs("div", { className: "bg-red-50 p-6 rounded-xl border-2 border-red-200", children: [g.jsx("h3", { className: "text-red-600 mb-4 font-bold text-lg", children: "Fiebre" }), g.jsxs("div", { className: "space-y-3 text-gray-700", children: [g.jsx("p", { children: g.jsx("strong", { children: "Medidas generales:" }) }), g.jsxs("ul", { className: "ml-6 space-y-2", children: [g.jsx("li", { children: " Ropa ligera, no abrigar en exceso" }), g.jsx("li", { children: " Ambiente fresco y ventilado" }), g.jsx("li", { children: " Ofrecer lquidos frecuentemente" }), g.jsx("li", { children: " Bao con agua tibia (NO fra)" })] }), g.jsx("p", { className: "mt-4", children: g.jsx("strong", { children: "Medicamentos:" }) }), g.jsxs("ul", { className: "ml-6 space-y-2", children: [g.jsx("li", { children: " Paracetamol: cada 4-6 horas si es necesario" }), g.jsx("li", { children: " Ibuprofeno (mayor de 6 meses): cada 6-8 horas" }), g.jsx("li", { children: " NO dar aspirina a nios" })] }), g.jsxs("div", { className: "mt-4 p-4 bg-red-100 rounded-lg border-2 border-red-300", children: [g.jsx("p", { className: "text-red-900", children: g.jsx("strong", { children: "Consultar si:" }) }), g.jsxs("ul", { className: "ml-6 mt-2 space-y-1 text-red-900", children: [g.jsx("li", { children: " Menor de 3 meses con fiebre" }), g.jsx("li", { children: " Fiebre mayor a 40C" }), g.jsx("li", { children: " Fiebre por ms de 3 das" }), g.jsx("li", { children: " Convulsiones, rigidez de nuca o alteracin de conciencia" })] })] })] })] }), g.jsxs("div", { className: "bg-blue-50 p-6 rounded-xl border-2 border-blue-200", children: [g.jsx("h3", { className: "text-blue-600 mb-4 font-bold text-lg", children: "Tos" }), g.jsxs("div", { className: "space-y-3 text-gray-700", children: [g.jsx("p", { children: g.jsx("strong", { children: "Medidas generales:" }) }), g.jsxs("ul", { className: "ml-6 space-y-2", children: [g.jsx("li", { children: " Mantener al nio bien hidratado" }), g.jsx("li", { children: " Humidificar el ambiente" }), g.jsx("li", { children: " Elevar la cabecera de la cama" }), g.jsx("li", { children: " Evitar irritantes (humo de cigarrillo)" }), g.jsx("li", { children: " Miel (mayor de 1 ao): 1 cucharadita" })] }), g.jsxs("div", { className: "mt-4 p-4 bg-blue-100 rounded-lg border-2 border-blue-300", children: [g.jsx("p", { className: "text-blue-900", children: g.jsx("strong", { children: "Consultar si:" }) }), g.jsxs("ul", { className: "ml-6 mt-2 space-y-1 text-blue-900", children: [g.jsx("li", { children: " Tos con dificultad para respirar" }), g.jsx("li", { children: " Tos con sangre" }), g.jsx("li", { children: " Tos que dura ms de 2 semanas" }), g.jsx("li", { children: " Tos con fiebre alta persistente" })] })] })] })] }), g.jsxs("div", { className: "bg-purple-50 p-6 rounded-xl border-2 border-purple-200", children: [g.jsx("h3", { className: "text-purple-600 mb-4 font-bold text-lg", children: "Dolor de Cabeza" }), g.jsxs("div", { className: "space-y-3 text-gray-700", children: [g.jsx("p", { children: g.jsx("strong", { children: "Medidas generales:" }) }), g.jsxs("ul", { className: "ml-6 space-y-2", children: [g.jsx("li", { children: " Reposo en ambiente tranquilo y oscuro" }), g.jsx("li", { children: " Aplicar pao fro en la frente" }), g.jsx("li", { children: " Asegurar buena hidratacin" }), g.jsx("li", { children: " Evitar pantallas" })] }), g.jsx("p", { className: "mt-4", children: g.jsx("strong", { children: "Medicamentos:" }) }), g.jsx("ul", { className: "ml-6 space-y-2", children: g.jsx("li", { children: " Paracetamol o Ibuprofeno segn peso" }) }), g.jsxs("div", { className: "mt-4 p-4 bg-purple-100 rounded-lg border-2 border-purple-300", children: [g.jsx("p", { className: "text-purple-900", children: g.jsx("strong", { children: "Consultar si:" }) }), g.jsxs("ul", { className: "ml-6 mt-2 space-y-1 text-purple-900", children: [g.jsx("li", { children: ' Dolor severo o repentino ("el peor dolor de su vida")' }), g.jsx("li", { children: " Con fiebre, rigidez de cuello o vmitos" }), g.jsx("li", { children: " Alteracin de conciencia o visin" }), g.jsx("li", { children: " Despus de golpe en la cabeza" })] })] })] })] })] }) })]
    })
  })
} const $2 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODgiIGhlaWdodD0iODgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBvcGFjaXR5PSIuMyIgZmlsbD0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIzLjciPjxyZWN0IHg9IjE2IiB5PSIxNiIgd2lkdGg9IjU2IiBoZWlnaHQ9IjU2IiByeD0iNiIvPjxwYXRoIGQ9Im0xNiA1OCAxNi0xOCAzMiAzMiIvPjxjaXJjbGUgY3g9IjUzIiBjeT0iMzUiIHI9IjciLz48L3N2Zz4KCg=="; function K2(n) { const [r, s] = M.useState(!1), a = () => { s(!0) }, { src: u, alt: f, style: d, className: h, ...p } = n; return r ? g.jsx("div", { className: `inline-block bg-gray-100 text-center align-middle ${h ?? ""}`, style: d, children: g.jsx("div", { className: "flex items-center justify-center w-full h-full", children: g.jsx("img", { src: $2, alt: "Error loading image", ...p, "data-original-url": u }) }) }) : g.jsx("img", { src: u, alt: f, className: h, style: d, ...p, onError: a }) } function G2() {
  const [n, r] = M.useState("main"), s = [{ id: "atragantamiento", nombre: "Atragantamiento", icon: mi, color: "red" }, { id: "quemaduras", nombre: "Quemaduras", icon: m2, color: "orange" }, { id: "heridas", nombre: "Heridas", icon: d2, color: "red" }, { id: "fracturas", nombre: "Fracturas", icon: t2, color: "blue" }, { id: "convulsiones", nombre: "Convulsiones", icon: I2, color: "purple" }, { id: "rcp", nombre: "RCP Bsica", icon: x2, color: "pink" }], a = u => { const d = { atragantamiento: { titulo: "Atragantamiento", imagen: "https://images.unsplash.com/photo-1542913019-7341c3d3f4d4?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxjaGlsZCUyMGNob2tpbmclMjBoZWltbGljaHxlbnwxfHx8fDE3NjM3NjE1NTR8MA&ixlib=rb-4.1.0&q=80&w=1080", importante: "Si el nio puede toser, llorar o hablar, NO interfiera! Anmelo a toser.", pasos: [{ titulo: "Para bebs menores de 1 ao:", contenido: ["Coloque al beb boca abajo sobre su antebrazo", "D 5 golpes firmes entre los omplatos con el taln de la mano", "Voltee al beb boca arriba", "D 5 compresiones en el centro del pecho con dos dedos", "Repita hasta que el objeto salga o el beb pierda el conocimiento"] }, { titulo: "Para nios mayores de 1 ao:", contenido: ["Prese detrs del nio", "Coloque su puo cerrado justo arriba del ombligo", "Agarre el puo con la otra mano", "D compresiones rpidas hacia adentro y hacia arriba", "Repita hasta que el objeto salga o el nio pierda el conocimiento"] }, { titulo: "Si el nio pierde el conocimiento:", contenido: ["Llame al 911 inmediatamente", "Inicie RCP (vea la gua de RCP bsica)"] }] }, quemaduras: { titulo: "Quemaduras", imagen: "https://images.unsplash.com/photo-1726621380962-d23f3dde9151?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxjaGlsZCUyMGJ1cm4lMjBpbmp1cnl8ZW58MXx8fHwxNzYzNzYxNTU1fDA&ixlib=rb-4.1.0&q=80&w=1080", importante: "NUNCA aplique hielo, mantequilla, pasta dental o remedios caseros.", pasos: [{ titulo: "Pasos inmediatos:", contenido: ["Aleje al nio de la fuente de calor", "Retire ropa y joyas de la zona afectada (si no est pegada a la piel)", "Enfre la quemadura con agua corriente tibia (NO fra) por 10-20 minutos", "NO rompa las ampollas"] }, { titulo: "Cubrir la quemadura:", contenido: ["Use un pao limpio y hmedo", "Si es posible, use gasa estril", "NO aplique presin"] }, { titulo: "Llame al 911 si:", contenido: ["La quemadura es ms grande que la palma de la mano del nio", "Est en cara, manos, pies, genitales o articulaciones", "La piel se ve blanca o carbonizada", "El nio tiene menos de 5 aos", "Es causada por electricidad o qumicos"] }] }, heridas: { titulo: "Heridas", imagen: "https://images.unsplash.com/photo-1758575514478-2cbf66f110aa?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxjaGlsZCUyMHdvdW5kJTIwYmFuZGFnZXxlbnwxfHx8fDE3NjM3NjE1NTV8MA&ixlib=rb-4.1.0&q=80&w=1080", importante: "Use guantes o proteja sus manos para evitar contacto directo con la sangre.", pasos: [{ titulo: "Control de sangrado:", contenido: ["Aplique presin directa con un pao limpio", "Mantenga la presin durante 5-10 minutos sin levantar", "Si el pao se empapa, agregue ms encima (no retire el primero)", "Eleve la parte lesionada por encima del corazn si es posible"] }, { titulo: "Limpieza (solo heridas menores):", contenido: ["Lvese las manos", "Enjuague suavemente con agua limpia", "No use alcohol ni agua oxigenada en heridas profundas"] }, { titulo: "Cubrir la herida:", contenido: ["Use gasa estril o pao limpio", "Asegure con vendaje (no muy apretado)"] }, { titulo: "Llame al 911 si:", contenido: ["El sangrado no se detiene despus de 10 minutos de presin", "La herida es profunda o extensa", "Puede ver hueso, msculo o grasa", "Es una herida punzante profunda", "Fue causada por mordedura de animal o humano"] }] }, fracturas: { titulo: "Fracturas", imagen: "https://images.unsplash.com/photo-1762347920674-13d8bca6cbb4?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxjaGlsZCUyMGJvbmUlMjBmcmFjdHVyZXxlbnwxfHx8fDE3NjM3NjE1NTZ8MA&ixlib=rb-4.1.0&q=80&w=1080", importante: "NO intente enderezar el hueso. NO mueva al nio si sospecha lesin de cuello o espalda.", pasos: [{ titulo: "Inmovilizar:", contenido: ["NO mueva la parte lesionada", "Estabilice en la posicin en que se encuentra", "Use materiales rgidos como frulas improvisadas (revista, cartn)", "Coloque almohadillas suaves entre la frula y la piel", "Asegure con vendajes (NO demasiado apretado)"] }, { titulo: "Control del dolor:", contenido: ["Mantenga al nio tranquilo y cmodo", "Puede aplicar hielo envuelto en una toalla (15 min, descanso 15 min)", "NO d alimentos ni bebidas (puede necesitar ciruga)"] }, { titulo: "Llame al 911 si:", contenido: ["La extremidad est deformada", "Hay prdida de sensibilidad o movimiento", "La piel est fra, plida o azulada", "Sospecha fractura de cuello, espalda, cadera o pelvis", "El hueso perfora la piel"] }] }, convulsiones: { titulo: "Convulsiones", imagen: "https://images.unsplash.com/photo-1620875638370-8957e4dbd830?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxiYWJ5JTIwaW5mYW50JTIwY3ByfGVufDF8fHx8MTc2Mzc2MTU1NHww&ixlib=rb-4.1.0&q=80&w=1080", importante: "NO ponga nada en la boca del nio. NO intente sujetar o restringir los movimientos.", pasos: [{ titulo: "Durante la convulsin:", contenido: ["Mantenga la calma", "Coloque al nio en el suelo o superficie plana", "Gire suavemente al nio de lado", "Retire objetos peligrosos cercanos", "Coloque algo suave bajo su cabeza", "Afloje ropa ajustada alrededor del cuello", "Registre la duracin de la convulsin"] }, { titulo: "Despus de la convulsin:", contenido: ["Mantenga al nio de lado (posicin de recuperacin)", "Revise si respira normalmente", "Mantngase con el nio hasta que est completamente alerta", "El nio puede estar confundido - tranquilcelo"] }, { titulo: "Llame al 911 si:", contenido: ["Es la primera convulsin del nio", "Dura ms de 5 minutos", "Tiene convulsiones repetidas", "No recupera la conciencia", "Tiene dificultad para respirar", "Se lesion durante la convulsin", "La convulsin ocurri en el agua"] }] }, rcp: { titulo: "RCP Bsica", imagen: "https://images.unsplash.com/photo-1620875638370-8957e4dbd830?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3Nzg4Nzd8MHwxfHNlYXJjaHwxfHxiYWJ5JTIwaW5mYW50JTIwY3ByfGVufDF8fHx8MTc2Mzc2MTU1NHww&ixlib=rb-4.1.0&q=80&w=1080", importante: "Si hay otra persona, pdale que llame al 911 mientras usted inicia RCP. Si est solo, haga RCP por 2 minutos antes de llamar.", pasos: [{ titulo: "1. Verificar respuesta:", contenido: ["Toque al nio y grite su nombre", "Si no responde, contine"] }, { titulo: "2. Pedir ayuda:", contenido: ["Grite para pedir ayuda", "Si alguien llega, pdale que llame al 911"] }, { titulo: "3. Posicin:", contenido: ["Coloque al nio boca arriba en superficie firme", "Arrodllese al lado del nio"] }, { titulo: "4. Compresiones (30 veces):", contenido: ["BEBS: Use dos dedos en el centro del pecho", "NIOS: Use una o dos manos en el centro del pecho", "Presione fuerte y rpido (100-120 veces por minuto)", "Profundidad: 1/3 del grosor del pecho", "Deje que el pecho suba completamente entre compresiones"] }, { titulo: "5. Respiraciones (2 veces):", contenido: ["Incline suavemente la cabeza hacia atrs", "Levante el mentn", "Tape la nariz (o cubra nariz y boca en bebs)", "D 2 respiraciones boca a boca de 1 segundo cada una", "El pecho debe elevarse visiblemente"] }, { titulo: "6. Continuar:", contenido: ["Repita ciclos de 30 compresiones y 2 respiraciones", "No se detenga hasta que:", "  - El nio comience a respirar", "  - Llegue ayuda mdica", "  - Est demasiado exhausto para continuar"] }] } }[u]; return g.jsxs("div", { className: "space-y-6", children: [g.jsx("div", { className: "rounded-2xl overflow-hidden shadow-lg", children: g.jsx(K2, { src: d.imagen, alt: d.titulo, className: "w-full h-64 object-cover" }) }), g.jsx("div", { className: "bg-red-100 border-2 border-red-400 rounded-xl p-5", children: g.jsxs("p", { className: "flex items-start gap-3", children: [g.jsx(mi, { className: "w-6 h-6 text-red-600 flex-shrink-0 mt-1" }), g.jsx("span", { className: "text-red-900 font-bold", children: d.importante })] }) }), d.pasos.map((h, p) => g.jsxs("div", { className: "bg-white rounded-xl p-6 border-2 border-gray-200", children: [g.jsx("h3", { className: "text-blue-600 mb-4 font-bold text-lg", children: h.titulo }), g.jsx("ul", { className: "space-y-3", children: h.contenido.map((v, y) => g.jsxs("li", { className: "flex items-start gap-3", children: [g.jsx("div", { className: "w-2 h-2 bg-blue-600 rounded-full flex-shrink-0 mt-2" }), g.jsx("span", { className: "flex-1 text-gray-700", children: v })] }, y)) })] }, p))] }) }; return g.jsx(Ye.div, {
    initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, className: "min-h-screen bg-gradient-to-br from-red-50 to-orange-50 p-6 pb-24", children: g.jsxs("div", {
      className: "max-w-4xl mx-auto", children: [g.jsx("div", { className: "bg-red-600 text-white rounded-2xl p-6 mb-6 shadow-xl", children: g.jsxs("div", { className: "flex items-center gap-4 mb-2", children: [g.jsx("button", { onClick: () => n === "main" ? window.history.back() : r("main"), className: "p-3 bg-white/20 hover:bg-white/30 rounded-xl active:scale-95 transition-all", children: g.jsx(Mi, { className: "w-6 h-6" }) }), g.jsxs("div", { className: "flex-1", children: [g.jsx("h1", { className: "text-white font-bold text-2xl", children: "EMERGENCIA" }), g.jsx("p", { className: "text-red-100", children: "Gua para Padres y Cuidadores" })] }), g.jsx(mi, { className: "w-12 h-12" })] }) }), n === "main" && g.jsxs(Ye.div, {
        initial: { opacity: 0 }, animate: { opacity: 1 }, className: "space-y-4", children: [g.jsx("div", { className: "bg-yellow-100 border-2 border-yellow-400 rounded-2xl p-6 mb-6", children: g.jsxs("div", { className: "flex items-start gap-4", children: [g.jsx(mi, { className: "w-8 h-8 text-yellow-700 flex-shrink-0" }), g.jsxs("div", { children: [g.jsx("h3", { className: "text-yellow-900 mb-2 font-bold", children: "IMPORTANTE!" }), g.jsx("p", { className: "text-yellow-900", children: "Si tiene dudas sobre la gravedad de la situacin, llame al 911 de inmediato. Es mejor prevenir que lamentar." })] })] }) }), g.jsxs("a", {
          href: "tel:911", className: `w-full bg-gradient-to-r from-red-600 to-red-700 text-white p-8 rounded-2xl shadow-lg 
                       hover:shadow-xl active:scale-98 transition-all flex items-center gap-4 justify-center mb-6`, children: [g.jsx(ap, { className: "w-10 h-10" }), g.jsxs("div", { className: "text-left", children: [g.jsx("p", { className: "text-red-100 text-lg", children: "Llamada de Emergencia" }), g.jsx("p", { className: "text-white text-3xl font-bold", children: "911" })] })]
        }), g.jsx("h2", { className: "text-gray-700 mb-4 font-bold text-xl", children: "Guas de Primeros Auxilios:" }), s.map(u => g.jsxs("button", {
          onClick: () => r(u.id), className: `w-full bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl active:scale-98 transition-all
                         border-2 border-gray-200 hover:border-red-400 flex items-center gap-4`, children: [g.jsx("div", { className: `w-16 h-16 bg-${u.color}-100 rounded-xl flex items-center justify-center`, children: g.jsx(u.icon, { className: `w-8 h-8 text-${u.color}-600` }) }), g.jsxs("div", { className: "flex-1 text-left", children: [g.jsx("h3", { className: "text-gray-900 font-bold text-lg", children: u.nombre }), g.jsx("p", { className: "text-gray-600", children: "Instrucciones paso a paso" })] })]
        }, u.id)), g.jsxs("div", { className: "bg-white rounded-2xl p-6 shadow-xl border-2 border-blue-200 mt-6", children: [g.jsx("h3", { className: "text-blue-600 mb-4 font-bold text-lg", children: "Nmeros de Emergencia" }), g.jsxs("div", { className: "space-y-3", children: [g.jsxs("div", { className: "flex items-center justify-between p-4 bg-blue-50 rounded-xl", children: [g.jsx("span", { className: "font-medium text-blue-900", children: "Ambulancia / Emergencias" }), g.jsx("a", { href: "tel:911", className: "px-6 py-2 bg-blue-600 text-white rounded-lg active:scale-95 transition-all font-bold", children: "911" })] }), g.jsxs("div", { className: "p-4 bg-gray-50 rounded-xl", children: [g.jsx("p", { className: "mb-2 font-bold text-gray-700", children: "Qu decir al llamar al 911:" }), g.jsxs("ul", { className: "space-y-1 text-gray-600", children: [g.jsx("li", { children: " Su ubicacin exacta" }), g.jsx("li", { children: " Qu sucedi" }), g.jsx("li", { children: " Edad del nio" }), g.jsx("li", { children: " Estado actual (respira?, est consciente?)" }), g.jsx("li", { children: " NO cuelgue hasta que se lo indiquen" })] })] })] })] })]
      }), n !== "main" && g.jsxs(Ye.div, {
        initial: { opacity: 0, x: 20 }, animate: { opacity: 1, x: 0 }, className: "bg-gray-50 rounded-2xl p-6 shadow-xl", children: [g.jsxs("div", { className: "flex items-center gap-4 mb-6", children: [g.jsx("button", { onClick: () => r("main"), className: "p-3 bg-white hover:bg-gray-100 rounded-xl active:scale-95 transition-all shadow", children: g.jsx(Mi, { className: "w-6 h-6" }) }), g.jsx("h2", { className: "flex-1 text-red-600 font-bold text-xl", children: s.find(u => u.id === n)?.nombre })] }), a(n), g.jsxs("a", {
          href: "tel:911", className: `w-full bg-gradient-to-r from-red-600 to-red-700 text-white p-6 rounded-2xl shadow-lg 
                       hover:shadow-xl active:scale-98 transition-all flex items-center gap-4 justify-center mt-6`, children: [g.jsx(ap, { className: "w-8 h-8" }), g.jsx("span", { className: "font-bold text-lg", children: "Llamar al 911" })]
        })]
      })]
    })
  })
} function q2() { return g.jsx("div", { className: "min-h-screen bg-gradient-to-br from-blue-50 to-indigo-50 overflow-hidden font-sans", children: g.jsx(nm, { mode: "wait", children: g.jsxs(FS, { children: [g.jsx(hr, { path: "/", element: g.jsx(z2, {}) }), g.jsx(hr, { path: "/symptoms", element: g.jsx(U2, {}) }), g.jsx(hr, { path: "/nasal-calc", element: g.jsx(H2, {}) }), g.jsx(hr, { path: "/parent-info", element: g.jsx(W2, {}) }), g.jsx(hr, { path: "/emergency-parent", element: g.jsx(G2, {}) })] }) }) }) } c0.createRoot(document.getElementById("root")).render(g.jsx(HS, { basename: "/Pediatriaparapadres/", children: g.jsx(q2, {}) }));
